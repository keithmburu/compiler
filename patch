From f04deb47ee63ac64d4bece294eae8da96117d1ad Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Fri, 20 May 2022 17:27:13 +0300
Subject: [PATCH] edit

---
 Compiler | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Compiler b/Compiler
new file mode 160000
index 0000000000000000000000000000000000000000..a0339f4fd01790127bc51fc1da091d5742115811
--- /dev/null
+++ b/Compiler
@@ -0,0 +1 @@
+Subproject commit a0339f4fd01790127bc51fc1da091d5742115811

From 38238f68842b60d67f0ed5f72c888a878bf6c77f Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Fri, 20 May 2022 17:36:52 +0300
Subject: [PATCH] edit

---
 Compiler                                           |    1 -
 Compiler/.cproject                                 |   72 +
 Compiler/.gitignore                                |    8 +
 Compiler/.project                                  |   82 +
 Compiler/AST.cc                                    |  242 +++
 Compiler/AST.h                                     |  245 +++
 Compiler/CMakeLists.txt                            |   18 +
 Compiler/ContextInfo.cc                            |   46 +
 Compiler/ContextInfo.h                             |   22 +
 Compiler/Dictionary.cpp                            |  124 ++
 Compiler/Dictionary.h                              |  101 ++
 Compiler/README-Collaboration.txt                  |    1 +
 Compiler/README-Design.txt                         |   16 +
 Compiler/README_Sources.txt                        |    1 +
 Compiler/generateHERA.cc                           |  238 +++
 Compiler/main.cc                                   |  132 ++
 Compiler/parser.cc                                 |  241 +++
 Compiler/parser.h                                  |   18 +
 Compiler/scanner-regexp.cc                         | 1871 ++++++++++++++++++++
 Compiler/scanner-regexp.h                          |   13 +
 Compiler/scanner-regexp.l                          |   62 +
 Compiler/scanner.cc                                |   82 +
 Compiler/scanner.h                                 |   27 +
 Compiler/scannerDemo.cc                            |   16 +
 Compiler/scannerDemo.h                             |   13 +
 Compiler/streams.h                                 |    3 +
 Compiler/tests/01-multiply.hrk                     |    1 +
 Compiler/tests/02-add-and-mult.hrk                 |    1 +
 Compiler/tests/03-mult-input.hrk                   |    1 +
 Compiler/tests/04-mult-exit.hrk                    |    1 +
 ...ithmetic or comparison operation type error.txt |    1 +
 Compiler/tests/comparison.txt                      |    1 +
 Compiler/tests/if type error.txt                   |    1 +
 Compiler/tests/if.txt                              |    1 +
 Compiler/tests/let.txt                             |    1 +
 Compiler/tests/letstar.txt                         |    1 +
 Compiler/tests/nested let.txt                      |    1 +
 Compiler/tests/nested letstar.txt                  |    1 +
 38 files changed, 3706 insertions(+), 1 deletion(-)

diff --git a/Compiler b/Compiler
deleted file mode 160000
index a0339f4fd01790127bc51fc1da091d5742115811..0000000000000000000000000000000000000000
--- a/Compiler
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit a0339f4fd01790127bc51fc1da091d5742115811
diff --git a/Compiler/.cproject b/Compiler/.cproject
new file mode 100644
index 0000000000000000000000000000000000000000..187849bc6ae681ba924a946dd7fa6428d1fb0f9a
--- /dev/null
+++ b/Compiler/.cproject
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="cdt.managedbuild.config.gnu.exe.debug.1161916250">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" moduleId="org.eclipse.cdt.core.settings" name="Debug">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.MakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactExtension="" artifactName="Compiler-C++" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" errorParsers="org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.GASErrorParser" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" name="Debug" parent="cdt.managedbuild.config.gnu.exe.debug">
+					<folderInfo id="cdt.managedbuild.config.gnu.exe.debug.1161916250.1127859407" name="/" resourcePath="">
+						<toolChain id="cdt.managedbuild.toolchain.gnu.exe.debug.1737210637" name="GCC Tool Chain" superClass="cdt.managedbuild.toolchain.gnu.exe.debug">
+							<targetPlatform id="cdt.managedbuild.target.gnu.platform.exe.debug.1043903385" name="Debug Platform" superClass="cdt.managedbuild.target.gnu.platform.exe.debug"/>
+							<builder buildPath="${workspace_loc:/Interpreter-C++/Debug}" id="cdt.managedbuild.target.gnu.builder.exe.debug.1885040107" keepEnvironmentInBuildfile="false" name="Gnu Make Builder" superClass="cdt.managedbuild.target.gnu.builder.exe.debug"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug.1315278191" name="GCC C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug">
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.compiler.option.include.paths.668525549" name="Include paths (-I)" superClass="gnu.cpp.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
+									<listOptionValue builtIn="false" value="/home/courses/include"/>
+								</option>
+								<option id="gnu.cpp.compiler.exe.debug.option.optimization.level.793100283" name="Optimization Level" superClass="gnu.cpp.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.optimization.level.none" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.exe.debug.option.debugging.level.1408142720" name="Debug Level" superClass="gnu.cpp.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.debugging.level.max" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.option.dialect.std.1577870906" name="Language standard" superClass="gnu.cpp.compiler.option.dialect.std" useByScannerDiscovery="true" value="gnu.cpp.compiler.dialect.c++1y" valueType="enumerated"/>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.compiler.input.842239186" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.c.compiler.exe.debug.351478677" name="GCC C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.exe.debug">
+								<option defaultValue="gnu.c.optimization.level.none" id="gnu.c.compiler.exe.debug.option.optimization.level.1879412635" name="Optimization Level" superClass="gnu.c.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" valueType="enumerated"/>
+								<option id="gnu.c.compiler.exe.debug.option.debugging.level.648859551" name="Debug Level" superClass="gnu.c.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.c.debugging.level.max" valueType="enumerated"/>
+								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.219263748" superClass="cdt.managedbuild.tool.gnu.c.compiler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.c.linker.exe.debug.370219233" name="GCC C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.exe.debug"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug.1321052876" name="GCC C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug">
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.libs.311614395" name="Libraries (-l)" superClass="gnu.cpp.link.option.libs" useByScannerDiscovery="false" valueType="libs">
+									<listOptionValue builtIn="false" value="courses"/>
+								</option>
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.paths.603027165" name="Library search path (-L)" superClass="gnu.cpp.link.option.paths" useByScannerDiscovery="false" valueType="stringList">
+									<listOptionValue builtIn="false" value="/home/courses/lib"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.linker.input.2141151307" superClass="cdt.managedbuild.tool.gnu.cpp.linker.input">
+									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
+									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
+								</inputType>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.assembler.exe.debug.1455701237" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.exe.debug">
+								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.1492382276" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.archiver.base.1329154531" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.base"/>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="Interpreter-C++.cdt.managedbuild.target.gnu.exe.1148232902" name="Executable (Gnu)" projectType="cdt.managedbuild.target.gnu.exe"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration"/>
+	<storageModule moduleId="refreshScope" versionNumber="2">
+		<configuration configurationName="Debug">
+			<resource resourceType="PROJECT" workspacePath="/Compiler-C++"/>
+		</configuration>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+	<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
+</cproject>
diff --git a/Compiler/.gitignore b/Compiler/.gitignore
new file mode 100644
index 0000000000000000000000000000000000000000..53afa4bd2ed50486fa864ebe3ff0741b409cd07f
--- /dev/null
+++ b/Compiler/.gitignore
@@ -0,0 +1,8 @@
+*~
+#*#
+cmake-build-debug
+Debug
+.settings
+.idea
+.DS_Store
+Compiler.out
diff --git a/Compiler/.project b/Compiler/.project
new file mode 100644
index 0000000000000000000000000000000000000000..0984b263388088ba78e995b6649bd345b6792269
--- /dev/null
+++ b/Compiler/.project
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Compiler-C++</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>make</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<value>${workspace_loc:/Tree-C++/Debug}</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/Compiler/AST.cc b/Compiler/AST.cc
new file mode 100644
index 0000000000000000000000000000000000000000..f724dd37ddd777df0831046ff320488ece022f1a
--- /dev/null
+++ b/Compiler/AST.cc
@@ -0,0 +1,242 @@
+#include <hc_list.h>
+#include <hc_list_helpers.h>
+#include "parser.h"  // for n_errors count; this should really be refactored
+#include "streams.h"
+
+using std::string;
+using std::endl;
+using HaverfordCS::list;
+
+
+#include <fstream>  /* needed for ofstream below */
+#if defined TRACE_EXPR_ALLOCATIONS
+static std::ofstream  alloc_trace(TRACE_EXPR_ALLOCATIONS);
+#else
+// by default, allow option for control via environment variable, but it's not given, send to /dev/null (disappears)
+static std::ofstream alloc_trace(getenv("HAVERRACKET_ALLOC_TRACE")?getenv("HAVERRACKET_ALLOC_TRACE"):"/dev/null");
+// static std::ofstream &alloc_trace = trace;  // alternate easy option, just send to regular trace
+#endif
+
+
+
+// This file has the constructors and destructors;
+//   all the generateHERA methods are together in generateHERA.cc
+
+
+// C++ Usage Note:
+// The v(value) is like having v=value, but initializes v rather than assigning to it
+// i.e., writing "v = value" in the constructor _body_ is like writing
+// i.e., writing "v = value" in the constructor _body_ is like writing
+//     int i;
+//     i = 12;
+// whereas writing v(value) before the body is like writing
+//     int i=12;  // i is created with "12" from the start
+//
+// Those steps, as the call(s) to any superclass(es)' constructors, are done before the body of the IntLiteralNode itself
+IntLiteralNode::IntLiteralNode(int value) : v(value)
+{
+	// nothing else needs to be done here, since the stuff above defines "v" as "value"
+	alloc_trace << "(class IntLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
+}
+
+BoolLiteralNode::BoolLiteralNode(string value) : v((value == "#t")? 1 : 0)
+{
+    // nothing else needs to be done here, since the stuff above defines "v" as "value"
+    alloc_trace << "(class BoolLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
+}
+
+// (so, we should see this trace before the one above, for each int literal node)
+ExprNode::ExprNode()
+{
+	alloc_trace << "[superclass ExprNode constructor  called for node at memory " << this << endl;
+}
+
+ComparisonNode::ComparisonNode(string op, ExprNode *lhs, ExprNode *rhs) :
+	o(op),
+	left(lhs),
+	right(rhs)
+{
+	alloc_trace << "(class ComparisonNode constructor called for node at memory " << this << endl;
+}
+
+ArithmeticNode::ArithmeticNode(string op, list<ExprNode *>operands) :
+	o(op),
+	subexps(operands)
+{
+	alloc_trace << "(class ArithmeticNode constructor called for node at memory " << this << endl;
+}
+
+
+VarUseNode::VarUseNode(string name) : n(name)
+{
+	alloc_trace << "(class     VarUseNode constructor called for node at memory " << this << endl;
+}
+
+CallNode::CallNode(string funcName, HaverfordCS::list<ExprNode *>arguments) :
+	n(funcName),
+	argList(arguments)
+{
+	alloc_trace << "(class       CallNode constructor called for node at memory " << this << endl;
+}
+
+IfNode::IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse) :
+    condition(condition),
+    expriftrue(expriftrue),
+    expriffalse(expriffalse)
+{
+    alloc_trace << "(class IfNode constructor called for node at memory " << this << endl;
+}
+
+LetNode::LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions) :
+        declarations(declarations),
+        expressions(expressions)
+{
+    alloc_trace << "(class LetNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationsNode::DeclarationsNode(HaverfordCS::list<ExprNode *> declarations) :
+        declarations(declarations)
+{
+    alloc_trace << "(class DeclarationsNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType) :
+        variable(variable),
+        intLiteral(intLiteral),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType) :
+        variable(variable),
+        boolLiteral(boolLiteral),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType) :
+        variable(variable),
+        definedVar(definedVar),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, ExprNode *expr, string declType) :
+        variable(variable),
+        expr(expr),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+// C++ Usage notes:
+//   When an object is destroyed, either because it is on the stack, e.g. as a variable,
+//     or because it is on the free-store heap, the _destructor(s)_ for the object,
+//     including those for the superclass(es) and data fields, are called before
+//     the memory for the object is released for potential re-use
+//     (destructors are called for those fields as they are released,
+//     and the superclass destructor is used after the class' own destructor is done).
+//
+//   Note that _pointers_ do not have destructor methods, so while e.g. when a "+" node
+//     goes away, the "string o" data field in the ArithmeticNode will automatically run,
+//     but nothing happens (by default) for the trees _pointed_to_ by "subexps".
+//     (ArithmeticNode's destructor also runs, of course, and so _it_ may take care of subexps)
+
+ExprNode::~ExprNode()  // nothing to do, but this ensures all subclasses will have virtual destructors, which C++ likes
+{
+	alloc_trace << " superclass ExprNode destructor   called for node at memory " << this << "]" << endl;
+}
+
+IntLiteralNode::~IntLiteralNode()
+{
+	alloc_trace << " class IntLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
+	// nothing needs to be done here,
+	//  except for tracing we could have omitted this.
+}
+
+BoolLiteralNode::~BoolLiteralNode()
+{
+    alloc_trace << " class BoolLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
+    // nothing needs to be done here,
+    //  except for tracing we could have omitted this.
+}
+
+#if FREE_AST_VIA_DESTRUCTORS
+
+// Memory management strategy:
+//   In a _Tree_, we know that any node will have at most one parent.
+//   Since the parser returns a pointer to the _root_,
+//     and no methods give access to any node's child pointers,
+//     we know that, when the root goes away, all the sub-trees can go away too.
+//   So, when the main program "delete"s the root,
+//     that will trigger the root's destructor; if that delete's any tree children,
+//     the whole thing will then be destroyed recursively.
+
+// Note that no destructor is needed for "IntLiteralNode".
+//   It has no subtrees, and data fields go away automatically when the node is deleted
+
+// In contrast, a ComparisonNode has subtree pointers "left" and "right".
+//   When we delete a ComparisonNode, those _pointers_ go away,
+//   but the trees on the free-store heap will last until we delete them.
+//   Since, as noted, we know there are no other pointers to them,
+//   we delete them when the ComparisonNode goes away:
+
+ComparisonNode::~ComparisonNode()
+{
+	alloc_trace << " class ComparisonNode  destructor called for node at memory " << this << ")" << endl;
+
+	delete left;
+	delete right;
+}
+
+void deleteAllSubtrees(list<ExprNode *>subtrees)
+{
+	if (!empty(subtrees)) {
+		delete head(subtrees);
+		deleteAllSubtrees(rest(subtrees));
+	}
+}
+
+ArithmeticNode::~ArithmeticNode()
+{
+	alloc_trace << " class ArithmeticNode  destructor called for node at memory " << this << ")" << endl;
+	
+	deleteAllSubtrees(subexps);
+}
+
+VarUseNode::~VarUseNode()
+{
+	alloc_trace << " class     VarUseNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+CallNode::~CallNode()
+{
+	alloc_trace << " class       CallNode  destructor called for node at memory " << this << ")" << endl;
+	
+	deleteAllSubtrees(argList);
+}
+
+IfNode::~IfNode()
+{
+    alloc_trace << " class     IfNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+LetNode::~LetNode()
+{
+    alloc_trace << " class     LetNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+DeclarationsNode::~DeclarationsNode()
+{
+    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+DeclarationNode::~DeclarationNode()
+{
+    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+#endif
diff --git a/Compiler/AST.h b/Compiler/AST.h
new file mode 100644
index 0000000000000000000000000000000000000000..07e3b7ceebfc3d09d688f4fd3db3742408d00b45
--- /dev/null
+++ b/Compiler/AST.h
@@ -0,0 +1,245 @@
+#ifndef AST_H_
+#define AST_H_
+
+#include <string>
+#include <hc_list.h>
+#include "ContextInfo.h"
+#include "Dictionary.h"
+
+
+/*
+ *  This file defines the heirarchy of different kinds of AST nodes.
+ *  Currently we have:
+ *    ExprNode (an "interface" class for expressions, with the following concrete subclasses ("implementers" of the interface):
+ *	IntLiteralNode(int value)
+ *	ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs)
+ *	ArithmeticNode(std::string op, list<ExprNode *>)
+ *	VarUseNode(std::string name)
+ *	CallNode(std::string name, HaverfordCS::list<ExprNode *>arguments)
+ *
+ *  The "generateHERA" methods are usually called by calling generateFullHERA on the root,
+ *      which puts "CBON" at the start.
+ */
+
+#if ! defined FREE_AST_VIA_DESTRUCTORS
+#define FREE_AST_VIA_DESTRUCTORS true
+#endif
+
+// C++ Usage Note:
+// The empty class definition of ContextInfo below lets us declare "const ContextInfo &" parameters
+//   without having to define the whole class here, which is fine because, at this point,
+//   we don't care much about what's in it ... we just need to know that there's some way
+//   to pass information down to the subtrees as we evaluate them.
+
+
+// Define the information will we need to pass down the tree as we generate code, see ContextInfo.h
+class ContextInfo;
+
+extern Dictionary declarationDict;
+
+// C++ Usage Note:
+//
+// The word "virtual" is needed in C++ when inheritance is use,
+//   to explicitly tell the compiler that we might override a function in a subclass
+// Java has the correct default of allowing this, and the keyword "final" prevents it.
+//   Many C++ compilers fail to complain if you forget the word "virtual" and override a method anyway :-(
+//
+// Putting "= 0" at the end of a virtual function declaration means
+//   that the method _must_ be overridden in subclasses
+//
+// Classes with virtual functions and (in subclasses) data with destructors need to have
+//  virtual destructors, to help the C++ compiler be sure the right data destructors are called
+
+
+// Class ExprNode is an interface that defines the methods that all
+//   expression nodes in our AST will provide
+// C++ does not have Java's "interface" keyword, so instead
+//   we just create a superclass with no data and all functions virtual
+
+class ExprNode {
+public:
+	ExprNode();           // just used for memory allocation labs, to print trace information
+	virtual ~ExprNode();  // used for actual memory allocation, sometimes, and for tracing
+
+    virtual std::string generateHERA(const ContextInfo &info) const = 0;
+    virtual std::string getType() const = 0;
+
+    ExprNode* operator==(ExprNode *other) {
+        this->type = other->type;
+        return this;
+    }
+private:
+    std::string type;
+};
+
+std::string generateFullHERA(ExprNode *presumedRoot);
+
+
+
+// Now, the various specific kinds of expressions we might have:
+
+class IntLiteralNode : public ExprNode {
+	public:
+		IntLiteralNode(int value);
+		~IntLiteralNode();  // just used for trace output
+
+        int getValue() const { return v; }
+        std::string getType() const { return type; }
+
+		std::string generateHERA(const ContextInfo &info) const;
+	private:
+		int v;  // the value
+        const std::string type = "IntLiteralNode";
+};
+
+class BoolLiteralNode : public ExprNode {
+public:
+    BoolLiteralNode(std::string value);
+    ~BoolLiteralNode();  // just used for trace output
+
+    int getValue() const { return v; }
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    int v;  // the value
+    const std::string type = "BoolLiteralNode";
+};
+
+class ComparisonNode : public ExprNode {  // <= etc., _inherently_binary_ in HaverRacket
+public:
+    ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~ComparisonNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    std::string o;
+    ExprNode *left;
+    ExprNode *right;
+    const std::string type = "ComparisonNode";
+};
+
+class ArithmeticNode : public ExprNode {  // +, *, -, etc.
+	public:
+		ArithmeticNode(std::string op, HaverfordCS::list<ExprNode *>);
+#if FREE_AST_VIA_DESTRUCTORS
+		~ArithmeticNode();
+#endif
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string o;
+		HaverfordCS::list<ExprNode *>subexps;
+        const std::string type = "ArithmeticNode";
+};
+
+/*
+   This represents the use of an identifier as an expression, e.g. the x in (* x 6).
+   Note that identifiers also exist in variable declarations, e.g. (let ((x 7)) ... )
+     but the x there doesn't count as an _expression_ since we're not asking for its value.
+ */
+class VarUseNode : public ExprNode {
+	public:
+		VarUseNode(std::string name);
+		~VarUseNode();
+
+        std::string getValue() const { return n; }
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string n;
+        const std::string type = "VarUseNode";
+};
+
+
+class CallNode : public ExprNode {
+	public:
+		CallNode(std::string funcName, HaverfordCS::list<ExprNode *>arguments);
+#if FREE_AST_VIA_DESTRUCTORS
+		~CallNode();
+#endif
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string n;  // the name
+		HaverfordCS::list<ExprNode *>argList;
+        const std::string type = "CallNode";
+};
+
+class IfNode : public ExprNode {
+public:
+    IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~IfNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    ExprNode *condition;
+    ExprNode *expriftrue;
+    ExprNode *expriffalse;
+    const std::string type = "IfNode";
+};
+
+class DeclarationsNode : public ExprNode {
+public:
+    DeclarationsNode(HaverfordCS::list<ExprNode *> declarations);
+    HaverfordCS::list<ExprNode *> getDeclarations();
+    std::string declarationsHelper(std::string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const;
+#if FREE_AST_VIA_DESTRUCTORS
+    ~DeclarationsNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    HaverfordCS::list<ExprNode *> declarations;
+    const std::string type = "DeclarationsNode";
+};
+
+class DeclarationNode : public ExprNode {
+public:
+    DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType);
+    DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType);
+    DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType);
+    DeclarationNode(VarUseNode variable, ExprNode *expr, string declType);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~DeclarationNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    VarUseNode variable;
+    VarUseNode definedVar = VarUseNode("defaultVar");
+    std::string declType;
+    IntLiteralNode intLiteral = IntLiteralNode(0);
+    BoolLiteralNode boolLiteral = BoolLiteralNode("#f");
+    ExprNode *expr = new IntLiteralNode(0);
+    const std::string type = "DeclarationNode";
+};
+
+class LetNode : public ExprNode {
+public:
+    LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~LetNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+    std::string expressionsHelper(std::string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const;
+    private:
+    ExprNode *declarations;
+    HaverfordCS::list<ExprNode *> expressions;
+    const std::string type = "LetNode";
+};
+
+#endif /*AST_H_*/
diff --git a/Compiler/CMakeLists.txt b/Compiler/CMakeLists.txt
new file mode 100644
index 0000000000000000000000000000000000000000..7cb37994904c3d06c0f02dba37ab1c2099289280
--- /dev/null
+++ b/Compiler/CMakeLists.txt
@@ -0,0 +1,18 @@
+cmake_minimum_required(VERSION 3.1)
+project(Compiler_C++)
+
+set(CMAKE_CXX_STANDARD 20)
+
+add_executable(Compiler_C++
+  scanner-regexp
+  scanner
+  scannerDemo
+  parser
+  AST
+  ContextInfo
+  generateHERA
+  main
+  Dictionary
+)
+
+include_directories(../HaverfordCS/include /home/courses/include)
diff --git a/Compiler/ContextInfo.cc b/Compiler/ContextInfo.cc
new file mode 100644
index 0000000000000000000000000000000000000000..01b49eebb2aa8a5193237087a85e5b882806518e
--- /dev/null
+++ b/Compiler/ContextInfo.cc
@@ -0,0 +1,46 @@
+#include "ContextInfo.h"
+#include <string.h>
+
+// To provide unique register numbers for each subexpression, with leftmost-executed-first
+//   we'll start with 1 at the root, make the rightmost child's number same as its parent,
+//   and make each other child one more than the sibling to its right.
+
+static const int minRegNum= 1;  // Lowest  register number we're going to use
+static const int maxRegNum=10;  // Highest register number we're going to use
+static const char labeler[] = "abcdefghijklmnopqrstuvwxyz";
+std::string label;
+
+ContextInfo::ContextInfo():
+	myRegNumber(maxRegNum)
+{
+}
+
+// Private constructor for use in e.g. evalThisFirst
+ContextInfo::ContextInfo(int r):
+	myRegNumber(r)
+{
+}
+
+ContextInfo ContextInfo::evalThisAfter() const
+{
+	if (myRegNumber <= minRegNum) {
+		throw "Out of register numbers, expression to complicated";
+	}
+	return ContextInfo(this->myRegNumber-1);
+}
+
+std::string ContextInfo::getReg() const
+{
+	return "R"+std::to_string(myRegNumber);
+}
+
+std::string ContextInfo::labelfunc() const
+{
+    std::string label = "";
+    return label + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26];
+}
+
+std::string ContextInfo::getLabel() const
+{
+    return label;
+}
diff --git a/Compiler/ContextInfo.h b/Compiler/ContextInfo.h
new file mode 100644
index 0000000000000000000000000000000000000000..bed4578779e50ce52186e7ddbb8209c28da7d556
--- /dev/null
+++ b/Compiler/ContextInfo.h
@@ -0,0 +1,22 @@
+#include <string>
+#ifndef CONTEXT_INFO
+#define CONTEXT_INFO
+class ContextInfo {
+public:
+	ContextInfo(); // create an empty one, appropriate for the TOP of a parse tree
+
+	ContextInfo evalThisAfter() const; // create another context for something to be evaluated later
+
+	std::string getReg() const;
+	std::string labelfunc() const;
+    std::string getLabel() const;
+private:
+	// "myRegNumber" will tell each expression what register number they should use for their result
+	//  should generally be different for the subexpressions of a node,
+	//  and if X is evalualuated before Y, it should have a higher number.
+
+	ContextInfo(int myRegNum);  // called by e.g. evalThisFirst, to build new contexts
+	int myRegNumber;
+	std::string label = labelfunc();
+};
+#endif //CONTEXT_INFO
\ No newline at end of file
diff --git a/Compiler/Dictionary.cpp b/Compiler/Dictionary.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..66a98511809d2e6368e96addfae57864fb62e5ac
--- /dev/null
+++ b/Compiler/Dictionary.cpp
@@ -0,0 +1,124 @@
+//
+// Created by Keith_Mburu on 3/15/2021.
+//
+
+#include "Dictionary.h"
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that recurses through dictionary checking for entry
+ *
+ * @return true or false
+ */
+bool Dictionary::containsHelper (const list<pair<string,int>> &dList, const string &entry) {
+    if (empty(dList)) {
+        return false;
+    }
+    else {
+        if ((get<0>(head(dList)) == entry)) {
+            return true;
+        }
+        return containsHelper(rest(dList), entry);
+    }
+}
+
+/**
+ * method that checks if entry is in dictionary
+ *
+ * @return true or false
+ */
+bool Dictionary::contains (const string &entry) {
+    return containsHelper(getList(), entry);
+}
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that recurses through dictionary until it finds and returns integer assigned to entry
+ *
+ * @param entry string being looked up
+ * @param dList dictionary data field
+ * @return the integer
+ */
+int Dictionary::lookupHelper (const list<pair<string,int>> &dList, const string &entry) {
+    if (empty(dList)) {
+        return -1;
+    }
+    else if ((get<0>(head(dList)) == entry)) {
+        return get<1>(head(dList));
+    }
+    return lookupHelper(rest(dList), entry);
+}
+
+/**
+ * method that checks the integer assigned to entry of dictionary
+ *
+ * @param entry string being looked up
+ * @return the integer
+ */
+int Dictionary::lookup (const string &entry) {
+    return lookupHelper(getList(), entry);
+}
+
+/**
+ * method that converts dictionary to the string that constructs it
+ *
+ * @return the string
+ */
+string Dictionary::toCode () {
+    if (empty(dictList)) {
+        return "Dictionary()\n";
+    }
+    list<pair<string, int>> temp = dictList;
+    string dictCode = "Dictionary()";
+    for (int i = 0; i < length(dictList); i++) {
+        // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
+        dictCode = "Dictionary(" + dictCode + ", \"" + get<0>(first(temp)) + "\", " + to_string(get<1>(first(temp))) +
+                ")";
+        temp = rest(temp);
+    }
+    return dictCode;
+}
+
+/**
+ * method that adds new entry to dictionary by constructing new data field
+ *
+ * @param entry string to be added
+ * @param integer integer assigned to the string
+ */
+void Dictionary::add (string entry, int integer) {
+    list<pair<string, int>> newList = list<pair<string, int>>(pair<string, int>(entry, integer), dictList);
+    dictList = newList;
+}
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that builds new dictionary data field with redefined entry
+ *
+ * @return true if successful
+ */
+bool Dictionary::replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int
+integer) {
+    if (empty(dList)) {
+        // finished recursion, now replace dictionary data field
+        setList(newList);
+        return true;
+    }
+    if ((get<0>(head(dList)) == entry)) {
+        newList = list<pair<string, int>>(pair<string, int>(get<0>(head(dList)), integer), newList);
+        // continue recursing to build the rest of the dictionary
+        return replaceHelper(newList, rest(dList), entry, integer);
+    }
+    newList = list<pair<string, int>>(head(dList), newList);
+    return replaceHelper(newList, rest(dList), entry, integer);
+}
+
+/**
+ * method that replaces the integer assigned to an entry of a dictionary
+ *
+ * @return true if the replacement was successful
+ */
+bool Dictionary::replace (const string &entry, int integer) {
+    replaceHelper(list<pair<string, int>>(), getList(), entry, integer);
+}
+
+
diff --git a/Compiler/Dictionary.h b/Compiler/Dictionary.h
new file mode 100644
index 0000000000000000000000000000000000000000..03348453c14653d1f500512f0fe8182c09106e43
--- /dev/null
+++ b/Compiler/Dictionary.h
@@ -0,0 +1,101 @@
+//
+// Created by Keith_Mburu on 3/15/2021.
+//
+
+#ifndef DICTIONARY_H
+#define DICTIONARY_H
+
+#include <hc_list.h>
+#include <hc_list_helpers.h>
+#include <utility>
+
+using namespace HaverfordCS;
+using namespace std;
+
+/**
+ * class that instantiates dictionary with string : integer entries
+ *
+ * @author Keith Mburu
+ * @version 3/24/2021
+ */
+class Dictionary {
+
+public:
+
+    /**
+     * constructor method for empty dictionary
+     */
+    Dictionary() {
+        dictList = list<std::pair<string,int>>();
+    }
+
+    /**
+     * constructor method for new dictionary with old dictionary plus new entry
+     *
+     * @param oldDict old dictionary
+     * @param entry string to be added to old dictionary
+     * @param integer integer to be assigned to new entry
+     */
+    Dictionary(const Dictionary &oldDict, const string &entry, const int &integer) {
+        dictList = list<pair<string,int>>(pair<string,int>(entry, integer), oldDict.dictList);
+    }
+
+    /**
+     * getter method for list that stores dictionary data
+     *
+     * @return list that stores dictionary data
+     */
+    list<pair<string,int>> getList() {
+        return dictList;
+    }
+
+    /**
+     * setter method for list that stores dictionary data
+     *
+     * @param newList list to replace dictionary list
+     */
+    void setList(list<pair<string, int>> newList) {
+        dictList = newList;
+    }
+
+    // learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+    // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
+    /**
+     * method that accumulates dictionary entries in string
+     *
+     * @return string containing dictionary entries
+     */
+    string toStringHelper(const list<pair<string,int>> &dictList, string dictString) {
+        if (empty(rest(dictList))) {
+            return dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList)));
+        }
+        dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList))) + "\n";
+        return toStringHelper(rest(dictList), dictString);
+    }
+
+    /**
+     * method that represents dictionary as a string
+     *
+     * @return string containing dictionary entries
+     */
+    string toString() {
+        return toStringHelper(getList(), "");
+    }
+
+    // other methods defined in Dictionary.cpp
+    int lookup (const string &entry);
+    int lookupHelper (const list<pair<string,int>> &dList, const string &entry);
+    bool contains (const string &entry);
+    bool containsHelper (const list<pair<string,int>> &dList, const string &entry);
+    void add (string entry, int integer);
+    bool replace (const string &entry, int integer);
+    bool replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int integer);
+    string toCode ();
+
+private:
+
+    list<pair<string,int>> dictList; // list that stores dictionary data
+
+};
+
+#endif
\ No newline at end of file
diff --git a/Compiler/README-Collaboration.txt b/Compiler/README-Collaboration.txt
new file mode 100644
index 0000000000000000000000000000000000000000..a4d117a958e7f176f9f498aed0dfc60aee767f99
--- /dev/null
+++ b/Compiler/README-Collaboration.txt
@@ -0,0 +1 @@
+Working alone
\ No newline at end of file
diff --git a/Compiler/README-Design.txt b/Compiler/README-Design.txt
new file mode 100644
index 0000000000000000000000000000000000000000..2ec30f9c78dde23cc412d07be3f00c4c19b56183
--- /dev/null
+++ b/Compiler/README-Design.txt
@@ -0,0 +1,16 @@
+PLEASE DO NOT EDIT THIS PRELIMINARY VERISON OF THE FILE, TO AVOID GIT CONFLICTS LATER
+ (if you're working before the update version is available, make a copy and edit that)
+
+Important Design Decisions:
+
+   * Sticking to node-based AST structure
+
+
+Project Status (T = code completed and test suite exists, C = code completed, P = in-progress, N = not started):
+
+   T  Parse + and * operations, constants and identifiers
+   T  Build an Object-Oriented AST from the above
+   T  Appropriately allocate registers for arithmetic operations
+   T  Generate HERA code for +, *, and constants
+
+ ---- more will be added later ----
diff --git a/Compiler/README_Sources.txt b/Compiler/README_Sources.txt
new file mode 100644
index 0000000000000000000000000000000000000000..dcbdecf608edb7dcfa732b27c5506086a27df60d
--- /dev/null
+++ b/Compiler/README_Sources.txt
@@ -0,0 +1 @@
+Copy assignment operators - https://en.cppreference.com/w/cpp/language/copy_assignment
\ No newline at end of file
diff --git a/Compiler/generateHERA.cc b/Compiler/generateHERA.cc
new file mode 100644
index 0000000000000000000000000000000000000000..9ac1c3feb35fe19bd2fef35f116304f7f49b80bd
--- /dev/null
+++ b/Compiler/generateHERA.cc
@@ -0,0 +1,238 @@
+#include "AST.h"
+#include "ContextInfo.h"
+#include "hc_list_helpers.h"
+#include "streams.h"
+
+using std::string;
+using std::endl;
+
+Dictionary declarationDict = Dictionary();
+int FPoffset = -1;
+
+std::string generateFullHERA(ExprNode *presumedRoot)
+{
+    return "\nCBON()\n" + presumedRoot->generateHERA(ContextInfo());
+}
+
+string IntLiteralNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered IntLiteralNode::generateHERA for integer " + std::to_string(v) << endl;
+	return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
+}
+
+string BoolLiteralNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered BoolLiteralNode::generateHERA for boolean " + std::to_string(v) << endl;
+    return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
+}
+
+std::string HERA_op(const std::string &AST_op_name)
+{
+	if (AST_op_name == "+") {
+		return "ADD";
+	} else if (AST_op_name == "-") {
+		return "SUB";
+	} else if (AST_op_name == "*") {
+		return "MUL";
+    } else if (AST_op_name == "=") {
+        return "CMP";
+    } else if (AST_op_name == ">=") {
+        return "CMP";
+    } else if (AST_op_name == "<=") {
+        return "CMP";
+	} else {
+		throw "Internal compiler inconsistency/incompleteness: HERA_op not implemented for " + AST_op_name;
+	}
+}
+
+string ComparisonNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered ComparisonNode::generateHERA for comparison " + o << endl;
+
+    // see arithmetic node for more about the "context" stuff:
+    //	trace << "need to compare the result of left-hand-side:\n" << left->generateHERA(context) << endl;
+    //	trace << "                        with right-hand-side:\n" << left->generateHERA(context.evalThisAfter()) << endl;
+
+    if (left->getType() != "CallNode" && right->getType() != "CallNode") {
+        if ((left->getType() != "IntLiteralNode" && left->getType() != "VarUseNode" && left->getType() != "LetNode") ||
+                (right->getType() != "IntLiteralNode" && right->getType() != "VarUseNode" && right->getType() != "LetNode")) {
+            cerr << endl << "!Type error! cannot perform comparison operations on non-integers" << endl;
+            exit(98);
+        }
+    }
+
+    ContextInfo rhsContext = context.evalThisAfter();
+    ContextInfo lhsContext = context;  // just named for symmetry
+
+    ContextInfo labelContext1 = ContextInfo();
+    ContextInfo endLabelContext = ContextInfo();
+
+    return left->generateHERA(lhsContext) +
+           right->generateHERA(rhsContext) +
+           HERA_op(o)+"("+lhsContext.getReg()+", "+rhsContext.getReg()+")\n" +
+           "BZ(" + context.getLabel() + ")\n" +
+            ((o == "=")? "SET(" + context.getReg() + ", " + "0)\n" :
+             (o == "<=" || o == ">=")? "BS(" + labelContext1.getLabel() + ")\n" : "") +
+            ((o == ">=")? "SET(" + context.getReg() + ", " + "1)\n" :
+             (o == "<=")? "SET(" + context.getReg() + ", " + "0)\n" : "") +
+            "BR(" + endLabelContext.getLabel() + ")\n" +
+            "LABEL(" + context.getLabel() + ")\n" +
+            "SET(" + context.getReg() + ", " + "1)\n" +
+            "BR(" + endLabelContext.getLabel() + ")\n" +
+            ((o == "<=" || o == ">=")? ("LABEL(" + labelContext1.getLabel() + ")\n" +
+            ((o == "<=")? "SET(" + context.getReg() + ", " + "1)\n" :
+             "SET(" + context.getReg() + ", " + "0)\n")) : "") +
+             "LABEL(" + endLabelContext.getLabel() + ")\n";
+}
+
+string ArithmeticNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered ArithmeticNode::generateHERA for operator " + o << endl;
+	if (length(subexps) != 2) {
+		throw "compiler incomplete/inconsistent: generateHERA not implemented for non-binary arithmetic";
+	}
+
+    if (first(subexps)->getType() != "CallNode" && first(rest(subexps))->getType() != "CallNode") {
+        if ((first(subexps)->getType() != "IntLiteralNode" && first(subexps)->getType() != "VarUseNode" && first(subexps)->getType() != "LetNode") ||
+                (first(rest(subexps))->getType() != "IntLiteralNode" && first(rest(subexps))->getType() != "VarUseNode" && first(rest(subexps))
+                ->getType() != "LetNode")) {
+            cerr << endl << "!Type error! cannot perform arithmetic operations on non-integers" << endl;
+            exit(99);
+        }
+    }
+
+	ContextInfo rhsContext = context.evalThisAfter();
+	ContextInfo lhsContext = context;  // just named for symmetry
+
+    string leftHERA = first(subexps)->generateHERA(lhsContext);
+    string rightHERA = first(rest(subexps))->generateHERA(rhsContext);
+
+    return  leftHERA + rightHERA + HERA_op(o)+"("+context.getReg()+", "+lhsContext.getReg()+", "+rhsContext.getReg()+")\n";
+}
+
+string VarUseNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered VarUseNode::generateHERA for variable " + n << endl;
+
+    return "LOAD(" + context.getReg() + ", " + to_string(declarationDict.lookup(n)) + ", FP)\n";
+}
+
+string CallNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered CallNode::generateHERA for call to " + n << endl;
+	
+	if (length(argList) != 0 || (n != "exit" && n != "getint")) {
+		throw "compiler incomplete/inconsistent: generateHERA for calls only implented for getint and exit";
+	}
+	// NOTE that calls to exit and getint don't need parameters and don't perturb registers
+	return ("MOVE(FP_alt, SP)\nCALL(FP_alt," + n + ")\n"+
+		(context.getReg()=="R1"?"":"MOVE("+context.getReg()+", R1)\n"));
+}
+
+string IfNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered IfNode::generateHERA" << endl;
+
+    if (expriftrue->getType() != "CallNode" && expriffalse->getType() != "CallNode") {
+        if (expriftrue->getType() != expriffalse->getType()) {
+            cerr << endl << "!Type error! \"then\" and \"else\" statements must be of the same type" << endl;
+            exit(45);
+        }
+    }
+
+    ContextInfo conditionContext = context;
+    ContextInfo expriftrueContext = context.evalThisAfter();
+    ContextInfo expriffalseContext = context.evalThisAfter().evalThisAfter();
+
+    ContextInfo labelContext1 = ContextInfo();
+    ContextInfo labelContext2 = ContextInfo();
+
+    string conditionHERA = condition->generateHERA(conditionContext);
+    string expriftrueHERA = expriftrue->generateHERA(expriftrueContext);
+    string expriffalseHERA = expriffalse->generateHERA(expriffalseContext);
+
+    return  conditionHERA + expriftrueHERA + expriffalseHERA +
+            "FLAGS(" + conditionContext.getReg() + ")\n" +
+            "BZ(" + labelContext1.getLabel() + ")\n" +
+            "MOVE(" + context.getReg() + ", " + expriftrueContext.getReg() + ")\n" +
+            "BR(" + labelContext2.getLabel() + ")\n" +
+            "LABEL(" + labelContext1.getLabel() + ")\n" +
+            "MOVE(" + context.getReg() + ", " + expriffalseContext.getReg() + ")\n" +
+            "LABEL(" + labelContext2.getLabel() + ")\n";
+}
+
+string LetNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered LetNode::generateHERA" << endl;
+    ContextInfo declarationsContext = context;
+    ContextInfo expressionsContext = context;
+
+    string expressionsHERA = "";
+    string declarationsHERA = declarations->generateHERA(declarationsContext);
+    expressionsHERA = expressionsHelper(expressionsHERA, expressions, expressionsContext);
+    return declarationsHERA + expressionsHERA;
+}
+
+string LetNode::expressionsHelper(string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const {
+    if (empty(expressions)) {
+        return expressionsHERA;
+    }
+    return expressionsHelper(expressionsHERA += first(expressions)->generateHERA(context), rest(expressions), context.evalThisAfter());
+}
+
+string DeclarationsNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered DeclarationsNode::generateHERA" << endl;
+    ContextInfo declarationsContext = context;
+
+    ContextInfo labelContext = ContextInfo();
+
+    string declarationsHERA = "";
+    return  declarationsHelper(declarationsHERA, declarations, context);
+}
+
+string DeclarationsNode::declarationsHelper(string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const {
+    if (empty(declarations)) {
+        return declarationsHERA;
+    }
+    return declarationsHelper(declarationsHERA += first(declarations)->generateHERA(context), rest(declarations),
+                              context);
+}
+
+string DeclarationNode::generateHERA(const ContextInfo &context) const
+{
+    auto literal = expr;
+    string value;
+    if (declType == "IntLiteralNode") {
+        *literal = intLiteral;
+        value = to_string(intLiteral.getValue());
+    }
+    else if (declType == "BoolLiteralNode") {
+        *literal = boolLiteral;
+        value = boolLiteral.getValue();
+    }
+    else if (declType == "definedVar") {
+        *literal = definedVar;
+        value = definedVar.getValue();
+    }
+
+    trace << "Entered DeclarationNode::generateHERA for declaration " + variable.getValue() + ((declType == "ExprNode")? " = expression" : " = " +
+    value) << endl;
+
+    if (declType == "definedVar") {
+        value = to_string(declarationDict.lookup(value));
+    }
+
+    FPoffset += 1;
+
+    declarationDict.add(variable.getValue(), FPoffset);
+
+    return ((declType == "ExprNode")? literal->generateHERA(context) :
+           (declType == "definedVar")? "LOAD(" + context.getReg() + ", " + value + ", FP)\n" :
+           "SET(" + context.getReg() + ", " + value + ")\n") +
+           "STORE(" + context.getReg() + ", " + std::to_string(FPoffset) + ", FP)\n";
+}
+
+
+
+
diff --git a/Compiler/main.cc b/Compiler/main.cc
new file mode 100644
index 0000000000000000000000000000000000000000..0b37124155f50aea45a9f9ce9a02124bdecfde69
--- /dev/null
+++ b/Compiler/main.cc
@@ -0,0 +1,132 @@
+/*
+ * "Compiler" project for HaverRacket
+ *  Translate a subset of Racket into HERA
+ *
+ * To run this project and run the program tests/01-multiply.hrk, use the command:
+ *   Debug/Compiler-C++ < tests/01-multiply.hrk | tee Compiler.out
+ * and then run the HERA program with the command
+ *   HERA-C-Run Compiler.out
+ */
+
+#include <iostream>
+#include <cstdlib>
+#include "scannerDemo.h"
+#include "parser.h"
+#include "ContextInfo.h"
+#include "hc_list_helpers.h" // ez_list
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+
+#include "streams.h"
+#include "Dictionary.h"
+
+// to change trace output, compile with
+//   e.g. -DTRACE_OUTPUT_HERE="./my-trace-output.txt"
+//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to throw away trace output
+//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to always use cerr
+//     or -DTRACE_OUTPUT_HERE=(getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
+//        # that last, the default (I hope) should allow run-time selection via e.g.,
+//        HAVERRACKET_TRACE=my-trace-output1.txt Debug/Compiler-C++
+//
+//  similarly for -DPROMPT_OUTPUT_HERE, which defaults to getenv("HAVERRACKET_PROMPT")
+//    note that prompt is not currently used, though
+
+#if ! defined TRACE_OUTPUT_HERE
+#define TRACE_OUTPUT_HERE (getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
+#endif
+#if ! defined PROMPT_OUTPUT_HERE
+#define PROMPT_OUTPUT_HERE (getenv("HAVERRACKET_PROMPT")?getenv("HAVERRACKET_PROMPT"):"/dev/stderr")
+#endif
+
+#include <fstream>  /* needed for ofstream below */
+std::ofstream _HaverRacket_trace(TRACE_OUTPUT_HERE);
+std::ostream &trace  = _HaverRacket_trace;
+std::ofstream _HaverRacket_prompt(PROMPT_OUTPUT_HERE);
+std::ostream &prompt = _HaverRacket_prompt;
+
+#if ! defined AbstractSyntaxTest
+#define AbstractSyntaxTest build_example1   /* this lets us use a different test easily with a special command line */
+#endif
+
+ParserResult AbstractSyntaxTest();
+
+int main(int numberOfCommandLineArguments, char *theCommandLineArguments[])
+{
+	try {
+		bool testScannerInstead = false;
+        if (numberOfCommandLineArguments == 2 && theCommandLineArguments[1] == string("testScannerInstead")) {
+			trace << "Testing Scanner instead." << endl;
+			testScannerInstead = true;
+		}
+
+		if (testScannerInstead) {
+			cout << "Demonstrating lexical scanner. Enter tokens followed by <EOF>." << endl;
+			scannerDemo();
+		} else {
+			if (!getenv("HAVERRACKET_TEST_CODE_HERA") ||
+			    getenv("HAVERRACKET_TEST_CODE_HERA") == string("#t"))
+			{
+				try {
+					ParserResult example1 = AbstractSyntaxTest();
+
+					trace << "confirming codegen basic functionality on test example1:" << endl;
+					string code = generateFullHERA(example1);
+					trace << code << endl;
+					delete example1;  // we're done with example1 now.
+
+				} catch (const char *message) {
+					cerr << "code generation confirmation test threw exception: " << message << endl;
+					return 2;
+				}
+			}
+
+            trace << "Type in new input!" << endl;
+
+            try {
+				ParserResult AST = matchStartSymbolAndEOF();
+//				trace << "Completed Parsing, got AST: " << AST.toCode() << endl;
+				try {
+                    trace << "\nNow generating code: " << endl;
+					trace << generateFullHERA(AST) << endl;
+				} catch (const char *message) {
+					cerr << "eval threw exception (typically an unhandled case): " << message << endl;
+					return 4;
+				}
+#if FREE_AST_VIA_DESTRUCTORS
+				delete AST;
+#endif
+			} catch (const char *message) {
+				cerr << "that's odd, parser threw exception: " << message << endl;
+				return 3;
+			}
+		}
+
+		return 0;  // indicate successful translation if no exit with non-0 before this
+	} catch (range_error) {
+		cerr << "Yikes! Uncaught exception" << endl;
+		return 66;
+	}
+}
+
+
+	    
+
+ParserResult build_example1()
+{
+//	ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new IntLiteralNode(3), new IntLiteralNode(7)));
+//    ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new BoolLiteralNode("#t"), new BoolLiteralNode("#f")));
+    ExprNode *product = new IfNode(new ComparisonNode("<=", new IntLiteralNode(6), new IntLiteralNode(7)), new BoolLiteralNode("#t"), new
+    BoolLiteralNode("#f"));
+
+    return product;
+/*
+  NOTE that the starter files ExprNode classes do _not_ support the following due to memory allocation techniques,
+    though it might seem at first to work:
+*/
+	// return new ArithmeticNode("+", HaverfordCS::ez_list<ExprNode *>(product, product));
+	// return new ComparisonNode("<=", product, product);
+}
+
diff --git a/Compiler/parser.cc b/Compiler/parser.cc
new file mode 100644
index 0000000000000000000000000000000000000000..c98845df82e3cb8dbd842b84e54a649b19663061
--- /dev/null
+++ b/Compiler/parser.cc
@@ -0,0 +1,241 @@
+#include <iostream>
+#include <cstdlib>  // for 'exit' function to abandon the program
+#include <hc_list_helpers.h>
+#include "parser.h"
+#include "scanner.h"
+
+using std::string;
+using HaverfordCS::list;
+using HaverfordCS::ez_list;
+using std::cout;
+using std::cerr;
+using std::endl;
+
+#include "streams.h"
+
+// match this:
+// START -> E   <followed by end-of-input>
+// E -> integer
+// E -> boolean
+// E -> identifier
+// E -> ( E_IN_PARENS )
+// E? -> E E?
+// E? -> ""
+// E_IN_PARENS -> OP E E
+// E_IN_PARENS -> letstar E E E?
+// E_IN_PARENS -> [ E_IN_BRACKETS ] E_IN_PARENS
+// E_IN_PARENS -> ""
+// E_IN_PARENS -> EXIT
+// E_IN_PARENS -> GETINT   // New in this version, gets user input
+// E_IN_PARENS -> if E E E
+
+// E_IN_BRACKETS -> E E
+
+// OP --> +|-|*|<=|=|>= OP_COMPARE
+
+// Declare all functions, so they can call each other in any order
+//  (note: "static" means it's restricted to this scope, e.g. this file
+static ParserResult matchE();
+static ParserResult matchEInParens();
+static string matchOp();
+
+
+// FIRST and FOLLOW sets for those,
+//  built with lists rather than sets, for familiarity
+//  defined in terms of kindOfToken from scanner-regexp.h
+static list<kindOfToken> FIRST_OP  = ez_list(PLUS, MINUS, TIMES, OP_COMPARE);
+static list<kindOfToken> FIRST_EIP = FIRST_OP;
+static list<kindOfToken> FIRST_E   = ez_list(INT_LITERAL, BOOL_LITERAL, IDENTIFIER, LPAREN, LBRACKET);
+
+static list<kindOfToken> FOLLOW_OP  = FIRST_E;
+static list<kindOfToken> FOLLOW_EIP = ez_list(RPAREN);
+static list<kindOfToken> FOLLOW_E   = /* append(FOLLOW_EIP, FIRST_E) */
+		                              list<kindOfToken>(RPAREN, FIRST_E);
+	                                  /* Dave should put "append" into list_helpers */
+
+// first, some helpful functions:
+
+// mustGetNextToken:
+//    we call this when we need to get more input and we must find something there,
+//    i.e. when we want to move current_token along and end-of-input would be an error
+void mustGetNextToken()
+{
+	getNextToken();
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+}
+
+
+// currentTokenThenMove
+//   record currentToken (which must NOT be end-of-input), then move past it, return what it was
+static std::string currentTokenThenMove()
+{
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+	std::string curr = currentToken();
+	getNextToken();
+	return curr;
+}
+
+// confirmLiteral
+//   match a literal, assuming the token HAS been scanned already,
+//    i.e. that "currentToken" is _on_ the literal we wish to match
+//   leave "currentToken" on the very last token of the matched pattern ... this is not a "match" function
+static void confirmLiteral(string what)
+{
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+	if (currentToken() != what) {
+		cerr << "got " << currentToken() << " instead of " << what << " at token #" << tokenNumber() << endl;
+		exit(2);
+	}	
+}
+
+
+// match an "E", i.e, anything on the right hand side of any "E-->..." production
+//  assume the first token of the E has been scanned
+//   (i.e., assuming currentToken is the first token of the "E" we're matching)
+//  leave "currentToken" AFTER the very last token of the matched pattern
+static ParserResult matchE()
+{
+	trace << "Entering matchE, current token is " << currentToken() << endl;
+	if (currentTokenKind() == INT_LITERAL) {
+        return new IntLiteralNode(std::stoi(currentTokenThenMove()));
+    } else if (currentTokenKind() == BOOL_LITERAL) {
+        return new BoolLiteralNode(currentTokenThenMove());
+	} else if (currentTokenKind() == IDENTIFIER) {
+        return new VarUseNode(currentTokenThenMove());
+	} else if (currentTokenKind() == LPAREN) {	
+		confirmLiteral("(");
+		mustGetNextToken();
+		ParserResult it = matchEInParens();
+		trace << "After matchEInParens, back in matchE, current token is: " << currentToken() << endl;
+		// if that left off AFTER the end of the E_IN_PARENS, we still need a ")" in the E we're matching
+		confirmLiteral(")");
+		getNextToken();	 // we're AFTER the ) now
+		return it;
+	} else {				
+		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+		exit(3);
+	}
+}
+
+// match an "E_IN_PARENS",
+//  assuming that the currentToken is at the start of the E_IN_PARENS, e.g. a "+"
+//  leave the currentToken AFTER the last part of what was matched,
+//  i.e. *on* the ")" that should come after the E_IN_PARENS
+static ParserResult matchEInParens() {
+	trace << "Entering matchEInParens, current token is " << currentToken() << endl;
+	if (find(currentTokenKind(), FIRST_OP)) {
+        bool its_a_comparison_op = (currentTokenKind() == OP_COMPARE);
+        string theOp = matchOp();
+        ParserResult firstChild = matchE();
+        ParserResult secondChild = matchE();
+        if (its_a_comparison_op) { // a comparison
+            return new ComparisonNode(theOp, firstChild, secondChild);
+        } else {
+            return new ArithmeticNode(theOp, ez_list(firstChild, secondChild));
+        }
+    } else if (currentTokenKind() == LBRACKET) {
+        list<ExprNode *> declarations = list<ExprNode *>();
+	    while (currentTokenKind() != RPAREN) {
+            mustGetNextToken();
+            declarations = list(matchEinBrackets(), declarations);
+            confirmLiteral("]");
+            mustGetNextToken();
+        }
+	    return new DeclarationsNode(reverse(declarations, list<ExprNode *>()));
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "if") {
+	    mustGetNextToken();
+	    ParserResult condition = matchE();
+        ParserResult expriftrue = matchE();
+        ParserResult expriffalse = matchE();
+        return new IfNode(condition, expriftrue, expriffalse);
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "let*") {
+        mustGetNextToken();
+        ParserResult declarations = matchE();
+        list<ExprNode *> expressions = list<ExprNode *>();
+        while (currentToken() != ")") {
+            expressions = list(matchE(), expressions);
+        }
+	    return new LetNode(declarations, reverse(expressions, list<ExprNode *>()));
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "exit") {
+		return new CallNode(currentTokenThenMove(), list<ParserResult>());
+	} else if (currentTokenKind() == IDENTIFIER && currentToken() == "getint") {
+		return new CallNode(currentTokenThenMove(), list<ParserResult>());
+	} else {
+		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+		exit(3);
+	}
+}
+
+static ParserResult matchEinBrackets() {
+    if (currentTokenKind() == IDENTIFIER) {
+        VarUseNode variable = VarUseNode(currentTokenThenMove());
+        if (currentTokenKind() == IDENTIFIER) {
+            VarUseNode definedVar = VarUseNode(currentTokenThenMove());
+            return new DeclarationNode(variable, definedVar, "definedVar");
+        }
+        else if (currentTokenKind() == INT_LITERAL) {
+            IntLiteralNode literal = IntLiteralNode(stoi(currentTokenThenMove()));
+            return new DeclarationNode(variable, literal, "IntLiteralNode");
+        }
+        else if (currentTokenKind() == BOOL_LITERAL) {
+            BoolLiteralNode literal = BoolLiteralNode(currentTokenThenMove());
+            return new DeclarationNode(variable, literal, "BoolLiteralNode");
+        }
+        else if (currentTokenKind() == LPAREN) {
+            ParserResult expr = matchE();
+            return new DeclarationNode(variable, expr, "ExprNode");
+        }
+    }
+    std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+    exit(3);
+}
+
+// match an operator, assuming that it is the currentToken
+//  leave the currentToken AFTER the last part of what was matched, i.e. unchanged
+static string matchOp()
+{
+	trace << "Entering matchOp, current token is " << currentToken() << endl;
+	// could do three cases here, but that's so tedious...
+	assert (find(currentTokenKind(), FIRST_OP));
+	return currentTokenThenMove();
+}
+
+
+ParserResult matchStartSymbolAndEOF()
+{
+	getNextToken();  // this will be the first one
+	if (!tokenAvailable()) {
+		cerr << "Illegal end of input" << endl;
+		exit(2);
+	}
+
+	ParserResult fullExpression = matchE();  // "E" is our start symbol
+
+	// now make sure there isn't anything else!
+	getNextToken();
+	if (tokenAvailable()) {
+		cerr << "Warning: extra input after end: " << currentToken() << endl;
+		exit (1);
+	}
+
+	return fullExpression;
+}
+
+list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList) {
+    if (empty(list)) {
+        return newList;
+    }
+    if (length(list) == 1) {
+        return ::list(first(list), newList);
+    }
+    return reverse(rest(list), ::list(first(list), newList));
+}
\ No newline at end of file
diff --git a/Compiler/parser.h b/Compiler/parser.h
new file mode 100644
index 0000000000000000000000000000000000000000..93d1b80df7d1f7c9d8bc91365b9e5addea106d1e
--- /dev/null
+++ b/Compiler/parser.h
@@ -0,0 +1,18 @@
+#ifndef PARSER_H_
+#define PARSER_H_
+
+
+#include "AST.h"
+
+// The typedef below makes the name "translatedResult"
+//  mean a "Tree" object from our Expr_Node type heirarchy.
+typedef ExprNode *ParserResult;
+
+ParserResult matchStartSymbolAndEOF();
+static ParserResult matchE();
+static ParserResult matchEinParens();
+static ParserResult matchEinBrackets();
+static std::string matchOp();
+list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList);
+
+#endif /*PARSER_H_*/
diff --git a/Compiler/scanner-regexp.cc b/Compiler/scanner-regexp.cc
new file mode 100644
index 0000000000000000000000000000000000000000..67ca6baa846697934c3895382b4ac8f58c53fbe7
--- /dev/null
+++ b/Compiler/scanner-regexp.cc
@@ -0,0 +1,1871 @@
+
+#line 2 "<stdout>"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 4
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* begin standard C++ headers. */
+
+/* TODO: this is always defined, so inline it */
+#define yyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
+#else
+#define yynoreturn
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
+ */
+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin  )
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+    
+    #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	int yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = NULL;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart ( FILE *input_file  );
+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
+void yy_delete_buffer ( YY_BUFFER_STATE b  );
+void yy_flush_buffer ( YY_BUFFER_STATE b  );
+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state ( void );
+
+static void yyensure_buffer_stack ( void );
+static void yy_load_buffer_state ( void );
+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
+
+void *yyalloc ( yy_size_t  );
+void *yyrealloc ( void *, yy_size_t  );
+void yyfree ( void *  );
+
+#define yy_new_buffer yy_create_buffer
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+typedef flex_uint8_t YY_CHAR;
+
+FILE *yyin = NULL, *yyout = NULL;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+int yylineno = 1;
+
+extern char *yytext;
+#ifdef yytext_ptr
+#undef yytext_ptr
+#endif
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state ( void );
+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
+static int yy_get_next_buffer ( void );
+static void yynoreturn yy_fatal_error ( const char* msg  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+#define YY_NUM_RULES 19
+#define YY_END_OF_BUFFER 20
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static const flex_int16_t yy_accept[34] =
+    {   0,
+        0,    0,   20,   18,    1,    2,    2,   18,    4,    5,
+       10,    8,    9,   15,    3,   18,   11,   18,   17,    6,
+        7,   16,   15,    3,   12,    0,   13,   17,   17,    0,
+        0,   14,    0
+    } ;
+
+static const YY_CHAR yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    5,    1,    1,    1,    1,    6,
+        7,    8,    9,    1,   10,    1,    1,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,    1,   12,   13,
+       14,   15,    1,    1,   16,   16,   16,   16,   17,   18,
+       16,   16,   16,   16,   16,   16,   16,   16,   19,   16,
+       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
+       20,    1,   21,    1,   22,    1,   23,   23,   23,   23,
+
+       23,   24,   23,   23,   23,   23,   23,   23,   23,   23,
+       23,   23,   23,   23,   23,   25,   23,   23,   23,   23,
+       23,   23,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static const YY_CHAR yy_meta[26] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    3,    1,    1,
+        3,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    3,    3,    3
+    } ;
+
+static const flex_int16_t yy_base[36] =
+    {   0,
+        0,    0,   42,   43,   43,   43,   43,    2,   43,   43,
+       43,   43,   30,   29,    0,   14,   43,   25,   30,   43,
+       43,   43,   26,    0,   43,   17,   43,   43,   27,   15,
+       15,   43,   43,   31,   26
+    } ;
+
+static const flex_int16_t yy_def[36] =
+    {   0,
+       33,    1,   33,   33,   33,   33,   33,   33,   33,   33,
+       33,   33,   33,   33,   34,   33,   33,   33,   35,   33,
+       33,   33,   33,   34,   33,   33,   33,   33,   35,   33,
+       33,   33,    0,   33,   33
+    } ;
+
+static const flex_int16_t yy_nxt[69] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,   15,   16,   17,   18,   19,   19,   19,   19,   20,
+       21,    4,   19,   19,   19,   22,   22,   25,   29,   32,
+       26,   24,   31,   24,   28,   30,   23,   28,   27,   23,
+       23,   33,    3,   33,   33,   33,   33,   33,   33,   33,
+       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
+       33,   33,   33,   33,   33,   33,   33,   33
+    } ;
+
+static const flex_int16_t yy_chk[69] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    8,    8,   16,   35,   31,
+       16,   34,   30,   34,   29,   26,   23,   19,   18,   14,
+       13,    3,   33,   33,   33,   33,   33,   33,   33,   33,
+       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
+       33,   33,   33,   33,   33,   33,   33,   33
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "scanner-regexp.l"
+#line 2 "scanner-regexp.l"
+/*
+
+   This is a lexical scanner specification for the "lex" (or "flex") language.
+   It can be translated into a "C++" file by running, in the project directory, the command
+
+    flex  -t scanner-regexp.l > scanner-regexp.cc
+
+
+   In this first section of the lex file (between %{ and %}),
+   we define C++ functions that will be used later in the actions of part 3.
+
+*/
+
+#include "scanner-regexp.h"
+
+// the code generated by the flex system requires we write this:
+extern "C" int yywrap()
+{
+ return 1;
+}
+
+#line 484 "<stdout>"
+/* In this second section of the lex file (after the %}),
+   we can define variables in terms of regular expressions.
+   C-style comments (like this one) are also legal. */
+/* In the third section of the lex file (after the %%),
+   we can define the patterns for each token
+   in terms of regular expressions and the variables above,
+   and give the action (as C++ code) for each token.
+   Comments are legal only inside the actions. */
+#line 493 "<stdout>"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals ( void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy ( void );
+
+int yyget_debug ( void );
+
+void yyset_debug ( int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra ( void );
+
+void yyset_extra ( YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in ( void );
+
+void yyset_in  ( FILE * _in_str  );
+
+FILE *yyget_out ( void );
+
+void yyset_out  ( FILE * _out_str  );
+
+			int yyget_leng ( void );
+
+char *yyget_text ( void );
+
+int yyget_lineno ( void );
+
+void yyset_lineno ( int _line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap ( void );
+#else
+extern int yywrap ( void );
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+    
+    static void yyunput ( int c, char *buf_ptr  );
+    
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy ( char *, const char *, int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen ( const char * );
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput ( void );
+#else
+static int input ( void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK /*LINTED*/break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
+    
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state(  );
+		}
+
+	{
+#line 38 "scanner-regexp.l"
+
+
+#line 713 "<stdout>"
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 34 )
+					yy_c = yy_meta[yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 43 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 40 "scanner-regexp.l"
+{ continue; }  /* do nothing with blank spaces */
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 41 "scanner-regexp.l"
+{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 42 "scanner-regexp.l"
+{ continue; }  /* treat comments like other blank space */
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 44 "scanner-regexp.l"
+{ tokenCount++; return LPAREN; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 45 "scanner-regexp.l"
+{ tokenCount++; return RPAREN; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 46 "scanner-regexp.l"
+{ tokenCount++; return LBRACKET; }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 47 "scanner-regexp.l"
+{ tokenCount++; return RBRACKET; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 48 "scanner-regexp.l"
+{ tokenCount++; return PLUS; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 49 "scanner-regexp.l"
+{ tokenCount++; return MINUS; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 50 "scanner-regexp.l"
+{ tokenCount++; return TIMES; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 51 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 52 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 53 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 55 "scanner-regexp.l"
+{ tokenCount++; return END_OF_INPUT; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 57 "scanner-regexp.l"
+{ tokenCount++; return INT_LITERAL; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 58 "scanner-regexp.l"
+{ tokenCount++; return BOOL_LITERAL; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 60 "scanner-regexp.l"
+{ tokenCount++; return IDENTIFIER; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 62 "scanner-regexp.l"
+{ scannerError(); continue; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 63 "scanner-regexp.l"
+ECHO;
+	YY_BREAK
+#line 866 "<stdout>"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap(  ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of user's declarations */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = (yytext_ptr);
+	int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc( (void *) b->yy_ch_buf,
+							 (yy_size_t) (b->yy_buf_size + 2)  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = NULL;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
+			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	yy_state_type yy_current_state;
+	char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 34 )
+				yy_c = yy_meta[yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	int yy_is_jam;
+    	char *yy_cp = (yy_c_buf_p);
+
+	YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 34 )
+			yy_c = yy_meta[yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+	yy_is_jam = (yy_current_state == 33);
+
+		return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_UNPUT
+
+    static void yyunput (int c, char * yy_bp )
+{
+	char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		int number_to_move = (yy_n_chars) + 2;
+		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap(  ) )
+						return 0;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer( yyin, YY_BUF_SIZE );
+	}
+
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state(  );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree( (void *) b->yy_ch_buf  );
+
+	yyfree( (void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state(  );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state(  );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state(  );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	yy_size_t num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return NULL;
+
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = NULL;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (const char * yystr )
+{
+    
+	return yy_scan_bytes( yystr, (int) strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = (yy_size_t) (_yybytes_len + 2);
+	buf = (char *) yyalloc( n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yynoreturn yy_fatal_error (const char* msg )
+{
+			fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+    
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param _line_number line number
+ * 
+ */
+void yyset_lineno (int  _line_number )
+{
+    
+    yylineno = _line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param _in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  _in_str )
+{
+        yyin = _in_str ;
+}
+
+void yyset_out (FILE *  _out_str )
+{
+        yyout = _out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  _bdebug )
+{
+        yy_flex_debug = _bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = NULL;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = NULL;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = NULL;
+    yyout = NULL;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, const char * s2, int n )
+{
+		
+	int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (const char * s )
+{
+	int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+			return malloc(size);
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+		
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return realloc(ptr, size);
+}
+
+void yyfree (void * ptr )
+{
+			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 63 "scanner-regexp.l"
diff --git a/Compiler/scanner-regexp.h b/Compiler/scanner-regexp.h
new file mode 100644
index 0000000000000000000000000000000000000000..a842c85c9de80d7e6cd2ea3405346ce319b1eeb6
--- /dev/null
+++ b/Compiler/scanner-regexp.h
@@ -0,0 +1,13 @@
+enum kindOfToken {
+	END_OF_INPUT = 0,   // defined by flex system
+	LPAREN,	RPAREN,
+	PLUS,	MINUS,	TIMES,
+	OP_COMPARE,
+	INT_LITERAL, BOOL_LITERAL,
+	IDENTIFIER, LBRACKET,
+	RBRACKET
+};
+
+void scannerError(); /// define in whatever uses the regexp-based scanner
+
+extern int tokenCount;  // not static because the .l file needs it too
diff --git a/Compiler/scanner-regexp.l b/Compiler/scanner-regexp.l
new file mode 100644
index 0000000000000000000000000000000000000000..d8b2cf39ab643276466099bd5a6bf991a90046a5
--- /dev/null
+++ b/Compiler/scanner-regexp.l
@@ -0,0 +1,62 @@
+%{
+/*
+
+   This is a lexical scanner specification for the "lex" (or "flex") language.
+   It can be translated into a "C++" file by running, in the project directory, the command
+
+    flex  -t scanner-regexp.l > scanner-regexp.cc
+
+
+   In this first section of the lex file (between %{ and %}),
+   we define C++ functions that will be used later in the actions of part 3.
+
+*/
+
+#include "scanner-regexp.h"
+
+// the code generated by the flex system requires we write this:
+extern "C" int yywrap()
+{
+ return 1;
+}
+
+%}
+
+/* In this second section of the lex file (after the %}),
+   we can define variables in terms of regular expressions.
+   C-style comments (like this one) are also legal. */
+
+digit		[0-9]
+identifier	[a-zA-Z][a-z0-9_]*\*?
+
+/* In the third section of the lex file (after the %%),
+   we can define the patterns for each token
+   in terms of regular expressions and the variables above,
+   and give the action (as C++ code) for each token.
+   Comments are legal only inside the actions. */
+
+%%
+
+[ \t]		{ continue; }  /* do nothing with blank spaces */
+[\n\r]		{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
+\;.*		{ continue; }  /* treat comments like other blank space */
+
+"("			{ tokenCount++; return LPAREN; }
+")"			{ tokenCount++; return RPAREN; }
+"["			{ tokenCount++; return LBRACKET; }
+"]"			{ tokenCount++; return RBRACKET; }
+"+"			{ tokenCount++; return PLUS; }
+"-"			{ tokenCount++; return MINUS; }
+"*"			{ tokenCount++; return TIMES; }
+"="			{ tokenCount++; return OP_COMPARE; }
+"<="			{ tokenCount++; return OP_COMPARE; }
+">="			{ tokenCount++; return OP_COMPARE; }
+
+"<EOF>"		{ tokenCount++; return END_OF_INPUT; }
+
+-?{digit}+	  { tokenCount++; return INT_LITERAL; }
+(#t|#f)	  { tokenCount++; return BOOL_LITERAL; }
+
+{identifier}  { tokenCount++; return IDENTIFIER; }
+
+.			{ scannerError(); continue; }
diff --git a/Compiler/scanner.cc b/Compiler/scanner.cc
new file mode 100644
index 0000000000000000000000000000000000000000..796711518cea5c96e29bb49d1421f85c343db5d1
--- /dev/null
+++ b/Compiler/scanner.cc
@@ -0,0 +1,82 @@
+#include <iostream>
+#include <logic.h>
+#include "scanner.h"
+
+#if ! defined USE_YYLEX
+#define USE_YYLEX 1  /* Use the stuff from scanner-regexp.l by default */
+#endif
+
+using namespace std;
+
+int tokenCount = 0;  // not static because the .l file needs it too
+static bool endOfInput = false;
+static bool calledGetNextTokenAlready = false;
+static string current = "";
+static kindOfToken currentKind;
+
+// some things built into scanner-regexp.cc by the flex system:
+extern int yylex();
+extern char *yytext;  // C-style string
+
+
+string currentToken()
+{
+	precondition(calledGetNextTokenAlready);
+	precondition(tokenAvailable());
+	
+	return current;
+}
+enum kindOfToken currentTokenKind()
+{
+	precondition(calledGetNextTokenAlready);
+	precondition(tokenAvailable());
+
+	return currentKind;
+}
+
+bool tokenAvailable()
+{
+	precondition(calledGetNextTokenAlready);
+	
+	return !endOfInput;
+}
+
+int  tokenNumber()
+{
+	return tokenCount;
+}
+
+void getNextToken()
+{
+	if (calledGetNextTokenAlready && endOfInput) return;  // No soup for you!
+	
+	calledGetNextTokenAlready = true;
+#if USE_YYLEX
+	/// This interfaces with scanner-regexp.cc
+	/// remember to update it from scanner-regexp.l if that is changed!
+	currentKind = kindOfToken(yylex()); // yylex thinks it could return any int but we know better
+	if (currentKind == 0) {
+		endOfInput = true;
+		current      = "";
+	} else {
+		current      = yytext;
+	}
+#else
+	/// HERE IS THE OLD CODE, before I tried lex
+	if (endOfInput || !cin) {
+		endOfInput = true;
+	} else {
+		cin >> current;
+		if (cin && current != "<EOF>") {
+			tokenCount++;
+		} else {
+			endOfInput = true;
+		}
+	}
+#endif
+}
+
+void scannerError()
+{
+	cerr << "Error: illegal token: '" << yytext << "'\n";
+}
diff --git a/Compiler/scanner.h b/Compiler/scanner.h
new file mode 100644
index 0000000000000000000000000000000000000000..e21665ed2bc8d48d33bf8f51de9ca28416f10d2f
--- /dev/null
+++ b/Compiler/scanner.h
@@ -0,0 +1,27 @@
+#ifndef _SCANNER_H_
+#define _SCANNER_H_
+
+#include <string>
+#include "scanner-regexp.h"
+
+// A simple lexical scanner
+
+// return the current token
+//  precondition:     you have called getNextToken at least once
+//                and tokenAvialable did not return false
+std::string currentToken();
+enum kindOfToken currentTokenKind();
+
+// see if there is a token (return false for end-of-input or the special input <EOF>)
+//  precondition: you must have called getNextToken at least once
+bool tokenAvailable();
+
+// return the number of tokens scanned so far
+// precondition: true
+int  tokenNumber();
+
+// advance current token to the next input
+// precondition: true
+void getNextToken();
+
+#endif //_SCANNER_H_
diff --git a/Compiler/scannerDemo.cc b/Compiler/scannerDemo.cc
new file mode 100644
index 0000000000000000000000000000000000000000..3d1e728715c64b5dec127d61a9c248eb633134f4
--- /dev/null
+++ b/Compiler/scannerDemo.cc
@@ -0,0 +1,16 @@
+#include <iostream>
+#include "scanner.h"
+#include "scannerDemo.h"
+
+using std::cout;
+using std::endl;
+
+void scannerDemo()
+{
+	while (getNextToken(), tokenAvailable()) {
+		cout << "Token number " << tokenNumber() << " is ";
+		cout << "'" << currentToken() << "'";
+		cout << ", which is token kind " << kindOfToken(currentTokenKind()) << endl;
+	}
+	cout << "Reached end-of-file, now stopping!" << endl;
+}
diff --git a/Compiler/scannerDemo.h b/Compiler/scannerDemo.h
new file mode 100644
index 0000000000000000000000000000000000000000..4a62e3c9fe5e640dcc0647b0b1df9bb206b854c0
--- /dev/null
+++ b/Compiler/scannerDemo.h
@@ -0,0 +1,13 @@
+/*
+ * scanner_demo.h
+ *
+ *  Created on: Oct 2, 2009
+ *      Author: davew
+ */
+
+#ifndef SCANNER_DEMO_H_
+#define SCANNER_DEMO_H_
+
+void scannerDemo();
+
+#endif /* SCANNER_DEMO_H_ */
diff --git a/Compiler/streams.h b/Compiler/streams.h
new file mode 100644
index 0000000000000000000000000000000000000000..5e892f0f8f893e0f686e901ab29fa3476e27ecd7
--- /dev/null
+++ b/Compiler/streams.h
@@ -0,0 +1,3 @@
+extern std::ostream &trace;
+extern std::ostream &prompt;
+// extern std::ostream &debug;  // could separate these if we had a reason to do so...
diff --git a/Compiler/tests/01-multiply.hrk b/Compiler/tests/01-multiply.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..412d02f309785591aa1d609c1108398fed75433c
--- /dev/null
+++ b/Compiler/tests/01-multiply.hrk
@@ -0,0 +1 @@
+(* 6 7)
diff --git a/Compiler/tests/02-add-and-mult.hrk b/Compiler/tests/02-add-and-mult.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..b0740fa6d3c99839d0bd3a14890c5dd1b12090d4
--- /dev/null
+++ b/Compiler/tests/02-add-and-mult.hrk
@@ -0,0 +1 @@
+(* (+ 2 5) (+ (+ 1 (* 2 1)) (+ 2 1)))
diff --git a/Compiler/tests/03-mult-input.hrk b/Compiler/tests/03-mult-input.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..d0527aaf109e751f7956fea14effb790fbbe252b
--- /dev/null
+++ b/Compiler/tests/03-mult-input.hrk
@@ -0,0 +1 @@
+(* 3 (getint))
diff --git a/Compiler/tests/04-mult-exit.hrk b/Compiler/tests/04-mult-exit.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..19f08ddfbf4dce603c3456d5a5c3ff422cf27723
--- /dev/null
+++ b/Compiler/tests/04-mult-exit.hrk
@@ -0,0 +1 @@
+(* 3 (exit))
diff --git a/Compiler/tests/arithmetic or comparison operation type error.txt b/Compiler/tests/arithmetic or comparison operation type error.txt
new file mode 100644
index 0000000000000000000000000000000000000000..74171143e261de0bc3b254b650af40c193bedf3e
--- /dev/null
+++ b/Compiler/tests/arithmetic or comparison operation type error.txt	
@@ -0,0 +1 @@
+( <= 4 #f ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/comparison.txt b/Compiler/tests/comparison.txt
new file mode 100644
index 0000000000000000000000000000000000000000..8bdf47dbd9ea3f0bc1319e04feb58aee6c3ce058
--- /dev/null
+++ b/Compiler/tests/comparison.txt
@@ -0,0 +1 @@
+( <= 4 5 ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if type error.txt b/Compiler/tests/if type error.txt
new file mode 100644
index 0000000000000000000000000000000000000000..60dca31173babb20287ac03e8cda9f9669101989
--- /dev/null
+++ b/Compiler/tests/if type error.txt	
@@ -0,0 +1 @@
+(if #t 3 h) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if.txt b/Compiler/tests/if.txt
new file mode 100644
index 0000000000000000000000000000000000000000..0fbbcb19e4e2929c3eaa6d30d03260f63901f1bb
--- /dev/null
+++ b/Compiler/tests/if.txt
@@ -0,0 +1 @@
+(if #t (if #f 2 3) (if #t 4 5)) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/let.txt b/Compiler/tests/let.txt
new file mode 100644
index 0000000000000000000000000000000000000000..3fe340a7484f889f26288b6a1175d4a6373d5e93
--- /dev/null
+++ b/Compiler/tests/let.txt
@@ -0,0 +1 @@
+(+ (letstar ( [x 1] [y 2] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/letstar.txt b/Compiler/tests/letstar.txt
new file mode 100644
index 0000000000000000000000000000000000000000..366eb923d0f93ca9fdb2006108e0a168112eb779
--- /dev/null
+++ b/Compiler/tests/letstar.txt
@@ -0,0 +1 @@
+(+ (letstar ( [x 3] [y x] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested let.txt b/Compiler/tests/nested let.txt
new file mode 100644
index 0000000000000000000000000000000000000000..17e52566013a6c055a7c8ad9fbb3ae9b235f7ece
--- /dev/null
+++ b/Compiler/tests/nested let.txt	
@@ -0,0 +1 @@
+(+ (letstar ( [x 1] [y 2] ) (+ x (letstar ( [z 3] [y 4] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested letstar.txt b/Compiler/tests/nested letstar.txt
new file mode 100644
index 0000000000000000000000000000000000000000..8808cc7ddf8d4f32094aa7e973959b70d9441474
--- /dev/null
+++ b/Compiler/tests/nested letstar.txt	
@@ -0,0 +1 @@
+(+ (letstar ( [x 4] [y 2] ) (+ x (letstar ( [z y] [y x] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file

From c3348aff84c367231c701704ff57534b80c89ab2 Mon Sep 17 00:00:00 2001
From: keithmburu <54857948+keithmburu@users.noreply.github.com>
Date: Mon, 18 Jul 2022 15:11:16 +0300
Subject: [PATCH] Delete Compiler directory

---
 Compiler/.cproject                                 |   72 -
 Compiler/.gitignore                                |    8 -
 Compiler/.project                                  |   82 -
 Compiler/AST.cc                                    |  242 ---
 Compiler/AST.h                                     |  245 ---
 Compiler/CMakeLists.txt                            |   18 -
 Compiler/ContextInfo.cc                            |   46 -
 Compiler/ContextInfo.h                             |   22 -
 Compiler/Dictionary.cpp                            |  124 --
 Compiler/Dictionary.h                              |  101 --
 Compiler/README-Collaboration.txt                  |    1 -
 Compiler/README-Design.txt                         |   16 -
 Compiler/README_Sources.txt                        |    1 -
 Compiler/generateHERA.cc                           |  238 ---
 Compiler/main.cc                                   |  132 --
 Compiler/parser.cc                                 |  241 ---
 Compiler/parser.h                                  |   18 -
 Compiler/scanner-regexp.cc                         | 1871 --------------------
 Compiler/scanner-regexp.h                          |   13 -
 Compiler/scanner-regexp.l                          |   62 -
 Compiler/scanner.cc                                |   82 -
 Compiler/scanner.h                                 |   27 -
 Compiler/scannerDemo.cc                            |   16 -
 Compiler/scannerDemo.h                             |   13 -
 Compiler/streams.h                                 |    3 -
 Compiler/tests/01-multiply.hrk                     |    1 -
 Compiler/tests/02-add-and-mult.hrk                 |    1 -
 Compiler/tests/03-mult-input.hrk                   |    1 -
 Compiler/tests/04-mult-exit.hrk                    |    1 -
 ...ithmetic or comparison operation type error.txt |    1 -
 Compiler/tests/comparison.txt                      |    1 -
 Compiler/tests/if type error.txt                   |    1 -
 Compiler/tests/if.txt                              |    1 -
 Compiler/tests/let.txt                             |    1 -
 Compiler/tests/letstar.txt                         |    1 -
 Compiler/tests/nested let.txt                      |    1 -
 Compiler/tests/nested letstar.txt                  |    1 -
 37 files changed, 3706 deletions(-)

diff --git a/Compiler/.cproject b/Compiler/.cproject
deleted file mode 100644
index 187849bc6ae681ba924a946dd7fa6428d1fb0f9a..0000000000000000000000000000000000000000
--- a/Compiler/.cproject
+++ /dev/null
@@ -1,72 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
-	<storageModule moduleId="org.eclipse.cdt.core.settings">
-		<cconfiguration id="cdt.managedbuild.config.gnu.exe.debug.1161916250">
-			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" moduleId="org.eclipse.cdt.core.settings" name="Debug">
-				<externalSettings/>
-				<extensions>
-					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
-					<extension id="org.eclipse.cdt.core.MakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
-				</extensions>
-			</storageModule>
-			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
-				<configuration artifactExtension="" artifactName="Compiler-C++" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" errorParsers="org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.GASErrorParser" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" name="Debug" parent="cdt.managedbuild.config.gnu.exe.debug">
-					<folderInfo id="cdt.managedbuild.config.gnu.exe.debug.1161916250.1127859407" name="/" resourcePath="">
-						<toolChain id="cdt.managedbuild.toolchain.gnu.exe.debug.1737210637" name="GCC Tool Chain" superClass="cdt.managedbuild.toolchain.gnu.exe.debug">
-							<targetPlatform id="cdt.managedbuild.target.gnu.platform.exe.debug.1043903385" name="Debug Platform" superClass="cdt.managedbuild.target.gnu.platform.exe.debug"/>
-							<builder buildPath="${workspace_loc:/Interpreter-C++/Debug}" id="cdt.managedbuild.target.gnu.builder.exe.debug.1885040107" keepEnvironmentInBuildfile="false" name="Gnu Make Builder" superClass="cdt.managedbuild.target.gnu.builder.exe.debug"/>
-							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug.1315278191" name="GCC C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug">
-								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.compiler.option.include.paths.668525549" name="Include paths (-I)" superClass="gnu.cpp.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
-									<listOptionValue builtIn="false" value="/home/courses/include"/>
-								</option>
-								<option id="gnu.cpp.compiler.exe.debug.option.optimization.level.793100283" name="Optimization Level" superClass="gnu.cpp.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.optimization.level.none" valueType="enumerated"/>
-								<option id="gnu.cpp.compiler.exe.debug.option.debugging.level.1408142720" name="Debug Level" superClass="gnu.cpp.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.debugging.level.max" valueType="enumerated"/>
-								<option id="gnu.cpp.compiler.option.dialect.std.1577870906" name="Language standard" superClass="gnu.cpp.compiler.option.dialect.std" useByScannerDiscovery="true" value="gnu.cpp.compiler.dialect.c++1y" valueType="enumerated"/>
-								<inputType id="cdt.managedbuild.tool.gnu.cpp.compiler.input.842239186" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.input"/>
-							</tool>
-							<tool id="cdt.managedbuild.tool.gnu.c.compiler.exe.debug.351478677" name="GCC C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.exe.debug">
-								<option defaultValue="gnu.c.optimization.level.none" id="gnu.c.compiler.exe.debug.option.optimization.level.1879412635" name="Optimization Level" superClass="gnu.c.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" valueType="enumerated"/>
-								<option id="gnu.c.compiler.exe.debug.option.debugging.level.648859551" name="Debug Level" superClass="gnu.c.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.c.debugging.level.max" valueType="enumerated"/>
-								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.219263748" superClass="cdt.managedbuild.tool.gnu.c.compiler.input"/>
-							</tool>
-							<tool id="cdt.managedbuild.tool.gnu.c.linker.exe.debug.370219233" name="GCC C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.exe.debug"/>
-							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug.1321052876" name="GCC C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug">
-								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.libs.311614395" name="Libraries (-l)" superClass="gnu.cpp.link.option.libs" useByScannerDiscovery="false" valueType="libs">
-									<listOptionValue builtIn="false" value="courses"/>
-								</option>
-								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.paths.603027165" name="Library search path (-L)" superClass="gnu.cpp.link.option.paths" useByScannerDiscovery="false" valueType="stringList">
-									<listOptionValue builtIn="false" value="/home/courses/lib"/>
-								</option>
-								<inputType id="cdt.managedbuild.tool.gnu.cpp.linker.input.2141151307" superClass="cdt.managedbuild.tool.gnu.cpp.linker.input">
-									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
-									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
-								</inputType>
-							</tool>
-							<tool id="cdt.managedbuild.tool.gnu.assembler.exe.debug.1455701237" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.exe.debug">
-								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.1492382276" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
-							</tool>
-							<tool id="cdt.managedbuild.tool.gnu.archiver.base.1329154531" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.base"/>
-						</toolChain>
-					</folderInfo>
-				</configuration>
-			</storageModule>
-			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
-		</cconfiguration>
-	</storageModule>
-	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
-		<project id="Interpreter-C++.cdt.managedbuild.target.gnu.exe.1148232902" name="Executable (Gnu)" projectType="cdt.managedbuild.target.gnu.exe"/>
-	</storageModule>
-	<storageModule moduleId="scannerConfiguration"/>
-	<storageModule moduleId="refreshScope" versionNumber="2">
-		<configuration configurationName="Debug">
-			<resource resourceType="PROJECT" workspacePath="/Compiler-C++"/>
-		</configuration>
-	</storageModule>
-	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
-	<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
-</cproject>
diff --git a/Compiler/.gitignore b/Compiler/.gitignore
deleted file mode 100644
index 53afa4bd2ed50486fa864ebe3ff0741b409cd07f..0000000000000000000000000000000000000000
--- a/Compiler/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-*~
-#*#
-cmake-build-debug
-Debug
-.settings
-.idea
-.DS_Store
-Compiler.out
diff --git a/Compiler/.project b/Compiler/.project
deleted file mode 100644
index 0984b263388088ba78e995b6649bd345b6792269..0000000000000000000000000000000000000000
--- a/Compiler/.project
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>Compiler-C++</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
-			<triggers>clean,full,incremental,</triggers>
-			<arguments>
-				<dictionary>
-					<key>?name?</key>
-					<value></value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.append_environment</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
-					<value>all</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildArguments</key>
-					<value></value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildCommand</key>
-					<value>make</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildLocation</key>
-					<value>${workspace_loc:/Tree-C++/Debug}</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
-					<value>clean</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.contents</key>
-					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
-					<value>false</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
-					<value>all</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.stopOnError</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
-					<value>true</value>
-				</dictionary>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.cdt.core.cnature</nature>
-		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
-		<nature>org.eclipse.cdt.core.ccnature</nature>
-		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
-	</natures>
-</projectDescription>
diff --git a/Compiler/AST.cc b/Compiler/AST.cc
deleted file mode 100644
index f724dd37ddd777df0831046ff320488ece022f1a..0000000000000000000000000000000000000000
--- a/Compiler/AST.cc
+++ /dev/null
@@ -1,242 +0,0 @@
-#include <hc_list.h>
-#include <hc_list_helpers.h>
-#include "parser.h"  // for n_errors count; this should really be refactored
-#include "streams.h"
-
-using std::string;
-using std::endl;
-using HaverfordCS::list;
-
-
-#include <fstream>  /* needed for ofstream below */
-#if defined TRACE_EXPR_ALLOCATIONS
-static std::ofstream  alloc_trace(TRACE_EXPR_ALLOCATIONS);
-#else
-// by default, allow option for control via environment variable, but it's not given, send to /dev/null (disappears)
-static std::ofstream alloc_trace(getenv("HAVERRACKET_ALLOC_TRACE")?getenv("HAVERRACKET_ALLOC_TRACE"):"/dev/null");
-// static std::ofstream &alloc_trace = trace;  // alternate easy option, just send to regular trace
-#endif
-
-
-
-// This file has the constructors and destructors;
-//   all the generateHERA methods are together in generateHERA.cc
-
-
-// C++ Usage Note:
-// The v(value) is like having v=value, but initializes v rather than assigning to it
-// i.e., writing "v = value" in the constructor _body_ is like writing
-// i.e., writing "v = value" in the constructor _body_ is like writing
-//     int i;
-//     i = 12;
-// whereas writing v(value) before the body is like writing
-//     int i=12;  // i is created with "12" from the start
-//
-// Those steps, as the call(s) to any superclass(es)' constructors, are done before the body of the IntLiteralNode itself
-IntLiteralNode::IntLiteralNode(int value) : v(value)
-{
-	// nothing else needs to be done here, since the stuff above defines "v" as "value"
-	alloc_trace << "(class IntLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
-}
-
-BoolLiteralNode::BoolLiteralNode(string value) : v((value == "#t")? 1 : 0)
-{
-    // nothing else needs to be done here, since the stuff above defines "v" as "value"
-    alloc_trace << "(class BoolLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
-}
-
-// (so, we should see this trace before the one above, for each int literal node)
-ExprNode::ExprNode()
-{
-	alloc_trace << "[superclass ExprNode constructor  called for node at memory " << this << endl;
-}
-
-ComparisonNode::ComparisonNode(string op, ExprNode *lhs, ExprNode *rhs) :
-	o(op),
-	left(lhs),
-	right(rhs)
-{
-	alloc_trace << "(class ComparisonNode constructor called for node at memory " << this << endl;
-}
-
-ArithmeticNode::ArithmeticNode(string op, list<ExprNode *>operands) :
-	o(op),
-	subexps(operands)
-{
-	alloc_trace << "(class ArithmeticNode constructor called for node at memory " << this << endl;
-}
-
-
-VarUseNode::VarUseNode(string name) : n(name)
-{
-	alloc_trace << "(class     VarUseNode constructor called for node at memory " << this << endl;
-}
-
-CallNode::CallNode(string funcName, HaverfordCS::list<ExprNode *>arguments) :
-	n(funcName),
-	argList(arguments)
-{
-	alloc_trace << "(class       CallNode constructor called for node at memory " << this << endl;
-}
-
-IfNode::IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse) :
-    condition(condition),
-    expriftrue(expriftrue),
-    expriffalse(expriffalse)
-{
-    alloc_trace << "(class IfNode constructor called for node at memory " << this << endl;
-}
-
-LetNode::LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions) :
-        declarations(declarations),
-        expressions(expressions)
-{
-    alloc_trace << "(class LetNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationsNode::DeclarationsNode(HaverfordCS::list<ExprNode *> declarations) :
-        declarations(declarations)
-{
-    alloc_trace << "(class DeclarationsNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationNode::DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType) :
-        variable(variable),
-        intLiteral(intLiteral),
-        declType(declType)
-{
-    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationNode::DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType) :
-        variable(variable),
-        boolLiteral(boolLiteral),
-        declType(declType)
-{
-    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationNode::DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType) :
-        variable(variable),
-        definedVar(definedVar),
-        declType(declType)
-{
-    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationNode::DeclarationNode(VarUseNode variable, ExprNode *expr, string declType) :
-        variable(variable),
-        expr(expr),
-        declType(declType)
-{
-    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
-}
-
-// C++ Usage notes:
-//   When an object is destroyed, either because it is on the stack, e.g. as a variable,
-//     or because it is on the free-store heap, the _destructor(s)_ for the object,
-//     including those for the superclass(es) and data fields, are called before
-//     the memory for the object is released for potential re-use
-//     (destructors are called for those fields as they are released,
-//     and the superclass destructor is used after the class' own destructor is done).
-//
-//   Note that _pointers_ do not have destructor methods, so while e.g. when a "+" node
-//     goes away, the "string o" data field in the ArithmeticNode will automatically run,
-//     but nothing happens (by default) for the trees _pointed_to_ by "subexps".
-//     (ArithmeticNode's destructor also runs, of course, and so _it_ may take care of subexps)
-
-ExprNode::~ExprNode()  // nothing to do, but this ensures all subclasses will have virtual destructors, which C++ likes
-{
-	alloc_trace << " superclass ExprNode destructor   called for node at memory " << this << "]" << endl;
-}
-
-IntLiteralNode::~IntLiteralNode()
-{
-	alloc_trace << " class IntLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
-	// nothing needs to be done here,
-	//  except for tracing we could have omitted this.
-}
-
-BoolLiteralNode::~BoolLiteralNode()
-{
-    alloc_trace << " class BoolLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
-    // nothing needs to be done here,
-    //  except for tracing we could have omitted this.
-}
-
-#if FREE_AST_VIA_DESTRUCTORS
-
-// Memory management strategy:
-//   In a _Tree_, we know that any node will have at most one parent.
-//   Since the parser returns a pointer to the _root_,
-//     and no methods give access to any node's child pointers,
-//     we know that, when the root goes away, all the sub-trees can go away too.
-//   So, when the main program "delete"s the root,
-//     that will trigger the root's destructor; if that delete's any tree children,
-//     the whole thing will then be destroyed recursively.
-
-// Note that no destructor is needed for "IntLiteralNode".
-//   It has no subtrees, and data fields go away automatically when the node is deleted
-
-// In contrast, a ComparisonNode has subtree pointers "left" and "right".
-//   When we delete a ComparisonNode, those _pointers_ go away,
-//   but the trees on the free-store heap will last until we delete them.
-//   Since, as noted, we know there are no other pointers to them,
-//   we delete them when the ComparisonNode goes away:
-
-ComparisonNode::~ComparisonNode()
-{
-	alloc_trace << " class ComparisonNode  destructor called for node at memory " << this << ")" << endl;
-
-	delete left;
-	delete right;
-}
-
-void deleteAllSubtrees(list<ExprNode *>subtrees)
-{
-	if (!empty(subtrees)) {
-		delete head(subtrees);
-		deleteAllSubtrees(rest(subtrees));
-	}
-}
-
-ArithmeticNode::~ArithmeticNode()
-{
-	alloc_trace << " class ArithmeticNode  destructor called for node at memory " << this << ")" << endl;
-	
-	deleteAllSubtrees(subexps);
-}
-
-VarUseNode::~VarUseNode()
-{
-	alloc_trace << " class     VarUseNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-CallNode::~CallNode()
-{
-	alloc_trace << " class       CallNode  destructor called for node at memory " << this << ")" << endl;
-	
-	deleteAllSubtrees(argList);
-}
-
-IfNode::~IfNode()
-{
-    alloc_trace << " class     IfNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-LetNode::~LetNode()
-{
-    alloc_trace << " class     LetNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-DeclarationsNode::~DeclarationsNode()
-{
-    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-DeclarationNode::~DeclarationNode()
-{
-    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-#endif
diff --git a/Compiler/AST.h b/Compiler/AST.h
deleted file mode 100644
index 07e3b7ceebfc3d09d688f4fd3db3742408d00b45..0000000000000000000000000000000000000000
--- a/Compiler/AST.h
+++ /dev/null
@@ -1,245 +0,0 @@
-#ifndef AST_H_
-#define AST_H_
-
-#include <string>
-#include <hc_list.h>
-#include "ContextInfo.h"
-#include "Dictionary.h"
-
-
-/*
- *  This file defines the heirarchy of different kinds of AST nodes.
- *  Currently we have:
- *    ExprNode (an "interface" class for expressions, with the following concrete subclasses ("implementers" of the interface):
- *	IntLiteralNode(int value)
- *	ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs)
- *	ArithmeticNode(std::string op, list<ExprNode *>)
- *	VarUseNode(std::string name)
- *	CallNode(std::string name, HaverfordCS::list<ExprNode *>arguments)
- *
- *  The "generateHERA" methods are usually called by calling generateFullHERA on the root,
- *      which puts "CBON" at the start.
- */
-
-#if ! defined FREE_AST_VIA_DESTRUCTORS
-#define FREE_AST_VIA_DESTRUCTORS true
-#endif
-
-// C++ Usage Note:
-// The empty class definition of ContextInfo below lets us declare "const ContextInfo &" parameters
-//   without having to define the whole class here, which is fine because, at this point,
-//   we don't care much about what's in it ... we just need to know that there's some way
-//   to pass information down to the subtrees as we evaluate them.
-
-
-// Define the information will we need to pass down the tree as we generate code, see ContextInfo.h
-class ContextInfo;
-
-extern Dictionary declarationDict;
-
-// C++ Usage Note:
-//
-// The word "virtual" is needed in C++ when inheritance is use,
-//   to explicitly tell the compiler that we might override a function in a subclass
-// Java has the correct default of allowing this, and the keyword "final" prevents it.
-//   Many C++ compilers fail to complain if you forget the word "virtual" and override a method anyway :-(
-//
-// Putting "= 0" at the end of a virtual function declaration means
-//   that the method _must_ be overridden in subclasses
-//
-// Classes with virtual functions and (in subclasses) data with destructors need to have
-//  virtual destructors, to help the C++ compiler be sure the right data destructors are called
-
-
-// Class ExprNode is an interface that defines the methods that all
-//   expression nodes in our AST will provide
-// C++ does not have Java's "interface" keyword, so instead
-//   we just create a superclass with no data and all functions virtual
-
-class ExprNode {
-public:
-	ExprNode();           // just used for memory allocation labs, to print trace information
-	virtual ~ExprNode();  // used for actual memory allocation, sometimes, and for tracing
-
-    virtual std::string generateHERA(const ContextInfo &info) const = 0;
-    virtual std::string getType() const = 0;
-
-    ExprNode* operator==(ExprNode *other) {
-        this->type = other->type;
-        return this;
-    }
-private:
-    std::string type;
-};
-
-std::string generateFullHERA(ExprNode *presumedRoot);
-
-
-
-// Now, the various specific kinds of expressions we might have:
-
-class IntLiteralNode : public ExprNode {
-	public:
-		IntLiteralNode(int value);
-		~IntLiteralNode();  // just used for trace output
-
-        int getValue() const { return v; }
-        std::string getType() const { return type; }
-
-		std::string generateHERA(const ContextInfo &info) const;
-	private:
-		int v;  // the value
-        const std::string type = "IntLiteralNode";
-};
-
-class BoolLiteralNode : public ExprNode {
-public:
-    BoolLiteralNode(std::string value);
-    ~BoolLiteralNode();  // just used for trace output
-
-    int getValue() const { return v; }
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    int v;  // the value
-    const std::string type = "BoolLiteralNode";
-};
-
-class ComparisonNode : public ExprNode {  // <= etc., _inherently_binary_ in HaverRacket
-public:
-    ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs);
-#if FREE_AST_VIA_DESTRUCTORS
-    ~ComparisonNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    std::string o;
-    ExprNode *left;
-    ExprNode *right;
-    const std::string type = "ComparisonNode";
-};
-
-class ArithmeticNode : public ExprNode {  // +, *, -, etc.
-	public:
-		ArithmeticNode(std::string op, HaverfordCS::list<ExprNode *>);
-#if FREE_AST_VIA_DESTRUCTORS
-		~ArithmeticNode();
-#endif
-        std::string getType() const { return type; }
-
-        std::string generateHERA(const ContextInfo &info) const;
-	private:
-		std::string o;
-		HaverfordCS::list<ExprNode *>subexps;
-        const std::string type = "ArithmeticNode";
-};
-
-/*
-   This represents the use of an identifier as an expression, e.g. the x in (* x 6).
-   Note that identifiers also exist in variable declarations, e.g. (let ((x 7)) ... )
-     but the x there doesn't count as an _expression_ since we're not asking for its value.
- */
-class VarUseNode : public ExprNode {
-	public:
-		VarUseNode(std::string name);
-		~VarUseNode();
-
-        std::string getValue() const { return n; }
-        std::string getType() const { return type; }
-
-        std::string generateHERA(const ContextInfo &info) const;
-	private:
-		std::string n;
-        const std::string type = "VarUseNode";
-};
-
-
-class CallNode : public ExprNode {
-	public:
-		CallNode(std::string funcName, HaverfordCS::list<ExprNode *>arguments);
-#if FREE_AST_VIA_DESTRUCTORS
-		~CallNode();
-#endif
-        std::string getType() const { return type; }
-
-        std::string generateHERA(const ContextInfo &info) const;
-	private:
-		std::string n;  // the name
-		HaverfordCS::list<ExprNode *>argList;
-        const std::string type = "CallNode";
-};
-
-class IfNode : public ExprNode {
-public:
-    IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse);
-#if FREE_AST_VIA_DESTRUCTORS
-    ~IfNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    ExprNode *condition;
-    ExprNode *expriftrue;
-    ExprNode *expriffalse;
-    const std::string type = "IfNode";
-};
-
-class DeclarationsNode : public ExprNode {
-public:
-    DeclarationsNode(HaverfordCS::list<ExprNode *> declarations);
-    HaverfordCS::list<ExprNode *> getDeclarations();
-    std::string declarationsHelper(std::string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const;
-#if FREE_AST_VIA_DESTRUCTORS
-    ~DeclarationsNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    HaverfordCS::list<ExprNode *> declarations;
-    const std::string type = "DeclarationsNode";
-};
-
-class DeclarationNode : public ExprNode {
-public:
-    DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType);
-    DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType);
-    DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType);
-    DeclarationNode(VarUseNode variable, ExprNode *expr, string declType);
-#if FREE_AST_VIA_DESTRUCTORS
-    ~DeclarationNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    VarUseNode variable;
-    VarUseNode definedVar = VarUseNode("defaultVar");
-    std::string declType;
-    IntLiteralNode intLiteral = IntLiteralNode(0);
-    BoolLiteralNode boolLiteral = BoolLiteralNode("#f");
-    ExprNode *expr = new IntLiteralNode(0);
-    const std::string type = "DeclarationNode";
-};
-
-class LetNode : public ExprNode {
-public:
-    LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions);
-#if FREE_AST_VIA_DESTRUCTORS
-    ~LetNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-    std::string expressionsHelper(std::string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const;
-    private:
-    ExprNode *declarations;
-    HaverfordCS::list<ExprNode *> expressions;
-    const std::string type = "LetNode";
-};
-
-#endif /*AST_H_*/
diff --git a/Compiler/CMakeLists.txt b/Compiler/CMakeLists.txt
deleted file mode 100644
index 7cb37994904c3d06c0f02dba37ab1c2099289280..0000000000000000000000000000000000000000
--- a/Compiler/CMakeLists.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-cmake_minimum_required(VERSION 3.1)
-project(Compiler_C++)
-
-set(CMAKE_CXX_STANDARD 20)
-
-add_executable(Compiler_C++
-  scanner-regexp
-  scanner
-  scannerDemo
-  parser
-  AST
-  ContextInfo
-  generateHERA
-  main
-  Dictionary
-)
-
-include_directories(../HaverfordCS/include /home/courses/include)
diff --git a/Compiler/ContextInfo.cc b/Compiler/ContextInfo.cc
deleted file mode 100644
index 01b49eebb2aa8a5193237087a85e5b882806518e..0000000000000000000000000000000000000000
--- a/Compiler/ContextInfo.cc
+++ /dev/null
@@ -1,46 +0,0 @@
-#include "ContextInfo.h"
-#include <string.h>
-
-// To provide unique register numbers for each subexpression, with leftmost-executed-first
-//   we'll start with 1 at the root, make the rightmost child's number same as its parent,
-//   and make each other child one more than the sibling to its right.
-
-static const int minRegNum= 1;  // Lowest  register number we're going to use
-static const int maxRegNum=10;  // Highest register number we're going to use
-static const char labeler[] = "abcdefghijklmnopqrstuvwxyz";
-std::string label;
-
-ContextInfo::ContextInfo():
-	myRegNumber(maxRegNum)
-{
-}
-
-// Private constructor for use in e.g. evalThisFirst
-ContextInfo::ContextInfo(int r):
-	myRegNumber(r)
-{
-}
-
-ContextInfo ContextInfo::evalThisAfter() const
-{
-	if (myRegNumber <= minRegNum) {
-		throw "Out of register numbers, expression to complicated";
-	}
-	return ContextInfo(this->myRegNumber-1);
-}
-
-std::string ContextInfo::getReg() const
-{
-	return "R"+std::to_string(myRegNumber);
-}
-
-std::string ContextInfo::labelfunc() const
-{
-    std::string label = "";
-    return label + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26];
-}
-
-std::string ContextInfo::getLabel() const
-{
-    return label;
-}
diff --git a/Compiler/ContextInfo.h b/Compiler/ContextInfo.h
deleted file mode 100644
index bed4578779e50ce52186e7ddbb8209c28da7d556..0000000000000000000000000000000000000000
--- a/Compiler/ContextInfo.h
+++ /dev/null
@@ -1,22 +0,0 @@
-#include <string>
-#ifndef CONTEXT_INFO
-#define CONTEXT_INFO
-class ContextInfo {
-public:
-	ContextInfo(); // create an empty one, appropriate for the TOP of a parse tree
-
-	ContextInfo evalThisAfter() const; // create another context for something to be evaluated later
-
-	std::string getReg() const;
-	std::string labelfunc() const;
-    std::string getLabel() const;
-private:
-	// "myRegNumber" will tell each expression what register number they should use for their result
-	//  should generally be different for the subexpressions of a node,
-	//  and if X is evalualuated before Y, it should have a higher number.
-
-	ContextInfo(int myRegNum);  // called by e.g. evalThisFirst, to build new contexts
-	int myRegNumber;
-	std::string label = labelfunc();
-};
-#endif //CONTEXT_INFO
\ No newline at end of file
diff --git a/Compiler/Dictionary.cpp b/Compiler/Dictionary.cpp
deleted file mode 100644
index 66a98511809d2e6368e96addfae57864fb62e5ac..0000000000000000000000000000000000000000
--- a/Compiler/Dictionary.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-//
-// Created by Keith_Mburu on 3/15/2021.
-//
-
-#include "Dictionary.h"
-
-// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
-/**
- * method that recurses through dictionary checking for entry
- *
- * @return true or false
- */
-bool Dictionary::containsHelper (const list<pair<string,int>> &dList, const string &entry) {
-    if (empty(dList)) {
-        return false;
-    }
-    else {
-        if ((get<0>(head(dList)) == entry)) {
-            return true;
-        }
-        return containsHelper(rest(dList), entry);
-    }
-}
-
-/**
- * method that checks if entry is in dictionary
- *
- * @return true or false
- */
-bool Dictionary::contains (const string &entry) {
-    return containsHelper(getList(), entry);
-}
-
-// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
-/**
- * method that recurses through dictionary until it finds and returns integer assigned to entry
- *
- * @param entry string being looked up
- * @param dList dictionary data field
- * @return the integer
- */
-int Dictionary::lookupHelper (const list<pair<string,int>> &dList, const string &entry) {
-    if (empty(dList)) {
-        return -1;
-    }
-    else if ((get<0>(head(dList)) == entry)) {
-        return get<1>(head(dList));
-    }
-    return lookupHelper(rest(dList), entry);
-}
-
-/**
- * method that checks the integer assigned to entry of dictionary
- *
- * @param entry string being looked up
- * @return the integer
- */
-int Dictionary::lookup (const string &entry) {
-    return lookupHelper(getList(), entry);
-}
-
-/**
- * method that converts dictionary to the string that constructs it
- *
- * @return the string
- */
-string Dictionary::toCode () {
-    if (empty(dictList)) {
-        return "Dictionary()\n";
-    }
-    list<pair<string, int>> temp = dictList;
-    string dictCode = "Dictionary()";
-    for (int i = 0; i < length(dictList); i++) {
-        // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
-        dictCode = "Dictionary(" + dictCode + ", \"" + get<0>(first(temp)) + "\", " + to_string(get<1>(first(temp))) +
-                ")";
-        temp = rest(temp);
-    }
-    return dictCode;
-}
-
-/**
- * method that adds new entry to dictionary by constructing new data field
- *
- * @param entry string to be added
- * @param integer integer assigned to the string
- */
-void Dictionary::add (string entry, int integer) {
-    list<pair<string, int>> newList = list<pair<string, int>>(pair<string, int>(entry, integer), dictList);
-    dictList = newList;
-}
-
-// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
-/**
- * method that builds new dictionary data field with redefined entry
- *
- * @return true if successful
- */
-bool Dictionary::replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int
-integer) {
-    if (empty(dList)) {
-        // finished recursion, now replace dictionary data field
-        setList(newList);
-        return true;
-    }
-    if ((get<0>(head(dList)) == entry)) {
-        newList = list<pair<string, int>>(pair<string, int>(get<0>(head(dList)), integer), newList);
-        // continue recursing to build the rest of the dictionary
-        return replaceHelper(newList, rest(dList), entry, integer);
-    }
-    newList = list<pair<string, int>>(head(dList), newList);
-    return replaceHelper(newList, rest(dList), entry, integer);
-}
-
-/**
- * method that replaces the integer assigned to an entry of a dictionary
- *
- * @return true if the replacement was successful
- */
-bool Dictionary::replace (const string &entry, int integer) {
-    replaceHelper(list<pair<string, int>>(), getList(), entry, integer);
-}
-
-
diff --git a/Compiler/Dictionary.h b/Compiler/Dictionary.h
deleted file mode 100644
index 03348453c14653d1f500512f0fe8182c09106e43..0000000000000000000000000000000000000000
--- a/Compiler/Dictionary.h
+++ /dev/null
@@ -1,101 +0,0 @@
-//
-// Created by Keith_Mburu on 3/15/2021.
-//
-
-#ifndef DICTIONARY_H
-#define DICTIONARY_H
-
-#include <hc_list.h>
-#include <hc_list_helpers.h>
-#include <utility>
-
-using namespace HaverfordCS;
-using namespace std;
-
-/**
- * class that instantiates dictionary with string : integer entries
- *
- * @author Keith Mburu
- * @version 3/24/2021
- */
-class Dictionary {
-
-public:
-
-    /**
-     * constructor method for empty dictionary
-     */
-    Dictionary() {
-        dictList = list<std::pair<string,int>>();
-    }
-
-    /**
-     * constructor method for new dictionary with old dictionary plus new entry
-     *
-     * @param oldDict old dictionary
-     * @param entry string to be added to old dictionary
-     * @param integer integer to be assigned to new entry
-     */
-    Dictionary(const Dictionary &oldDict, const string &entry, const int &integer) {
-        dictList = list<pair<string,int>>(pair<string,int>(entry, integer), oldDict.dictList);
-    }
-
-    /**
-     * getter method for list that stores dictionary data
-     *
-     * @return list that stores dictionary data
-     */
-    list<pair<string,int>> getList() {
-        return dictList;
-    }
-
-    /**
-     * setter method for list that stores dictionary data
-     *
-     * @param newList list to replace dictionary list
-     */
-    void setList(list<pair<string, int>> newList) {
-        dictList = newList;
-    }
-
-    // learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
-    // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
-    /**
-     * method that accumulates dictionary entries in string
-     *
-     * @return string containing dictionary entries
-     */
-    string toStringHelper(const list<pair<string,int>> &dictList, string dictString) {
-        if (empty(rest(dictList))) {
-            return dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList)));
-        }
-        dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList))) + "\n";
-        return toStringHelper(rest(dictList), dictString);
-    }
-
-    /**
-     * method that represents dictionary as a string
-     *
-     * @return string containing dictionary entries
-     */
-    string toString() {
-        return toStringHelper(getList(), "");
-    }
-
-    // other methods defined in Dictionary.cpp
-    int lookup (const string &entry);
-    int lookupHelper (const list<pair<string,int>> &dList, const string &entry);
-    bool contains (const string &entry);
-    bool containsHelper (const list<pair<string,int>> &dList, const string &entry);
-    void add (string entry, int integer);
-    bool replace (const string &entry, int integer);
-    bool replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int integer);
-    string toCode ();
-
-private:
-
-    list<pair<string,int>> dictList; // list that stores dictionary data
-
-};
-
-#endif
\ No newline at end of file
diff --git a/Compiler/README-Collaboration.txt b/Compiler/README-Collaboration.txt
deleted file mode 100644
index a4d117a958e7f176f9f498aed0dfc60aee767f99..0000000000000000000000000000000000000000
--- a/Compiler/README-Collaboration.txt
+++ /dev/null
@@ -1 +0,0 @@
-Working alone
\ No newline at end of file
diff --git a/Compiler/README-Design.txt b/Compiler/README-Design.txt
deleted file mode 100644
index 2ec30f9c78dde23cc412d07be3f00c4c19b56183..0000000000000000000000000000000000000000
--- a/Compiler/README-Design.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-PLEASE DO NOT EDIT THIS PRELIMINARY VERISON OF THE FILE, TO AVOID GIT CONFLICTS LATER
- (if you're working before the update version is available, make a copy and edit that)
-
-Important Design Decisions:
-
-   * Sticking to node-based AST structure
-
-
-Project Status (T = code completed and test suite exists, C = code completed, P = in-progress, N = not started):
-
-   T  Parse + and * operations, constants and identifiers
-   T  Build an Object-Oriented AST from the above
-   T  Appropriately allocate registers for arithmetic operations
-   T  Generate HERA code for +, *, and constants
-
- ---- more will be added later ----
diff --git a/Compiler/README_Sources.txt b/Compiler/README_Sources.txt
deleted file mode 100644
index dcbdecf608edb7dcfa732b27c5506086a27df60d..0000000000000000000000000000000000000000
--- a/Compiler/README_Sources.txt
+++ /dev/null
@@ -1 +0,0 @@
-Copy assignment operators - https://en.cppreference.com/w/cpp/language/copy_assignment
\ No newline at end of file
diff --git a/Compiler/generateHERA.cc b/Compiler/generateHERA.cc
deleted file mode 100644
index 9ac1c3feb35fe19bd2fef35f116304f7f49b80bd..0000000000000000000000000000000000000000
--- a/Compiler/generateHERA.cc
+++ /dev/null
@@ -1,238 +0,0 @@
-#include "AST.h"
-#include "ContextInfo.h"
-#include "hc_list_helpers.h"
-#include "streams.h"
-
-using std::string;
-using std::endl;
-
-Dictionary declarationDict = Dictionary();
-int FPoffset = -1;
-
-std::string generateFullHERA(ExprNode *presumedRoot)
-{
-    return "\nCBON()\n" + presumedRoot->generateHERA(ContextInfo());
-}
-
-string IntLiteralNode::generateHERA(const ContextInfo &context) const
-{
-	trace << "Entered IntLiteralNode::generateHERA for integer " + std::to_string(v) << endl;
-	return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
-}
-
-string BoolLiteralNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered BoolLiteralNode::generateHERA for boolean " + std::to_string(v) << endl;
-    return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
-}
-
-std::string HERA_op(const std::string &AST_op_name)
-{
-	if (AST_op_name == "+") {
-		return "ADD";
-	} else if (AST_op_name == "-") {
-		return "SUB";
-	} else if (AST_op_name == "*") {
-		return "MUL";
-    } else if (AST_op_name == "=") {
-        return "CMP";
-    } else if (AST_op_name == ">=") {
-        return "CMP";
-    } else if (AST_op_name == "<=") {
-        return "CMP";
-	} else {
-		throw "Internal compiler inconsistency/incompleteness: HERA_op not implemented for " + AST_op_name;
-	}
-}
-
-string ComparisonNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered ComparisonNode::generateHERA for comparison " + o << endl;
-
-    // see arithmetic node for more about the "context" stuff:
-    //	trace << "need to compare the result of left-hand-side:\n" << left->generateHERA(context) << endl;
-    //	trace << "                        with right-hand-side:\n" << left->generateHERA(context.evalThisAfter()) << endl;
-
-    if (left->getType() != "CallNode" && right->getType() != "CallNode") {
-        if ((left->getType() != "IntLiteralNode" && left->getType() != "VarUseNode" && left->getType() != "LetNode") ||
-                (right->getType() != "IntLiteralNode" && right->getType() != "VarUseNode" && right->getType() != "LetNode")) {
-            cerr << endl << "!Type error! cannot perform comparison operations on non-integers" << endl;
-            exit(98);
-        }
-    }
-
-    ContextInfo rhsContext = context.evalThisAfter();
-    ContextInfo lhsContext = context;  // just named for symmetry
-
-    ContextInfo labelContext1 = ContextInfo();
-    ContextInfo endLabelContext = ContextInfo();
-
-    return left->generateHERA(lhsContext) +
-           right->generateHERA(rhsContext) +
-           HERA_op(o)+"("+lhsContext.getReg()+", "+rhsContext.getReg()+")\n" +
-           "BZ(" + context.getLabel() + ")\n" +
-            ((o == "=")? "SET(" + context.getReg() + ", " + "0)\n" :
-             (o == "<=" || o == ">=")? "BS(" + labelContext1.getLabel() + ")\n" : "") +
-            ((o == ">=")? "SET(" + context.getReg() + ", " + "1)\n" :
-             (o == "<=")? "SET(" + context.getReg() + ", " + "0)\n" : "") +
-            "BR(" + endLabelContext.getLabel() + ")\n" +
-            "LABEL(" + context.getLabel() + ")\n" +
-            "SET(" + context.getReg() + ", " + "1)\n" +
-            "BR(" + endLabelContext.getLabel() + ")\n" +
-            ((o == "<=" || o == ">=")? ("LABEL(" + labelContext1.getLabel() + ")\n" +
-            ((o == "<=")? "SET(" + context.getReg() + ", " + "1)\n" :
-             "SET(" + context.getReg() + ", " + "0)\n")) : "") +
-             "LABEL(" + endLabelContext.getLabel() + ")\n";
-}
-
-string ArithmeticNode::generateHERA(const ContextInfo &context) const
-{
-	trace << "Entered ArithmeticNode::generateHERA for operator " + o << endl;
-	if (length(subexps) != 2) {
-		throw "compiler incomplete/inconsistent: generateHERA not implemented for non-binary arithmetic";
-	}
-
-    if (first(subexps)->getType() != "CallNode" && first(rest(subexps))->getType() != "CallNode") {
-        if ((first(subexps)->getType() != "IntLiteralNode" && first(subexps)->getType() != "VarUseNode" && first(subexps)->getType() != "LetNode") ||
-                (first(rest(subexps))->getType() != "IntLiteralNode" && first(rest(subexps))->getType() != "VarUseNode" && first(rest(subexps))
-                ->getType() != "LetNode")) {
-            cerr << endl << "!Type error! cannot perform arithmetic operations on non-integers" << endl;
-            exit(99);
-        }
-    }
-
-	ContextInfo rhsContext = context.evalThisAfter();
-	ContextInfo lhsContext = context;  // just named for symmetry
-
-    string leftHERA = first(subexps)->generateHERA(lhsContext);
-    string rightHERA = first(rest(subexps))->generateHERA(rhsContext);
-
-    return  leftHERA + rightHERA + HERA_op(o)+"("+context.getReg()+", "+lhsContext.getReg()+", "+rhsContext.getReg()+")\n";
-}
-
-string VarUseNode::generateHERA(const ContextInfo &context) const
-{
-	trace << "Entered VarUseNode::generateHERA for variable " + n << endl;
-
-    return "LOAD(" + context.getReg() + ", " + to_string(declarationDict.lookup(n)) + ", FP)\n";
-}
-
-string CallNode::generateHERA(const ContextInfo &context) const
-{
-	trace << "Entered CallNode::generateHERA for call to " + n << endl;
-	
-	if (length(argList) != 0 || (n != "exit" && n != "getint")) {
-		throw "compiler incomplete/inconsistent: generateHERA for calls only implented for getint and exit";
-	}
-	// NOTE that calls to exit and getint don't need parameters and don't perturb registers
-	return ("MOVE(FP_alt, SP)\nCALL(FP_alt," + n + ")\n"+
-		(context.getReg()=="R1"?"":"MOVE("+context.getReg()+", R1)\n"));
-}
-
-string IfNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered IfNode::generateHERA" << endl;
-
-    if (expriftrue->getType() != "CallNode" && expriffalse->getType() != "CallNode") {
-        if (expriftrue->getType() != expriffalse->getType()) {
-            cerr << endl << "!Type error! \"then\" and \"else\" statements must be of the same type" << endl;
-            exit(45);
-        }
-    }
-
-    ContextInfo conditionContext = context;
-    ContextInfo expriftrueContext = context.evalThisAfter();
-    ContextInfo expriffalseContext = context.evalThisAfter().evalThisAfter();
-
-    ContextInfo labelContext1 = ContextInfo();
-    ContextInfo labelContext2 = ContextInfo();
-
-    string conditionHERA = condition->generateHERA(conditionContext);
-    string expriftrueHERA = expriftrue->generateHERA(expriftrueContext);
-    string expriffalseHERA = expriffalse->generateHERA(expriffalseContext);
-
-    return  conditionHERA + expriftrueHERA + expriffalseHERA +
-            "FLAGS(" + conditionContext.getReg() + ")\n" +
-            "BZ(" + labelContext1.getLabel() + ")\n" +
-            "MOVE(" + context.getReg() + ", " + expriftrueContext.getReg() + ")\n" +
-            "BR(" + labelContext2.getLabel() + ")\n" +
-            "LABEL(" + labelContext1.getLabel() + ")\n" +
-            "MOVE(" + context.getReg() + ", " + expriffalseContext.getReg() + ")\n" +
-            "LABEL(" + labelContext2.getLabel() + ")\n";
-}
-
-string LetNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered LetNode::generateHERA" << endl;
-    ContextInfo declarationsContext = context;
-    ContextInfo expressionsContext = context;
-
-    string expressionsHERA = "";
-    string declarationsHERA = declarations->generateHERA(declarationsContext);
-    expressionsHERA = expressionsHelper(expressionsHERA, expressions, expressionsContext);
-    return declarationsHERA + expressionsHERA;
-}
-
-string LetNode::expressionsHelper(string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const {
-    if (empty(expressions)) {
-        return expressionsHERA;
-    }
-    return expressionsHelper(expressionsHERA += first(expressions)->generateHERA(context), rest(expressions), context.evalThisAfter());
-}
-
-string DeclarationsNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered DeclarationsNode::generateHERA" << endl;
-    ContextInfo declarationsContext = context;
-
-    ContextInfo labelContext = ContextInfo();
-
-    string declarationsHERA = "";
-    return  declarationsHelper(declarationsHERA, declarations, context);
-}
-
-string DeclarationsNode::declarationsHelper(string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const {
-    if (empty(declarations)) {
-        return declarationsHERA;
-    }
-    return declarationsHelper(declarationsHERA += first(declarations)->generateHERA(context), rest(declarations),
-                              context);
-}
-
-string DeclarationNode::generateHERA(const ContextInfo &context) const
-{
-    auto literal = expr;
-    string value;
-    if (declType == "IntLiteralNode") {
-        *literal = intLiteral;
-        value = to_string(intLiteral.getValue());
-    }
-    else if (declType == "BoolLiteralNode") {
-        *literal = boolLiteral;
-        value = boolLiteral.getValue();
-    }
-    else if (declType == "definedVar") {
-        *literal = definedVar;
-        value = definedVar.getValue();
-    }
-
-    trace << "Entered DeclarationNode::generateHERA for declaration " + variable.getValue() + ((declType == "ExprNode")? " = expression" : " = " +
-    value) << endl;
-
-    if (declType == "definedVar") {
-        value = to_string(declarationDict.lookup(value));
-    }
-
-    FPoffset += 1;
-
-    declarationDict.add(variable.getValue(), FPoffset);
-
-    return ((declType == "ExprNode")? literal->generateHERA(context) :
-           (declType == "definedVar")? "LOAD(" + context.getReg() + ", " + value + ", FP)\n" :
-           "SET(" + context.getReg() + ", " + value + ")\n") +
-           "STORE(" + context.getReg() + ", " + std::to_string(FPoffset) + ", FP)\n";
-}
-
-
-
-
diff --git a/Compiler/main.cc b/Compiler/main.cc
deleted file mode 100644
index 0b37124155f50aea45a9f9ce9a02124bdecfde69..0000000000000000000000000000000000000000
--- a/Compiler/main.cc
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * "Compiler" project for HaverRacket
- *  Translate a subset of Racket into HERA
- *
- * To run this project and run the program tests/01-multiply.hrk, use the command:
- *   Debug/Compiler-C++ < tests/01-multiply.hrk | tee Compiler.out
- * and then run the HERA program with the command
- *   HERA-C-Run Compiler.out
- */
-
-#include <iostream>
-#include <cstdlib>
-#include "scannerDemo.h"
-#include "parser.h"
-#include "ContextInfo.h"
-#include "hc_list_helpers.h" // ez_list
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-
-#include "streams.h"
-#include "Dictionary.h"
-
-// to change trace output, compile with
-//   e.g. -DTRACE_OUTPUT_HERE="./my-trace-output.txt"
-//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to throw away trace output
-//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to always use cerr
-//     or -DTRACE_OUTPUT_HERE=(getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
-//        # that last, the default (I hope) should allow run-time selection via e.g.,
-//        HAVERRACKET_TRACE=my-trace-output1.txt Debug/Compiler-C++
-//
-//  similarly for -DPROMPT_OUTPUT_HERE, which defaults to getenv("HAVERRACKET_PROMPT")
-//    note that prompt is not currently used, though
-
-#if ! defined TRACE_OUTPUT_HERE
-#define TRACE_OUTPUT_HERE (getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
-#endif
-#if ! defined PROMPT_OUTPUT_HERE
-#define PROMPT_OUTPUT_HERE (getenv("HAVERRACKET_PROMPT")?getenv("HAVERRACKET_PROMPT"):"/dev/stderr")
-#endif
-
-#include <fstream>  /* needed for ofstream below */
-std::ofstream _HaverRacket_trace(TRACE_OUTPUT_HERE);
-std::ostream &trace  = _HaverRacket_trace;
-std::ofstream _HaverRacket_prompt(PROMPT_OUTPUT_HERE);
-std::ostream &prompt = _HaverRacket_prompt;
-
-#if ! defined AbstractSyntaxTest
-#define AbstractSyntaxTest build_example1   /* this lets us use a different test easily with a special command line */
-#endif
-
-ParserResult AbstractSyntaxTest();
-
-int main(int numberOfCommandLineArguments, char *theCommandLineArguments[])
-{
-	try {
-		bool testScannerInstead = false;
-        if (numberOfCommandLineArguments == 2 && theCommandLineArguments[1] == string("testScannerInstead")) {
-			trace << "Testing Scanner instead." << endl;
-			testScannerInstead = true;
-		}
-
-		if (testScannerInstead) {
-			cout << "Demonstrating lexical scanner. Enter tokens followed by <EOF>." << endl;
-			scannerDemo();
-		} else {
-			if (!getenv("HAVERRACKET_TEST_CODE_HERA") ||
-			    getenv("HAVERRACKET_TEST_CODE_HERA") == string("#t"))
-			{
-				try {
-					ParserResult example1 = AbstractSyntaxTest();
-
-					trace << "confirming codegen basic functionality on test example1:" << endl;
-					string code = generateFullHERA(example1);
-					trace << code << endl;
-					delete example1;  // we're done with example1 now.
-
-				} catch (const char *message) {
-					cerr << "code generation confirmation test threw exception: " << message << endl;
-					return 2;
-				}
-			}
-
-            trace << "Type in new input!" << endl;
-
-            try {
-				ParserResult AST = matchStartSymbolAndEOF();
-//				trace << "Completed Parsing, got AST: " << AST.toCode() << endl;
-				try {
-                    trace << "\nNow generating code: " << endl;
-					trace << generateFullHERA(AST) << endl;
-				} catch (const char *message) {
-					cerr << "eval threw exception (typically an unhandled case): " << message << endl;
-					return 4;
-				}
-#if FREE_AST_VIA_DESTRUCTORS
-				delete AST;
-#endif
-			} catch (const char *message) {
-				cerr << "that's odd, parser threw exception: " << message << endl;
-				return 3;
-			}
-		}
-
-		return 0;  // indicate successful translation if no exit with non-0 before this
-	} catch (range_error) {
-		cerr << "Yikes! Uncaught exception" << endl;
-		return 66;
-	}
-}
-
-
-	    
-
-ParserResult build_example1()
-{
-//	ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new IntLiteralNode(3), new IntLiteralNode(7)));
-//    ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new BoolLiteralNode("#t"), new BoolLiteralNode("#f")));
-    ExprNode *product = new IfNode(new ComparisonNode("<=", new IntLiteralNode(6), new IntLiteralNode(7)), new BoolLiteralNode("#t"), new
-    BoolLiteralNode("#f"));
-
-    return product;
-/*
-  NOTE that the starter files ExprNode classes do _not_ support the following due to memory allocation techniques,
-    though it might seem at first to work:
-*/
-	// return new ArithmeticNode("+", HaverfordCS::ez_list<ExprNode *>(product, product));
-	// return new ComparisonNode("<=", product, product);
-}
-
diff --git a/Compiler/parser.cc b/Compiler/parser.cc
deleted file mode 100644
index c98845df82e3cb8dbd842b84e54a649b19663061..0000000000000000000000000000000000000000
--- a/Compiler/parser.cc
+++ /dev/null
@@ -1,241 +0,0 @@
-#include <iostream>
-#include <cstdlib>  // for 'exit' function to abandon the program
-#include <hc_list_helpers.h>
-#include "parser.h"
-#include "scanner.h"
-
-using std::string;
-using HaverfordCS::list;
-using HaverfordCS::ez_list;
-using std::cout;
-using std::cerr;
-using std::endl;
-
-#include "streams.h"
-
-// match this:
-// START -> E   <followed by end-of-input>
-// E -> integer
-// E -> boolean
-// E -> identifier
-// E -> ( E_IN_PARENS )
-// E? -> E E?
-// E? -> ""
-// E_IN_PARENS -> OP E E
-// E_IN_PARENS -> letstar E E E?
-// E_IN_PARENS -> [ E_IN_BRACKETS ] E_IN_PARENS
-// E_IN_PARENS -> ""
-// E_IN_PARENS -> EXIT
-// E_IN_PARENS -> GETINT   // New in this version, gets user input
-// E_IN_PARENS -> if E E E
-
-// E_IN_BRACKETS -> E E
-
-// OP --> +|-|*|<=|=|>= OP_COMPARE
-
-// Declare all functions, so they can call each other in any order
-//  (note: "static" means it's restricted to this scope, e.g. this file
-static ParserResult matchE();
-static ParserResult matchEInParens();
-static string matchOp();
-
-
-// FIRST and FOLLOW sets for those,
-//  built with lists rather than sets, for familiarity
-//  defined in terms of kindOfToken from scanner-regexp.h
-static list<kindOfToken> FIRST_OP  = ez_list(PLUS, MINUS, TIMES, OP_COMPARE);
-static list<kindOfToken> FIRST_EIP = FIRST_OP;
-static list<kindOfToken> FIRST_E   = ez_list(INT_LITERAL, BOOL_LITERAL, IDENTIFIER, LPAREN, LBRACKET);
-
-static list<kindOfToken> FOLLOW_OP  = FIRST_E;
-static list<kindOfToken> FOLLOW_EIP = ez_list(RPAREN);
-static list<kindOfToken> FOLLOW_E   = /* append(FOLLOW_EIP, FIRST_E) */
-		                              list<kindOfToken>(RPAREN, FIRST_E);
-	                                  /* Dave should put "append" into list_helpers */
-
-// first, some helpful functions:
-
-// mustGetNextToken:
-//    we call this when we need to get more input and we must find something there,
-//    i.e. when we want to move current_token along and end-of-input would be an error
-void mustGetNextToken()
-{
-	getNextToken();
-	if (!tokenAvailable()) {
-		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
-		exit(5);
-	}
-}
-
-
-// currentTokenThenMove
-//   record currentToken (which must NOT be end-of-input), then move past it, return what it was
-static std::string currentTokenThenMove()
-{
-	if (!tokenAvailable()) {
-		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
-		exit(5);
-	}
-	std::string curr = currentToken();
-	getNextToken();
-	return curr;
-}
-
-// confirmLiteral
-//   match a literal, assuming the token HAS been scanned already,
-//    i.e. that "currentToken" is _on_ the literal we wish to match
-//   leave "currentToken" on the very last token of the matched pattern ... this is not a "match" function
-static void confirmLiteral(string what)
-{
-	if (!tokenAvailable()) {
-		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
-		exit(5);
-	}
-	if (currentToken() != what) {
-		cerr << "got " << currentToken() << " instead of " << what << " at token #" << tokenNumber() << endl;
-		exit(2);
-	}	
-}
-
-
-// match an "E", i.e, anything on the right hand side of any "E-->..." production
-//  assume the first token of the E has been scanned
-//   (i.e., assuming currentToken is the first token of the "E" we're matching)
-//  leave "currentToken" AFTER the very last token of the matched pattern
-static ParserResult matchE()
-{
-	trace << "Entering matchE, current token is " << currentToken() << endl;
-	if (currentTokenKind() == INT_LITERAL) {
-        return new IntLiteralNode(std::stoi(currentTokenThenMove()));
-    } else if (currentTokenKind() == BOOL_LITERAL) {
-        return new BoolLiteralNode(currentTokenThenMove());
-	} else if (currentTokenKind() == IDENTIFIER) {
-        return new VarUseNode(currentTokenThenMove());
-	} else if (currentTokenKind() == LPAREN) {	
-		confirmLiteral("(");
-		mustGetNextToken();
-		ParserResult it = matchEInParens();
-		trace << "After matchEInParens, back in matchE, current token is: " << currentToken() << endl;
-		// if that left off AFTER the end of the E_IN_PARENS, we still need a ")" in the E we're matching
-		confirmLiteral(")");
-		getNextToken();	 // we're AFTER the ) now
-		return it;
-	} else {				
-		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
-		exit(3);
-	}
-}
-
-// match an "E_IN_PARENS",
-//  assuming that the currentToken is at the start of the E_IN_PARENS, e.g. a "+"
-//  leave the currentToken AFTER the last part of what was matched,
-//  i.e. *on* the ")" that should come after the E_IN_PARENS
-static ParserResult matchEInParens() {
-	trace << "Entering matchEInParens, current token is " << currentToken() << endl;
-	if (find(currentTokenKind(), FIRST_OP)) {
-        bool its_a_comparison_op = (currentTokenKind() == OP_COMPARE);
-        string theOp = matchOp();
-        ParserResult firstChild = matchE();
-        ParserResult secondChild = matchE();
-        if (its_a_comparison_op) { // a comparison
-            return new ComparisonNode(theOp, firstChild, secondChild);
-        } else {
-            return new ArithmeticNode(theOp, ez_list(firstChild, secondChild));
-        }
-    } else if (currentTokenKind() == LBRACKET) {
-        list<ExprNode *> declarations = list<ExprNode *>();
-	    while (currentTokenKind() != RPAREN) {
-            mustGetNextToken();
-            declarations = list(matchEinBrackets(), declarations);
-            confirmLiteral("]");
-            mustGetNextToken();
-        }
-	    return new DeclarationsNode(reverse(declarations, list<ExprNode *>()));
-    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "if") {
-	    mustGetNextToken();
-	    ParserResult condition = matchE();
-        ParserResult expriftrue = matchE();
-        ParserResult expriffalse = matchE();
-        return new IfNode(condition, expriftrue, expriffalse);
-    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "let*") {
-        mustGetNextToken();
-        ParserResult declarations = matchE();
-        list<ExprNode *> expressions = list<ExprNode *>();
-        while (currentToken() != ")") {
-            expressions = list(matchE(), expressions);
-        }
-	    return new LetNode(declarations, reverse(expressions, list<ExprNode *>()));
-    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "exit") {
-		return new CallNode(currentTokenThenMove(), list<ParserResult>());
-	} else if (currentTokenKind() == IDENTIFIER && currentToken() == "getint") {
-		return new CallNode(currentTokenThenMove(), list<ParserResult>());
-	} else {
-		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
-		exit(3);
-	}
-}
-
-static ParserResult matchEinBrackets() {
-    if (currentTokenKind() == IDENTIFIER) {
-        VarUseNode variable = VarUseNode(currentTokenThenMove());
-        if (currentTokenKind() == IDENTIFIER) {
-            VarUseNode definedVar = VarUseNode(currentTokenThenMove());
-            return new DeclarationNode(variable, definedVar, "definedVar");
-        }
-        else if (currentTokenKind() == INT_LITERAL) {
-            IntLiteralNode literal = IntLiteralNode(stoi(currentTokenThenMove()));
-            return new DeclarationNode(variable, literal, "IntLiteralNode");
-        }
-        else if (currentTokenKind() == BOOL_LITERAL) {
-            BoolLiteralNode literal = BoolLiteralNode(currentTokenThenMove());
-            return new DeclarationNode(variable, literal, "BoolLiteralNode");
-        }
-        else if (currentTokenKind() == LPAREN) {
-            ParserResult expr = matchE();
-            return new DeclarationNode(variable, expr, "ExprNode");
-        }
-    }
-    std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
-    exit(3);
-}
-
-// match an operator, assuming that it is the currentToken
-//  leave the currentToken AFTER the last part of what was matched, i.e. unchanged
-static string matchOp()
-{
-	trace << "Entering matchOp, current token is " << currentToken() << endl;
-	// could do three cases here, but that's so tedious...
-	assert (find(currentTokenKind(), FIRST_OP));
-	return currentTokenThenMove();
-}
-
-
-ParserResult matchStartSymbolAndEOF()
-{
-	getNextToken();  // this will be the first one
-	if (!tokenAvailable()) {
-		cerr << "Illegal end of input" << endl;
-		exit(2);
-	}
-
-	ParserResult fullExpression = matchE();  // "E" is our start symbol
-
-	// now make sure there isn't anything else!
-	getNextToken();
-	if (tokenAvailable()) {
-		cerr << "Warning: extra input after end: " << currentToken() << endl;
-		exit (1);
-	}
-
-	return fullExpression;
-}
-
-list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList) {
-    if (empty(list)) {
-        return newList;
-    }
-    if (length(list) == 1) {
-        return ::list(first(list), newList);
-    }
-    return reverse(rest(list), ::list(first(list), newList));
-}
\ No newline at end of file
diff --git a/Compiler/parser.h b/Compiler/parser.h
deleted file mode 100644
index 93d1b80df7d1f7c9d8bc91365b9e5addea106d1e..0000000000000000000000000000000000000000
--- a/Compiler/parser.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef PARSER_H_
-#define PARSER_H_
-
-
-#include "AST.h"
-
-// The typedef below makes the name "translatedResult"
-//  mean a "Tree" object from our Expr_Node type heirarchy.
-typedef ExprNode *ParserResult;
-
-ParserResult matchStartSymbolAndEOF();
-static ParserResult matchE();
-static ParserResult matchEinParens();
-static ParserResult matchEinBrackets();
-static std::string matchOp();
-list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList);
-
-#endif /*PARSER_H_*/
diff --git a/Compiler/scanner-regexp.cc b/Compiler/scanner-regexp.cc
deleted file mode 100644
index 67ca6baa846697934c3895382b4ac8f58c53fbe7..0000000000000000000000000000000000000000
--- a/Compiler/scanner-regexp.cc
+++ /dev/null
@@ -1,1871 +0,0 @@
-
-#line 2 "<stdout>"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 4
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#ifndef SIZE_MAX
-#define SIZE_MAX               (~(size_t)0)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-/* begin standard C++ headers. */
-
-/* TODO: this is always defined, so inline it */
-#define yyconst const
-
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
-#else
-#define yynoreturn
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an
- *   integer in range [0..255] for use as an array index.
- */
-#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN (yy_start) = 1 + 2 *
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin  )
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
-#define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-extern int yyleng;
-
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-    
-    #define YY_LESS_LINENO(n)
-    #define YY_LINENO_REWIND_TO(ptr)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-#define unput(c) yyunput( c, (yytext_ptr)  )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	int yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = NULL;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart ( FILE *input_file  );
-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
-void yy_delete_buffer ( YY_BUFFER_STATE b  );
-void yy_flush_buffer ( YY_BUFFER_STATE b  );
-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state ( void );
-
-static void yyensure_buffer_stack ( void );
-static void yy_load_buffer_state ( void );
-static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
-#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
-
-void *yyalloc ( yy_size_t  );
-void *yyrealloc ( void *, yy_size_t  );
-void yyfree ( void *  );
-
-#define yy_new_buffer yy_create_buffer
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-typedef flex_uint8_t YY_CHAR;
-
-FILE *yyin = NULL, *yyout = NULL;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-int yylineno = 1;
-
-extern char *yytext;
-#ifdef yytext_ptr
-#undef yytext_ptr
-#endif
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state ( void );
-static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
-static int yy_get_next_buffer ( void );
-static void yynoreturn yy_fatal_error ( const char* msg  );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	(yy_c_buf_p) = yy_cp;
-#define YY_NUM_RULES 19
-#define YY_END_OF_BUFFER 20
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static const flex_int16_t yy_accept[34] =
-    {   0,
-        0,    0,   20,   18,    1,    2,    2,   18,    4,    5,
-       10,    8,    9,   15,    3,   18,   11,   18,   17,    6,
-        7,   16,   15,    3,   12,    0,   13,   17,   17,    0,
-        0,   14,    0
-    } ;
-
-static const YY_CHAR yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    1,    5,    1,    1,    1,    1,    6,
-        7,    8,    9,    1,   10,    1,    1,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,    1,   12,   13,
-       14,   15,    1,    1,   16,   16,   16,   16,   17,   18,
-       16,   16,   16,   16,   16,   16,   16,   16,   19,   16,
-       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
-       20,    1,   21,    1,   22,    1,   23,   23,   23,   23,
-
-       23,   24,   23,   23,   23,   23,   23,   23,   23,   23,
-       23,   23,   23,   23,   23,   25,   23,   23,   23,   23,
-       23,   23,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static const YY_CHAR yy_meta[26] =
-    {   0,
-        1,    1,    2,    1,    1,    1,    1,    3,    1,    1,
-        3,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    3,    3,    3,    3
-    } ;
-
-static const flex_int16_t yy_base[36] =
-    {   0,
-        0,    0,   42,   43,   43,   43,   43,    2,   43,   43,
-       43,   43,   30,   29,    0,   14,   43,   25,   30,   43,
-       43,   43,   26,    0,   43,   17,   43,   43,   27,   15,
-       15,   43,   43,   31,   26
-    } ;
-
-static const flex_int16_t yy_def[36] =
-    {   0,
-       33,    1,   33,   33,   33,   33,   33,   33,   33,   33,
-       33,   33,   33,   33,   34,   33,   33,   33,   35,   33,
-       33,   33,   33,   34,   33,   33,   33,   33,   35,   33,
-       33,   33,    0,   33,   33
-    } ;
-
-static const flex_int16_t yy_nxt[69] =
-    {   0,
-        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
-       14,   15,   16,   17,   18,   19,   19,   19,   19,   20,
-       21,    4,   19,   19,   19,   22,   22,   25,   29,   32,
-       26,   24,   31,   24,   28,   30,   23,   28,   27,   23,
-       23,   33,    3,   33,   33,   33,   33,   33,   33,   33,
-       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
-       33,   33,   33,   33,   33,   33,   33,   33
-    } ;
-
-static const flex_int16_t yy_chk[69] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    8,    8,   16,   35,   31,
-       16,   34,   30,   34,   29,   26,   23,   19,   18,   14,
-       13,    3,   33,   33,   33,   33,   33,   33,   33,   33,
-       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
-       33,   33,   33,   33,   33,   33,   33,   33
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "scanner-regexp.l"
-#line 2 "scanner-regexp.l"
-/*
-
-   This is a lexical scanner specification for the "lex" (or "flex") language.
-   It can be translated into a "C++" file by running, in the project directory, the command
-
-    flex  -t scanner-regexp.l > scanner-regexp.cc
-
-
-   In this first section of the lex file (between %{ and %}),
-   we define C++ functions that will be used later in the actions of part 3.
-
-*/
-
-#include "scanner-regexp.h"
-
-// the code generated by the flex system requires we write this:
-extern "C" int yywrap()
-{
- return 1;
-}
-
-#line 484 "<stdout>"
-/* In this second section of the lex file (after the %}),
-   we can define variables in terms of regular expressions.
-   C-style comments (like this one) are also legal. */
-/* In the third section of the lex file (after the %%),
-   we can define the patterns for each token
-   in terms of regular expressions and the variables above,
-   and give the action (as C++ code) for each token.
-   Comments are legal only inside the actions. */
-#line 493 "<stdout>"
-
-#define INITIAL 0
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals ( void );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy ( void );
-
-int yyget_debug ( void );
-
-void yyset_debug ( int debug_flag  );
-
-YY_EXTRA_TYPE yyget_extra ( void );
-
-void yyset_extra ( YY_EXTRA_TYPE user_defined  );
-
-FILE *yyget_in ( void );
-
-void yyset_in  ( FILE * _in_str  );
-
-FILE *yyget_out ( void );
-
-void yyset_out  ( FILE * _out_str  );
-
-			int yyget_leng ( void );
-
-char *yyget_text ( void );
-
-int yyget_lineno ( void );
-
-void yyset_lineno ( int _line_number  );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap ( void );
-#else
-extern int yywrap ( void );
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-    
-    static void yyunput ( int c, char *buf_ptr  );
-    
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy ( char *, const char *, int );
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen ( const char * );
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput ( void );
-#else
-static int input ( void );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
-#define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		int n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK /*LINTED*/break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	yy_state_type yy_current_state;
-	char *yy_cp, *yy_bp;
-	int yy_act;
-    
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state(  );
-		}
-
-	{
-#line 38 "scanner-regexp.l"
-
-
-#line 713 "<stdout>"
-
-	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-yy_match:
-		do
-			{
-			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 34 )
-					yy_c = yy_meta[yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 43 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 40 "scanner-regexp.l"
-{ continue; }  /* do nothing with blank spaces */
-	YY_BREAK
-case 2:
-/* rule 2 can match eol */
-YY_RULE_SETUP
-#line 41 "scanner-regexp.l"
-{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 42 "scanner-regexp.l"
-{ continue; }  /* treat comments like other blank space */
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 44 "scanner-regexp.l"
-{ tokenCount++; return LPAREN; }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 45 "scanner-regexp.l"
-{ tokenCount++; return RPAREN; }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 46 "scanner-regexp.l"
-{ tokenCount++; return LBRACKET; }
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 47 "scanner-regexp.l"
-{ tokenCount++; return RBRACKET; }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 48 "scanner-regexp.l"
-{ tokenCount++; return PLUS; }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 49 "scanner-regexp.l"
-{ tokenCount++; return MINUS; }
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 50 "scanner-regexp.l"
-{ tokenCount++; return TIMES; }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 51 "scanner-regexp.l"
-{ tokenCount++; return OP_COMPARE; }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 52 "scanner-regexp.l"
-{ tokenCount++; return OP_COMPARE; }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 53 "scanner-regexp.l"
-{ tokenCount++; return OP_COMPARE; }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 55 "scanner-regexp.l"
-{ tokenCount++; return END_OF_INPUT; }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 57 "scanner-regexp.l"
-{ tokenCount++; return INT_LITERAL; }
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 58 "scanner-regexp.l"
-{ tokenCount++; return BOOL_LITERAL; }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 60 "scanner-regexp.l"
-{ tokenCount++; return IDENTIFIER; }
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 62 "scanner-regexp.l"
-{ scannerError(); continue; }
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 63 "scanner-regexp.l"
-ECHO;
-	YY_BREAK
-#line 866 "<stdout>"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_c_buf_p);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap(  ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of user's declarations */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	char *source = (yytext_ptr);
-	int number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			int num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc( (void *) b->yy_ch_buf,
-							 (yy_size_t) (b->yy_buf_size + 2)  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = NULL;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
-			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-		/* "- 2" to take care of EOB's */
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
-	}
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
-
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (void)
-{
-	yy_state_type yy_current_state;
-	char *yy_cp;
-    
-	yy_current_state = (yy_start);
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 34 )
-				yy_c = yy_meta[yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	int yy_is_jam;
-    	char *yy_cp = (yy_c_buf_p);
-
-	YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 34 )
-			yy_c = yy_meta[yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-	yy_is_jam = (yy_current_state == 33);
-
-		return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_UNPUT
-
-    static void yyunput (int c, char * yy_bp )
-{
-	char *yy_cp;
-    
-    yy_cp = (yy_c_buf_p);
-
-	/* undo effects of setting up yytext */
-	*yy_cp = (yy_hold_char);
-
-	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		int number_to_move = (yy_n_chars) + 2;
-		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
-					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		char *source =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
-
-		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
-
-		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-	(yytext_ptr) = yy_bp;
-	(yy_hold_char) = *yy_cp;
-	(yy_c_buf_p) = yy_cp;
-}
-
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap(  ) )
-						return 0;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer( yyin, YY_BUF_SIZE );
-	}
-
-	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
-	yy_load_buffer_state(  );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state(  );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree( (void *) b->yy_ch_buf  );
-
-	yyfree( (void *) b  );
-}
-
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
-
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state(  );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state(  );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state(  );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	yy_size_t num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		yy_size_t grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return NULL;
-
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = NULL;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b  );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (const char * yystr )
-{
-    
-	return yy_scan_bytes( yystr, (int) strlen(yystr) );
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param yybytes the byte buffer to scan
- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = (yy_size_t) (_yybytes_len + 2);
-	buf = (char *) yyalloc( n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yynoreturn yy_fatal_error (const char* msg )
-{
-			fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-    
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-int yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param _line_number line number
- * 
- */
-void yyset_lineno (int  _line_number )
-{
-    
-    yylineno = _line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param _in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  _in_str )
-{
-        yyin = _in_str ;
-}
-
-void yyset_out (FILE *  _out_str )
-{
-        yyout = _out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  _bdebug )
-{
-        yy_flex_debug = _bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = NULL;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = NULL;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = NULL;
-    yyout = NULL;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer( YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, const char * s2, int n )
-{
-		
-	int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (const char * s )
-{
-	int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size )
-{
-			return malloc(size);
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-		
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return realloc(ptr, size);
-}
-
-void yyfree (void * ptr )
-{
-			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 63 "scanner-regexp.l"
diff --git a/Compiler/scanner-regexp.h b/Compiler/scanner-regexp.h
deleted file mode 100644
index a842c85c9de80d7e6cd2ea3405346ce319b1eeb6..0000000000000000000000000000000000000000
--- a/Compiler/scanner-regexp.h
+++ /dev/null
@@ -1,13 +0,0 @@
-enum kindOfToken {
-	END_OF_INPUT = 0,   // defined by flex system
-	LPAREN,	RPAREN,
-	PLUS,	MINUS,	TIMES,
-	OP_COMPARE,
-	INT_LITERAL, BOOL_LITERAL,
-	IDENTIFIER, LBRACKET,
-	RBRACKET
-};
-
-void scannerError(); /// define in whatever uses the regexp-based scanner
-
-extern int tokenCount;  // not static because the .l file needs it too
diff --git a/Compiler/scanner-regexp.l b/Compiler/scanner-regexp.l
deleted file mode 100644
index d8b2cf39ab643276466099bd5a6bf991a90046a5..0000000000000000000000000000000000000000
--- a/Compiler/scanner-regexp.l
+++ /dev/null
@@ -1,62 +0,0 @@
-%{
-/*
-
-   This is a lexical scanner specification for the "lex" (or "flex") language.
-   It can be translated into a "C++" file by running, in the project directory, the command
-
-    flex  -t scanner-regexp.l > scanner-regexp.cc
-
-
-   In this first section of the lex file (between %{ and %}),
-   we define C++ functions that will be used later in the actions of part 3.
-
-*/
-
-#include "scanner-regexp.h"
-
-// the code generated by the flex system requires we write this:
-extern "C" int yywrap()
-{
- return 1;
-}
-
-%}
-
-/* In this second section of the lex file (after the %}),
-   we can define variables in terms of regular expressions.
-   C-style comments (like this one) are also legal. */
-
-digit		[0-9]
-identifier	[a-zA-Z][a-z0-9_]*\*?
-
-/* In the third section of the lex file (after the %%),
-   we can define the patterns for each token
-   in terms of regular expressions and the variables above,
-   and give the action (as C++ code) for each token.
-   Comments are legal only inside the actions. */
-
-%%
-
-[ \t]		{ continue; }  /* do nothing with blank spaces */
-[\n\r]		{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
-\;.*		{ continue; }  /* treat comments like other blank space */
-
-"("			{ tokenCount++; return LPAREN; }
-")"			{ tokenCount++; return RPAREN; }
-"["			{ tokenCount++; return LBRACKET; }
-"]"			{ tokenCount++; return RBRACKET; }
-"+"			{ tokenCount++; return PLUS; }
-"-"			{ tokenCount++; return MINUS; }
-"*"			{ tokenCount++; return TIMES; }
-"="			{ tokenCount++; return OP_COMPARE; }
-"<="			{ tokenCount++; return OP_COMPARE; }
-">="			{ tokenCount++; return OP_COMPARE; }
-
-"<EOF>"		{ tokenCount++; return END_OF_INPUT; }
-
--?{digit}+	  { tokenCount++; return INT_LITERAL; }
-(#t|#f)	  { tokenCount++; return BOOL_LITERAL; }
-
-{identifier}  { tokenCount++; return IDENTIFIER; }
-
-.			{ scannerError(); continue; }
diff --git a/Compiler/scanner.cc b/Compiler/scanner.cc
deleted file mode 100644
index 796711518cea5c96e29bb49d1421f85c343db5d1..0000000000000000000000000000000000000000
--- a/Compiler/scanner.cc
+++ /dev/null
@@ -1,82 +0,0 @@
-#include <iostream>
-#include <logic.h>
-#include "scanner.h"
-
-#if ! defined USE_YYLEX
-#define USE_YYLEX 1  /* Use the stuff from scanner-regexp.l by default */
-#endif
-
-using namespace std;
-
-int tokenCount = 0;  // not static because the .l file needs it too
-static bool endOfInput = false;
-static bool calledGetNextTokenAlready = false;
-static string current = "";
-static kindOfToken currentKind;
-
-// some things built into scanner-regexp.cc by the flex system:
-extern int yylex();
-extern char *yytext;  // C-style string
-
-
-string currentToken()
-{
-	precondition(calledGetNextTokenAlready);
-	precondition(tokenAvailable());
-	
-	return current;
-}
-enum kindOfToken currentTokenKind()
-{
-	precondition(calledGetNextTokenAlready);
-	precondition(tokenAvailable());
-
-	return currentKind;
-}
-
-bool tokenAvailable()
-{
-	precondition(calledGetNextTokenAlready);
-	
-	return !endOfInput;
-}
-
-int  tokenNumber()
-{
-	return tokenCount;
-}
-
-void getNextToken()
-{
-	if (calledGetNextTokenAlready && endOfInput) return;  // No soup for you!
-	
-	calledGetNextTokenAlready = true;
-#if USE_YYLEX
-	/// This interfaces with scanner-regexp.cc
-	/// remember to update it from scanner-regexp.l if that is changed!
-	currentKind = kindOfToken(yylex()); // yylex thinks it could return any int but we know better
-	if (currentKind == 0) {
-		endOfInput = true;
-		current      = "";
-	} else {
-		current      = yytext;
-	}
-#else
-	/// HERE IS THE OLD CODE, before I tried lex
-	if (endOfInput || !cin) {
-		endOfInput = true;
-	} else {
-		cin >> current;
-		if (cin && current != "<EOF>") {
-			tokenCount++;
-		} else {
-			endOfInput = true;
-		}
-	}
-#endif
-}
-
-void scannerError()
-{
-	cerr << "Error: illegal token: '" << yytext << "'\n";
-}
diff --git a/Compiler/scanner.h b/Compiler/scanner.h
deleted file mode 100644
index e21665ed2bc8d48d33bf8f51de9ca28416f10d2f..0000000000000000000000000000000000000000
--- a/Compiler/scanner.h
+++ /dev/null
@@ -1,27 +0,0 @@
-#ifndef _SCANNER_H_
-#define _SCANNER_H_
-
-#include <string>
-#include "scanner-regexp.h"
-
-// A simple lexical scanner
-
-// return the current token
-//  precondition:     you have called getNextToken at least once
-//                and tokenAvialable did not return false
-std::string currentToken();
-enum kindOfToken currentTokenKind();
-
-// see if there is a token (return false for end-of-input or the special input <EOF>)
-//  precondition: you must have called getNextToken at least once
-bool tokenAvailable();
-
-// return the number of tokens scanned so far
-// precondition: true
-int  tokenNumber();
-
-// advance current token to the next input
-// precondition: true
-void getNextToken();
-
-#endif //_SCANNER_H_
diff --git a/Compiler/scannerDemo.cc b/Compiler/scannerDemo.cc
deleted file mode 100644
index 3d1e728715c64b5dec127d61a9c248eb633134f4..0000000000000000000000000000000000000000
--- a/Compiler/scannerDemo.cc
+++ /dev/null
@@ -1,16 +0,0 @@
-#include <iostream>
-#include "scanner.h"
-#include "scannerDemo.h"
-
-using std::cout;
-using std::endl;
-
-void scannerDemo()
-{
-	while (getNextToken(), tokenAvailable()) {
-		cout << "Token number " << tokenNumber() << " is ";
-		cout << "'" << currentToken() << "'";
-		cout << ", which is token kind " << kindOfToken(currentTokenKind()) << endl;
-	}
-	cout << "Reached end-of-file, now stopping!" << endl;
-}
diff --git a/Compiler/scannerDemo.h b/Compiler/scannerDemo.h
deleted file mode 100644
index 4a62e3c9fe5e640dcc0647b0b1df9bb206b854c0..0000000000000000000000000000000000000000
--- a/Compiler/scannerDemo.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * scanner_demo.h
- *
- *  Created on: Oct 2, 2009
- *      Author: davew
- */
-
-#ifndef SCANNER_DEMO_H_
-#define SCANNER_DEMO_H_
-
-void scannerDemo();
-
-#endif /* SCANNER_DEMO_H_ */
diff --git a/Compiler/streams.h b/Compiler/streams.h
deleted file mode 100644
index 5e892f0f8f893e0f686e901ab29fa3476e27ecd7..0000000000000000000000000000000000000000
--- a/Compiler/streams.h
+++ /dev/null
@@ -1,3 +0,0 @@
-extern std::ostream &trace;
-extern std::ostream &prompt;
-// extern std::ostream &debug;  // could separate these if we had a reason to do so...
diff --git a/Compiler/tests/01-multiply.hrk b/Compiler/tests/01-multiply.hrk
deleted file mode 100644
index 412d02f309785591aa1d609c1108398fed75433c..0000000000000000000000000000000000000000
--- a/Compiler/tests/01-multiply.hrk
+++ /dev/null
@@ -1 +0,0 @@
-(* 6 7)
diff --git a/Compiler/tests/02-add-and-mult.hrk b/Compiler/tests/02-add-and-mult.hrk
deleted file mode 100644
index b0740fa6d3c99839d0bd3a14890c5dd1b12090d4..0000000000000000000000000000000000000000
--- a/Compiler/tests/02-add-and-mult.hrk
+++ /dev/null
@@ -1 +0,0 @@
-(* (+ 2 5) (+ (+ 1 (* 2 1)) (+ 2 1)))
diff --git a/Compiler/tests/03-mult-input.hrk b/Compiler/tests/03-mult-input.hrk
deleted file mode 100644
index d0527aaf109e751f7956fea14effb790fbbe252b..0000000000000000000000000000000000000000
--- a/Compiler/tests/03-mult-input.hrk
+++ /dev/null
@@ -1 +0,0 @@
-(* 3 (getint))
diff --git a/Compiler/tests/04-mult-exit.hrk b/Compiler/tests/04-mult-exit.hrk
deleted file mode 100644
index 19f08ddfbf4dce603c3456d5a5c3ff422cf27723..0000000000000000000000000000000000000000
--- a/Compiler/tests/04-mult-exit.hrk
+++ /dev/null
@@ -1 +0,0 @@
-(* 3 (exit))
diff --git a/Compiler/tests/arithmetic or comparison operation type error.txt b/Compiler/tests/arithmetic or comparison operation type error.txt
deleted file mode 100644
index 74171143e261de0bc3b254b650af40c193bedf3e..0000000000000000000000000000000000000000
--- a/Compiler/tests/arithmetic or comparison operation type error.txt	
+++ /dev/null
@@ -1 +0,0 @@
-( <= 4 #f ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/comparison.txt b/Compiler/tests/comparison.txt
deleted file mode 100644
index 8bdf47dbd9ea3f0bc1319e04feb58aee6c3ce058..0000000000000000000000000000000000000000
--- a/Compiler/tests/comparison.txt
+++ /dev/null
@@ -1 +0,0 @@
-( <= 4 5 ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if type error.txt b/Compiler/tests/if type error.txt
deleted file mode 100644
index 60dca31173babb20287ac03e8cda9f9669101989..0000000000000000000000000000000000000000
--- a/Compiler/tests/if type error.txt	
+++ /dev/null
@@ -1 +0,0 @@
-(if #t 3 h) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if.txt b/Compiler/tests/if.txt
deleted file mode 100644
index 0fbbcb19e4e2929c3eaa6d30d03260f63901f1bb..0000000000000000000000000000000000000000
--- a/Compiler/tests/if.txt
+++ /dev/null
@@ -1 +0,0 @@
-(if #t (if #f 2 3) (if #t 4 5)) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/let.txt b/Compiler/tests/let.txt
deleted file mode 100644
index 3fe340a7484f889f26288b6a1175d4a6373d5e93..0000000000000000000000000000000000000000
--- a/Compiler/tests/let.txt
+++ /dev/null
@@ -1 +0,0 @@
-(+ (letstar ( [x 1] [y 2] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/letstar.txt b/Compiler/tests/letstar.txt
deleted file mode 100644
index 366eb923d0f93ca9fdb2006108e0a168112eb779..0000000000000000000000000000000000000000
--- a/Compiler/tests/letstar.txt
+++ /dev/null
@@ -1 +0,0 @@
-(+ (letstar ( [x 3] [y x] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested let.txt b/Compiler/tests/nested let.txt
deleted file mode 100644
index 17e52566013a6c055a7c8ad9fbb3ae9b235f7ece..0000000000000000000000000000000000000000
--- a/Compiler/tests/nested let.txt	
+++ /dev/null
@@ -1 +0,0 @@
-(+ (letstar ( [x 1] [y 2] ) (+ x (letstar ( [z 3] [y 4] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested letstar.txt b/Compiler/tests/nested letstar.txt
deleted file mode 100644
index 8808cc7ddf8d4f32094aa7e973959b70d9441474..0000000000000000000000000000000000000000
--- a/Compiler/tests/nested letstar.txt	
+++ /dev/null
@@ -1 +0,0 @@
-(+ (letstar ( [x 4] [y 2] ) (+ x (letstar ( [z y] [y x] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file

From a5abba971a9f87f049847b92160a072b497679c8 Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 15:14:19 +0300
Subject: [PATCH] compiler submodule

---
 Compiler | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Compiler b/Compiler
new file mode 160000
index 0000000000000000000000000000000000000000..a0339f4fd01790127bc51fc1da091d5742115811
--- /dev/null
+++ b/Compiler
@@ -0,0 +1 @@
+Subproject commit a0339f4fd01790127bc51fc1da091d5742115811

From 46d5e2da641146d67e26ba7d690acbf9f9aba7c2 Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 15:21:34 +0300
Subject: [PATCH] rm Compiler

---
 Compiler | 1 -
 1 file changed, 1 deletion(-)

diff --git a/Compiler b/Compiler
deleted file mode 160000
index a0339f4fd01790127bc51fc1da091d5742115811..0000000000000000000000000000000000000000
--- a/Compiler
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit a0339f4fd01790127bc51fc1da091d5742115811

From 25f090232880f4d96c51e49c79c59e467b875f79 Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 15:24:35 +0300
Subject: [PATCH] getint, exit corner case

---
 Compiler | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Compiler b/Compiler
new file mode 160000
index 0000000000000000000000000000000000000000..a0339f4fd01790127bc51fc1da091d5742115811
--- /dev/null
+++ b/Compiler
@@ -0,0 +1 @@
+Subproject commit a0339f4fd01790127bc51fc1da091d5742115811

From b6c429c4b3282a6eab072f1749ea0c908451cfdd Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 15:29:17 +0300
Subject: [PATCH] rm submodule

---
 Compiler | 1 -
 1 file changed, 1 deletion(-)

diff --git a/Compiler b/Compiler
deleted file mode 160000
index a0339f4fd01790127bc51fc1da091d5742115811..0000000000000000000000000000000000000000
--- a/Compiler
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit a0339f4fd01790127bc51fc1da091d5742115811

From 5845beb3a3ed5d3373b4af96f5f2832d526e0e6a Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 15:30:13 +0300
Subject: [PATCH] getint, exit corner case

---
 Compiler/.cproject                                 |   72 +
 Compiler/.gitignore                                |    8 +
 Compiler/.project                                  |   82 +
 Compiler/AST.cc                                    |  242 +++
 Compiler/AST.h                                     |  245 +++
 Compiler/CMakeLists.txt                            |   18 +
 Compiler/ContextInfo.cc                            |   46 +
 Compiler/ContextInfo.h                             |   22 +
 Compiler/Dictionary.cpp                            |  124 ++
 Compiler/Dictionary.h                              |  101 ++
 Compiler/README-Collaboration.txt                  |    1 +
 Compiler/README-Design.txt                         |   16 +
 Compiler/README_Sources.txt                        |    1 +
 Compiler/generateHERA.cc                           |  238 +++
 Compiler/main.cc                                   |  132 ++
 Compiler/parser.cc                                 |  241 +++
 Compiler/parser.h                                  |   18 +
 Compiler/scanner-regexp.cc                         | 1871 ++++++++++++++++++++
 Compiler/scanner-regexp.h                          |   13 +
 Compiler/scanner-regexp.l                          |   62 +
 Compiler/scanner.cc                                |   82 +
 Compiler/scanner.h                                 |   27 +
 Compiler/scannerDemo.cc                            |   16 +
 Compiler/scannerDemo.h                             |   13 +
 Compiler/streams.h                                 |    3 +
 Compiler/tests/01-multiply.hrk                     |    1 +
 Compiler/tests/02-add-and-mult.hrk                 |    1 +
 Compiler/tests/03-mult-input.hrk                   |    1 +
 Compiler/tests/04-mult-exit.hrk                    |    1 +
 ...ithmetic or comparison operation type error.txt |    1 +
 Compiler/tests/comparison.txt                      |    1 +
 Compiler/tests/if type error.txt                   |    1 +
 Compiler/tests/if.txt                              |    1 +
 Compiler/tests/let.txt                             |    1 +
 Compiler/tests/letstar.txt                         |    1 +
 Compiler/tests/nested let.txt                      |    1 +
 Compiler/tests/nested letstar.txt                  |    1 +
 37 files changed, 3706 insertions(+)

diff --git a/Compiler/.cproject b/Compiler/.cproject
new file mode 100644
index 0000000000000000000000000000000000000000..909e19a7e90ca0f6e31541b0d3f726a9ead5b304
--- /dev/null
+++ b/Compiler/.cproject
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="cdt.managedbuild.config.gnu.exe.debug.1161916250">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" moduleId="org.eclipse.cdt.core.settings" name="Debug">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.MakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactExtension="" artifactName="Compiler-C++" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" errorParsers="org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.GASErrorParser" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" name="Debug" parent="cdt.managedbuild.config.gnu.exe.debug">
+					<folderInfo id="cdt.managedbuild.config.gnu.exe.debug.1161916250.1127859407" name="/" resourcePath="">
+						<toolChain id="cdt.managedbuild.toolchain.gnu.exe.debug.1737210637" name="GCC Tool Chain" superClass="cdt.managedbuild.toolchain.gnu.exe.debug">
+							<targetPlatform id="cdt.managedbuild.target.gnu.platform.exe.debug.1043903385" name="Debug Platform" superClass="cdt.managedbuild.target.gnu.platform.exe.debug"/>
+							<builder buildPath="${workspace_loc:/Interpreter-C++/Debug}" id="cdt.managedbuild.target.gnu.builder.exe.debug.1885040107" keepEnvironmentInBuildfile="false" name="Gnu Make Builder" superClass="cdt.managedbuild.target.gnu.builder.exe.debug"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug.1315278191" name="GCC C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug">
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.compiler.option.include.paths.668525549" name="Include paths (-I)" superClass="gnu.cpp.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
+									<listOptionValue builtIn="false" value="/home/courses/include"/>
+								</option>
+								<option id="gnu.cpp.compiler.exe.debug.option.optimization.level.793100283" name="Optimization Level" superClass="gnu.cpp.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.optimization.level.none" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.exe.debug.option.debugging.level.1408142720" name="Debug Level" superClass="gnu.cpp.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.debugging.level.max" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.option.dialect.std.1577870906" name="Language standard" superClass="gnu.cpp.compiler.option.dialect.std" useByScannerDiscovery="true" value="gnu.cpp.compiler.dialect.c++1y" valueType="enumerated"/>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.compiler.input.842239186" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.c.compiler.exe.debug.351478677" name="GCC C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.exe.debug">
+								<option defaultValue="gnu.c.optimization.level.none" id="gnu.c.compiler.exe.debug.option.optimization.level.1879412635" name="Optimization Level" superClass="gnu.c.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" valueType="enumerated"/>
+								<option id="gnu.c.compiler.exe.debug.option.debugging.level.648859551" name="Debug Level" superClass="gnu.c.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.c.debugging.level.max" valueType="enumerated"/>
+								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.219263748" superClass="cdt.managedbuild.tool.gnu.c.compiler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.c.linker.exe.debug.370219233" name="GCC C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.exe.debug"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug.1321052876" name="GCC C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug">
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.libs.311614395" name="Libraries (-l)" superClass="gnu.cpp.link.option.libs" useByScannerDiscovery="false" valueType="libs">
+									<listOptionValue builtIn="false" value="courses"/>
+								</option>
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.paths.603027165" name="Library search path (-L)" superClass="gnu.cpp.link.option.paths" useByScannerDiscovery="false" valueType="stringList">
+									<listOptionValue builtIn="false" value="/home/courses/lib"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.linker.input.2141151307" superClass="cdt.managedbuild.tool.gnu.cpp.linker.input">
+									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
+									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
+								</inputType>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.assembler.exe.debug.1455701237" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.exe.debug">
+								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.1492382276" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.archiver.base.1329154531" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.base"/>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="Interpreter-C++.cdt.managedbuild.target.gnu.exe.1148232902" name="Executable (Gnu)" projectType="cdt.managedbuild.target.gnu.exe"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration"/>
+	<storageModule moduleId="refreshScope" versionNumber="2">
+		<configuration configurationName="Debug">
+			<resource resourceType="PROJECT" workspacePath="/Compiler-C++"/>
+		</configuration>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+	<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
+</cproject>
diff --git a/Compiler/.gitignore b/Compiler/.gitignore
new file mode 100644
index 0000000000000000000000000000000000000000..3f41ab15da41e4fbd4b9d23106bccda660f6c1bb
--- /dev/null
+++ b/Compiler/.gitignore
@@ -0,0 +1,8 @@
+*~
+#*#
+cmake-build-debug
+Debug
+.settings
+.idea
+.DS_Store
+Compiler.out
diff --git a/Compiler/.project b/Compiler/.project
new file mode 100644
index 0000000000000000000000000000000000000000..fcf25eff71b070352f4ba0ab857e8c9b49fca63a
--- /dev/null
+++ b/Compiler/.project
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Compiler-C++</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>make</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<value>${workspace_loc:/Tree-C++/Debug}</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/Compiler/AST.cc b/Compiler/AST.cc
new file mode 100644
index 0000000000000000000000000000000000000000..fd946ffe54ebdaf973c285682036f46ed6f5dbfe
--- /dev/null
+++ b/Compiler/AST.cc
@@ -0,0 +1,242 @@
+#include <hc_list.h>
+#include <hc_list_helpers.h>
+#include "parser.h"  // for n_errors count; this should really be refactored
+#include "streams.h"
+
+using std::string;
+using std::endl;
+using HaverfordCS::list;
+
+
+#include <fstream>  /* needed for ofstream below */
+#if defined TRACE_EXPR_ALLOCATIONS
+static std::ofstream  alloc_trace(TRACE_EXPR_ALLOCATIONS);
+#else
+// by default, allow option for control via environment variable, but it's not given, send to /dev/null (disappears)
+static std::ofstream alloc_trace(getenv("HAVERRACKET_ALLOC_TRACE")?getenv("HAVERRACKET_ALLOC_TRACE"):"/dev/null");
+// static std::ofstream &alloc_trace = trace;  // alternate easy option, just send to regular trace
+#endif
+
+
+
+// This file has the constructors and destructors;
+//   all the generateHERA methods are together in generateHERA.cc
+
+
+// C++ Usage Note:
+// The v(value) is like having v=value, but initializes v rather than assigning to it
+// i.e., writing "v = value" in the constructor _body_ is like writing
+// i.e., writing "v = value" in the constructor _body_ is like writing
+//     int i;
+//     i = 12;
+// whereas writing v(value) before the body is like writing
+//     int i=12;  // i is created with "12" from the start
+//
+// Those steps, as the call(s) to any superclass(es)' constructors, are done before the body of the IntLiteralNode itself
+IntLiteralNode::IntLiteralNode(int value) : v(value)
+{
+	// nothing else needs to be done here, since the stuff above defines "v" as "value"
+	alloc_trace << "(class IntLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
+}
+
+BoolLiteralNode::BoolLiteralNode(string value) : v((value == "#t")? 1 : 0)
+{
+    // nothing else needs to be done here, since the stuff above defines "v" as "value"
+    alloc_trace << "(class BoolLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
+}
+
+// (so, we should see this trace before the one above, for each int literal node)
+ExprNode::ExprNode()
+{
+	alloc_trace << "[superclass ExprNode constructor  called for node at memory " << this << endl;
+}
+
+ComparisonNode::ComparisonNode(string op, ExprNode *lhs, ExprNode *rhs) :
+	o(op),
+	left(lhs),
+	right(rhs)
+{
+	alloc_trace << "(class ComparisonNode constructor called for node at memory " << this << endl;
+}
+
+ArithmeticNode::ArithmeticNode(string op, list<ExprNode *>operands) :
+	o(op),
+	subexps(operands)
+{
+	alloc_trace << "(class ArithmeticNode constructor called for node at memory " << this << endl;
+}
+
+
+VarUseNode::VarUseNode(string name) : n(name)
+{
+	alloc_trace << "(class     VarUseNode constructor called for node at memory " << this << endl;
+}
+
+CallNode::CallNode(string funcName, HaverfordCS::list<ExprNode *>arguments) :
+	n(funcName),
+	argList(arguments)
+{
+	alloc_trace << "(class       CallNode constructor called for node at memory " << this << endl;
+}
+
+IfNode::IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse) :
+    condition(condition),
+    expriftrue(expriftrue),
+    expriffalse(expriffalse)
+{
+    alloc_trace << "(class IfNode constructor called for node at memory " << this << endl;
+}
+
+LetNode::LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions) :
+        declarations(declarations),
+        expressions(expressions)
+{
+    alloc_trace << "(class LetNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationsNode::DeclarationsNode(HaverfordCS::list<ExprNode *> declarations) :
+        declarations(declarations)
+{
+    alloc_trace << "(class DeclarationsNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType) :
+        variable(variable),
+        intLiteral(intLiteral),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType) :
+        variable(variable),
+        boolLiteral(boolLiteral),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType) :
+        variable(variable),
+        definedVar(definedVar),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, ExprNode *expr, string declType) :
+        variable(variable),
+        expr(expr),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+// C++ Usage notes:
+//   When an object is destroyed, either because it is on the stack, e.g. as a variable,
+//     or because it is on the free-store heap, the _destructor(s)_ for the object,
+//     including those for the superclass(es) and data fields, are called before
+//     the memory for the object is released for potential re-use
+//     (destructors are called for those fields as they are released,
+//     and the superclass destructor is used after the class' own destructor is done).
+//
+//   Note that _pointers_ do not have destructor methods, so while e.g. when a "+" node
+//     goes away, the "string o" data field in the ArithmeticNode will automatically run,
+//     but nothing happens (by default) for the trees _pointed_to_ by "subexps".
+//     (ArithmeticNode's destructor also runs, of course, and so _it_ may take care of subexps)
+
+ExprNode::~ExprNode()  // nothing to do, but this ensures all subclasses will have virtual destructors, which C++ likes
+{
+	alloc_trace << " superclass ExprNode destructor   called for node at memory " << this << "]" << endl;
+}
+
+IntLiteralNode::~IntLiteralNode()
+{
+	alloc_trace << " class IntLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
+	// nothing needs to be done here,
+	//  except for tracing we could have omitted this.
+}
+
+BoolLiteralNode::~BoolLiteralNode()
+{
+    alloc_trace << " class BoolLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
+    // nothing needs to be done here,
+    //  except for tracing we could have omitted this.
+}
+
+#if FREE_AST_VIA_DESTRUCTORS
+
+// Memory management strategy:
+//   In a _Tree_, we know that any node will have at most one parent.
+//   Since the parser returns a pointer to the _root_,
+//     and no methods give access to any node's child pointers,
+//     we know that, when the root goes away, all the sub-trees can go away too.
+//   So, when the main program "delete"s the root,
+//     that will trigger the root's destructor; if that delete's any tree children,
+//     the whole thing will then be destroyed recursively.
+
+// Note that no destructor is needed for "IntLiteralNode".
+//   It has no subtrees, and data fields go away automatically when the node is deleted
+
+// In contrast, a ComparisonNode has subtree pointers "left" and "right".
+//   When we delete a ComparisonNode, those _pointers_ go away,
+//   but the trees on the free-store heap will last until we delete them.
+//   Since, as noted, we know there are no other pointers to them,
+//   we delete them when the ComparisonNode goes away:
+
+ComparisonNode::~ComparisonNode()
+{
+	alloc_trace << " class ComparisonNode  destructor called for node at memory " << this << ")" << endl;
+
+	delete left;
+	delete right;
+}
+
+void deleteAllSubtrees(list<ExprNode *>subtrees)
+{
+	if (!empty(subtrees)) {
+		delete head(subtrees);
+		deleteAllSubtrees(rest(subtrees));
+	}
+}
+
+ArithmeticNode::~ArithmeticNode()
+{
+	alloc_trace << " class ArithmeticNode  destructor called for node at memory " << this << ")" << endl;
+	
+	deleteAllSubtrees(subexps);
+}
+
+VarUseNode::~VarUseNode()
+{
+	alloc_trace << " class     VarUseNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+CallNode::~CallNode()
+{
+	alloc_trace << " class       CallNode  destructor called for node at memory " << this << ")" << endl;
+	
+	deleteAllSubtrees(argList);
+}
+
+IfNode::~IfNode()
+{
+    alloc_trace << " class     IfNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+LetNode::~LetNode()
+{
+    alloc_trace << " class     LetNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+DeclarationsNode::~DeclarationsNode()
+{
+    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+DeclarationNode::~DeclarationNode()
+{
+    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+#endif
diff --git a/Compiler/AST.h b/Compiler/AST.h
new file mode 100644
index 0000000000000000000000000000000000000000..c141d1ca1d54fa3a77ac7a8c4d0441da3b78cdc8
--- /dev/null
+++ b/Compiler/AST.h
@@ -0,0 +1,245 @@
+#ifndef AST_H_
+#define AST_H_
+
+#include <string>
+#include <hc_list.h>
+#include "ContextInfo.h"
+#include "Dictionary.h"
+
+
+/*
+ *  This file defines the heirarchy of different kinds of AST nodes.
+ *  Currently we have:
+ *    ExprNode (an "interface" class for expressions, with the following concrete subclasses ("implementers" of the interface):
+ *	IntLiteralNode(int value)
+ *	ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs)
+ *	ArithmeticNode(std::string op, list<ExprNode *>)
+ *	VarUseNode(std::string name)
+ *	CallNode(std::string name, HaverfordCS::list<ExprNode *>arguments)
+ *
+ *  The "generateHERA" methods are usually called by calling generateFullHERA on the root,
+ *      which puts "CBON" at the start.
+ */
+
+#if ! defined FREE_AST_VIA_DESTRUCTORS
+#define FREE_AST_VIA_DESTRUCTORS true
+#endif
+
+// C++ Usage Note:
+// The empty class definition of ContextInfo below lets us declare "const ContextInfo &" parameters
+//   without having to define the whole class here, which is fine because, at this point,
+//   we don't care much about what's in it ... we just need to know that there's some way
+//   to pass information down to the subtrees as we evaluate them.
+
+
+// Define the information will we need to pass down the tree as we generate code, see ContextInfo.h
+class ContextInfo;
+
+extern Dictionary declarationDict;
+
+// C++ Usage Note:
+//
+// The word "virtual" is needed in C++ when inheritance is use,
+//   to explicitly tell the compiler that we might override a function in a subclass
+// Java has the correct default of allowing this, and the keyword "final" prevents it.
+//   Many C++ compilers fail to complain if you forget the word "virtual" and override a method anyway :-(
+//
+// Putting "= 0" at the end of a virtual function declaration means
+//   that the method _must_ be overridden in subclasses
+//
+// Classes with virtual functions and (in subclasses) data with destructors need to have
+//  virtual destructors, to help the C++ compiler be sure the right data destructors are called
+
+
+// Class ExprNode is an interface that defines the methods that all
+//   expression nodes in our AST will provide
+// C++ does not have Java's "interface" keyword, so instead
+//   we just create a superclass with no data and all functions virtual
+
+class ExprNode {
+public:
+	ExprNode();           // just used for memory allocation labs, to print trace information
+	virtual ~ExprNode();  // used for actual memory allocation, sometimes, and for tracing
+
+    virtual std::string generateHERA(const ContextInfo &info) const = 0;
+    virtual std::string getType() const = 0;
+
+    ExprNode* operator==(ExprNode *other) {
+        this->type = other->type;
+        return this;
+    }
+private:
+    std::string type;
+};
+
+std::string generateFullHERA(ExprNode *presumedRoot);
+
+
+
+// Now, the various specific kinds of expressions we might have:
+
+class IntLiteralNode : public ExprNode {
+	public:
+		IntLiteralNode(int value);
+		~IntLiteralNode();  // just used for trace output
+
+        int getValue() const { return v; }
+        std::string getType() const { return type; }
+
+		std::string generateHERA(const ContextInfo &info) const;
+	private:
+		int v;  // the value
+        const std::string type = "IntLiteralNode";
+};
+
+class BoolLiteralNode : public ExprNode {
+public:
+    BoolLiteralNode(std::string value);
+    ~BoolLiteralNode();  // just used for trace output
+
+    int getValue() const { return v; }
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    int v;  // the value
+    const std::string type = "BoolLiteralNode";
+};
+
+class ComparisonNode : public ExprNode {  // <= etc., _inherently_binary_ in HaverRacket
+public:
+    ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~ComparisonNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    std::string o;
+    ExprNode *left;
+    ExprNode *right;
+    const std::string type = "ComparisonNode";
+};
+
+class ArithmeticNode : public ExprNode {  // +, *, -, etc.
+	public:
+		ArithmeticNode(std::string op, HaverfordCS::list<ExprNode *>);
+#if FREE_AST_VIA_DESTRUCTORS
+		~ArithmeticNode();
+#endif
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string o;
+		HaverfordCS::list<ExprNode *>subexps;
+        const std::string type = "ArithmeticNode";
+};
+
+/*
+   This represents the use of an identifier as an expression, e.g. the x in (* x 6).
+   Note that identifiers also exist in variable declarations, e.g. (let ((x 7)) ... )
+     but the x there doesn't count as an _expression_ since we're not asking for its value.
+ */
+class VarUseNode : public ExprNode {
+	public:
+		VarUseNode(std::string name);
+		~VarUseNode();
+
+        std::string getValue() const { return n; }
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string n;
+        const std::string type = "VarUseNode";
+};
+
+
+class CallNode : public ExprNode {
+	public:
+		CallNode(std::string funcName, HaverfordCS::list<ExprNode *>arguments);
+#if FREE_AST_VIA_DESTRUCTORS
+		~CallNode();
+#endif
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string n;  // the name
+		HaverfordCS::list<ExprNode *>argList;
+        const std::string type = "CallNode";
+};
+
+class IfNode : public ExprNode {
+public:
+    IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~IfNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    ExprNode *condition;
+    ExprNode *expriftrue;
+    ExprNode *expriffalse;
+    const std::string type = "IfNode";
+};
+
+class DeclarationsNode : public ExprNode {
+public:
+    DeclarationsNode(HaverfordCS::list<ExprNode *> declarations);
+    HaverfordCS::list<ExprNode *> getDeclarations();
+    std::string declarationsHelper(std::string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const;
+#if FREE_AST_VIA_DESTRUCTORS
+    ~DeclarationsNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    HaverfordCS::list<ExprNode *> declarations;
+    const std::string type = "DeclarationsNode";
+};
+
+class DeclarationNode : public ExprNode {
+public:
+    DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType);
+    DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType);
+    DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType);
+    DeclarationNode(VarUseNode variable, ExprNode *expr, string declType);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~DeclarationNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    VarUseNode variable;
+    VarUseNode definedVar = VarUseNode("defaultVar");
+    std::string declType;
+    IntLiteralNode intLiteral = IntLiteralNode(0);
+    BoolLiteralNode boolLiteral = BoolLiteralNode("#f");
+    ExprNode *expr = new IntLiteralNode(0);
+    const std::string type = "DeclarationNode";
+};
+
+class LetNode : public ExprNode {
+public:
+    LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~LetNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+    std::string expressionsHelper(std::string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const;
+    private:
+    ExprNode *declarations;
+    HaverfordCS::list<ExprNode *> expressions;
+    const std::string type = "LetNode";
+};
+
+#endif /*AST_H_*/
diff --git a/Compiler/CMakeLists.txt b/Compiler/CMakeLists.txt
new file mode 100755
index 0000000000000000000000000000000000000000..062dc130adcaafeef166e748f727927ef412fda0
--- /dev/null
+++ b/Compiler/CMakeLists.txt
@@ -0,0 +1,18 @@
+cmake_minimum_required(VERSION 3.1)
+project(Compiler_C++)
+
+set(CMAKE_CXX_STANDARD 20)
+
+add_executable(Compiler_C++
+  scanner-regexp
+  scanner
+  scannerDemo
+  parser
+  AST
+  ContextInfo
+  generateHERA
+  main
+  Dictionary
+)
+
+include_directories(../HaverfordCS/include /home/courses/include)
diff --git a/Compiler/ContextInfo.cc b/Compiler/ContextInfo.cc
new file mode 100644
index 0000000000000000000000000000000000000000..30bffca0697ed8a4f056bf899bbafcae2864f5dc
--- /dev/null
+++ b/Compiler/ContextInfo.cc
@@ -0,0 +1,46 @@
+#include "ContextInfo.h"
+#include <string.h>
+
+// To provide unique register numbers for each subexpression, with leftmost-executed-first
+//   we'll start with 1 at the root, make the rightmost child's number same as its parent,
+//   and make each other child one more than the sibling to its right.
+
+static const int minRegNum= 1;  // Lowest  register number we're going to use
+static const int maxRegNum=10;  // Highest register number we're going to use
+static const char labeler[] = "abcdefghijklmnopqrstuvwxyz";
+std::string label;
+
+ContextInfo::ContextInfo():
+	myRegNumber(maxRegNum)
+{
+}
+
+// Private constructor for use in e.g. evalThisFirst
+ContextInfo::ContextInfo(int r):
+	myRegNumber(r)
+{
+}
+
+ContextInfo ContextInfo::evalThisAfter() const
+{
+	if (myRegNumber <= minRegNum) {
+		throw "Out of register numbers, expression to complicated";
+	}
+	return ContextInfo(this->myRegNumber-1);
+}
+
+std::string ContextInfo::getReg() const
+{
+	return "R"+std::to_string(myRegNumber);
+}
+
+std::string ContextInfo::labelfunc() const
+{
+    std::string label = "";
+    return label + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26];
+}
+
+std::string ContextInfo::getLabel() const
+{
+    return label;
+}
diff --git a/Compiler/ContextInfo.h b/Compiler/ContextInfo.h
new file mode 100644
index 0000000000000000000000000000000000000000..7b17f253d940e1e9f8b451530aaf436d4b77c927
--- /dev/null
+++ b/Compiler/ContextInfo.h
@@ -0,0 +1,22 @@
+#include <string>
+#ifndef CONTEXT_INFO
+#define CONTEXT_INFO
+class ContextInfo {
+public:
+	ContextInfo(); // create an empty one, appropriate for the TOP of a parse tree
+
+	ContextInfo evalThisAfter() const; // create another context for something to be evaluated later
+
+	std::string getReg() const;
+	std::string labelfunc() const;
+    std::string getLabel() const;
+private:
+	// "myRegNumber" will tell each expression what register number they should use for their result
+	//  should generally be different for the subexpressions of a node,
+	//  and if X is evalualuated before Y, it should have a higher number.
+
+	ContextInfo(int myRegNum);  // called by e.g. evalThisFirst, to build new contexts
+	int myRegNumber;
+	std::string label = labelfunc();
+};
+#endif //CONTEXT_INFO
\ No newline at end of file
diff --git a/Compiler/Dictionary.cpp b/Compiler/Dictionary.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..6c3416da026a2490ddf986e501ec7c15fee7f317
--- /dev/null
+++ b/Compiler/Dictionary.cpp
@@ -0,0 +1,124 @@
+//
+// Created by Keith_Mburu on 3/15/2021.
+//
+
+#include "Dictionary.h"
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that recurses through dictionary checking for entry
+ *
+ * @return true or false
+ */
+bool Dictionary::containsHelper (const list<pair<string,int>> &dList, const string &entry) {
+    if (empty(dList)) {
+        return false;
+    }
+    else {
+        if ((get<0>(head(dList)) == entry)) {
+            return true;
+        }
+        return containsHelper(rest(dList), entry);
+    }
+}
+
+/**
+ * method that checks if entry is in dictionary
+ *
+ * @return true or false
+ */
+bool Dictionary::contains (const string &entry) {
+    return containsHelper(getList(), entry);
+}
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that recurses through dictionary until it finds and returns integer assigned to entry
+ *
+ * @param entry string being looked up
+ * @param dList dictionary data field
+ * @return the integer
+ */
+int Dictionary::lookupHelper (const list<pair<string,int>> &dList, const string &entry) {
+    if (empty(dList)) {
+        return -1;
+    }
+    else if ((get<0>(head(dList)) == entry)) {
+        return get<1>(head(dList));
+    }
+    return lookupHelper(rest(dList), entry);
+}
+
+/**
+ * method that checks the integer assigned to entry of dictionary
+ *
+ * @param entry string being looked up
+ * @return the integer
+ */
+int Dictionary::lookup (const string &entry) {
+    return lookupHelper(getList(), entry);
+}
+
+/**
+ * method that converts dictionary to the string that constructs it
+ *
+ * @return the string
+ */
+string Dictionary::toCode () {
+    if (empty(dictList)) {
+        return "Dictionary()\n";
+    }
+    list<pair<string, int>> temp = dictList;
+    string dictCode = "Dictionary()";
+    for (int i = 0; i < length(dictList); i++) {
+        // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
+        dictCode = "Dictionary(" + dictCode + ", \"" + get<0>(first(temp)) + "\", " + to_string(get<1>(first(temp))) +
+                ")";
+        temp = rest(temp);
+    }
+    return dictCode;
+}
+
+/**
+ * method that adds new entry to dictionary by constructing new data field
+ *
+ * @param entry string to be added
+ * @param integer integer assigned to the string
+ */
+void Dictionary::add (string entry, int integer) {
+    list<pair<string, int>> newList = list<pair<string, int>>(pair<string, int>(entry, integer), dictList);
+    dictList = newList;
+}
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that builds new dictionary data field with redefined entry
+ *
+ * @return true if successful
+ */
+bool Dictionary::replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int
+integer) {
+    if (empty(dList)) {
+        // finished recursion, now replace dictionary data field
+        setList(newList);
+        return true;
+    }
+    if ((get<0>(head(dList)) == entry)) {
+        newList = list<pair<string, int>>(pair<string, int>(get<0>(head(dList)), integer), newList);
+        // continue recursing to build the rest of the dictionary
+        return replaceHelper(newList, rest(dList), entry, integer);
+    }
+    newList = list<pair<string, int>>(head(dList), newList);
+    return replaceHelper(newList, rest(dList), entry, integer);
+}
+
+/**
+ * method that replaces the integer assigned to an entry of a dictionary
+ *
+ * @return true if the replacement was successful
+ */
+bool Dictionary::replace (const string &entry, int integer) {
+    replaceHelper(list<pair<string, int>>(), getList(), entry, integer);
+}
+
+
diff --git a/Compiler/Dictionary.h b/Compiler/Dictionary.h
new file mode 100644
index 0000000000000000000000000000000000000000..3696da9d645c34ecf1fbc5f519c9a829818955ce
--- /dev/null
+++ b/Compiler/Dictionary.h
@@ -0,0 +1,101 @@
+//
+// Created by Keith_Mburu on 3/15/2021.
+//
+
+#ifndef DICTIONARY_H
+#define DICTIONARY_H
+
+#include <hc_list.h>
+#include <hc_list_helpers.h>
+#include <utility>
+
+using namespace HaverfordCS;
+using namespace std;
+
+/**
+ * class that instantiates dictionary with string : integer entries
+ *
+ * @author Keith Mburu
+ * @version 3/24/2021
+ */
+class Dictionary {
+
+public:
+
+    /**
+     * constructor method for empty dictionary
+     */
+    Dictionary() {
+        dictList = list<std::pair<string,int>>();
+    }
+
+    /**
+     * constructor method for new dictionary with old dictionary plus new entry
+     *
+     * @param oldDict old dictionary
+     * @param entry string to be added to old dictionary
+     * @param integer integer to be assigned to new entry
+     */
+    Dictionary(const Dictionary &oldDict, const string &entry, const int &integer) {
+        dictList = list<pair<string,int>>(pair<string,int>(entry, integer), oldDict.dictList);
+    }
+
+    /**
+     * getter method for list that stores dictionary data
+     *
+     * @return list that stores dictionary data
+     */
+    list<pair<string,int>> getList() {
+        return dictList;
+    }
+
+    /**
+     * setter method for list that stores dictionary data
+     *
+     * @param newList list to replace dictionary list
+     */
+    void setList(list<pair<string, int>> newList) {
+        dictList = newList;
+    }
+
+    // learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+    // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
+    /**
+     * method that accumulates dictionary entries in string
+     *
+     * @return string containing dictionary entries
+     */
+    string toStringHelper(const list<pair<string,int>> &dictList, string dictString) {
+        if (empty(rest(dictList))) {
+            return dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList)));
+        }
+        dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList))) + "\n";
+        return toStringHelper(rest(dictList), dictString);
+    }
+
+    /**
+     * method that represents dictionary as a string
+     *
+     * @return string containing dictionary entries
+     */
+    string toString() {
+        return toStringHelper(getList(), "");
+    }
+
+    // other methods defined in Dictionary.cpp
+    int lookup (const string &entry);
+    int lookupHelper (const list<pair<string,int>> &dList, const string &entry);
+    bool contains (const string &entry);
+    bool containsHelper (const list<pair<string,int>> &dList, const string &entry);
+    void add (string entry, int integer);
+    bool replace (const string &entry, int integer);
+    bool replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int integer);
+    string toCode ();
+
+private:
+
+    list<pair<string,int>> dictList; // list that stores dictionary data
+
+};
+
+#endif
\ No newline at end of file
diff --git a/Compiler/README-Collaboration.txt b/Compiler/README-Collaboration.txt
new file mode 100644
index 0000000000000000000000000000000000000000..a4d117a958e7f176f9f498aed0dfc60aee767f99
--- /dev/null
+++ b/Compiler/README-Collaboration.txt
@@ -0,0 +1 @@
+Working alone
\ No newline at end of file
diff --git a/Compiler/README-Design.txt b/Compiler/README-Design.txt
new file mode 100644
index 0000000000000000000000000000000000000000..4545104538e0f6df575cb443d81afeccdbcf6821
--- /dev/null
+++ b/Compiler/README-Design.txt
@@ -0,0 +1,16 @@
+PLEASE DO NOT EDIT THIS PRELIMINARY VERISON OF THE FILE, TO AVOID GIT CONFLICTS LATER
+ (if you're working before the update version is available, make a copy and edit that)
+
+Important Design Decisions:
+
+   * Sticking to node-based AST structure
+
+
+Project Status (T = code completed and test suite exists, C = code completed, P = in-progress, N = not started):
+
+   T  Parse + and * operations, constants and identifiers
+   T  Build an Object-Oriented AST from the above
+   T  Appropriately allocate registers for arithmetic operations
+   T  Generate HERA code for +, *, and constants
+
+ ---- more will be added later ----
diff --git a/Compiler/README_Sources.txt b/Compiler/README_Sources.txt
new file mode 100644
index 0000000000000000000000000000000000000000..dcbdecf608edb7dcfa732b27c5506086a27df60d
--- /dev/null
+++ b/Compiler/README_Sources.txt
@@ -0,0 +1 @@
+Copy assignment operators - https://en.cppreference.com/w/cpp/language/copy_assignment
\ No newline at end of file
diff --git a/Compiler/generateHERA.cc b/Compiler/generateHERA.cc
new file mode 100644
index 0000000000000000000000000000000000000000..fd07e5c355fe7202aca4775c9b4e485aeab6ab72
--- /dev/null
+++ b/Compiler/generateHERA.cc
@@ -0,0 +1,238 @@
+#include "AST.h"
+#include "ContextInfo.h"
+#include "hc_list_helpers.h"
+#include "streams.h"
+
+using std::string;
+using std::endl;
+
+Dictionary declarationDict = Dictionary();
+int FPoffset = -1;
+
+std::string generateFullHERA(ExprNode *presumedRoot)
+{
+    return "\nCBON()\n" + presumedRoot->generateHERA(ContextInfo());
+}
+
+string IntLiteralNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered IntLiteralNode::generateHERA for integer " + std::to_string(v) << endl;
+	return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
+}
+
+string BoolLiteralNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered BoolLiteralNode::generateHERA for boolean " + std::to_string(v) << endl;
+    return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
+}
+
+std::string HERA_op(const std::string &AST_op_name)
+{
+	if (AST_op_name == "+") {
+		return "ADD";
+	} else if (AST_op_name == "-") {
+		return "SUB";
+	} else if (AST_op_name == "*") {
+		return "MUL";
+    } else if (AST_op_name == "=") {
+        return "CMP";
+    } else if (AST_op_name == ">=") {
+        return "CMP";
+    } else if (AST_op_name == "<=") {
+        return "CMP";
+	} else {
+		throw "Internal compiler inconsistency/incompleteness: HERA_op not implemented for " + AST_op_name;
+	}
+}
+
+string ComparisonNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered ComparisonNode::generateHERA for comparison " + o << endl;
+
+    // see arithmetic node for more about the "context" stuff:
+    //	trace << "need to compare the result of left-hand-side:\n" << left->generateHERA(context) << endl;
+    //	trace << "                        with right-hand-side:\n" << left->generateHERA(context.evalThisAfter()) << endl;
+
+    if (left->getType() != "CallNode" && right->getType() != "CallNode") {
+        if ((left->getType() != "IntLiteralNode" && left->getType() != "VarUseNode" && left->getType() != "LetNode") ||
+                (right->getType() != "IntLiteralNode" && right->getType() != "VarUseNode" && right->getType() != "LetNode")) {
+            cerr << endl << "!Type error! cannot perform comparison operations on non-integers" << endl;
+            exit(98);
+        }
+    }
+
+    ContextInfo rhsContext = context.evalThisAfter();
+    ContextInfo lhsContext = context;  // just named for symmetry
+
+    ContextInfo labelContext1 = ContextInfo();
+    ContextInfo endLabelContext = ContextInfo();
+
+    return left->generateHERA(lhsContext) +
+           right->generateHERA(rhsContext) +
+           HERA_op(o)+"("+lhsContext.getReg()+", "+rhsContext.getReg()+")\n" +
+           "BZ(" + context.getLabel() + ")\n" +
+            ((o == "=")? "SET(" + context.getReg() + ", " + "0)\n" :
+             (o == "<=" || o == ">=")? "BS(" + labelContext1.getLabel() + ")\n" : "") +
+            ((o == ">=")? "SET(" + context.getReg() + ", " + "1)\n" :
+             (o == "<=")? "SET(" + context.getReg() + ", " + "0)\n" : "") +
+            "BR(" + endLabelContext.getLabel() + ")\n" +
+            "LABEL(" + context.getLabel() + ")\n" +
+            "SET(" + context.getReg() + ", " + "1)\n" +
+            "BR(" + endLabelContext.getLabel() + ")\n" +
+            ((o == "<=" || o == ">=")? ("LABEL(" + labelContext1.getLabel() + ")\n" +
+            ((o == "<=")? "SET(" + context.getReg() + ", " + "1)\n" :
+             "SET(" + context.getReg() + ", " + "0)\n")) : "") +
+             "LABEL(" + endLabelContext.getLabel() + ")\n";
+}
+
+string ArithmeticNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered ArithmeticNode::generateHERA for operator " + o << endl;
+	if (length(subexps) != 2) {
+		throw "compiler incomplete/inconsistent: generateHERA not implemented for non-binary arithmetic";
+	}
+
+    if (first(subexps)->getType() != "CallNode" && first(rest(subexps))->getType() != "CallNode") {
+        if ((first(subexps)->getType() != "IntLiteralNode" && first(subexps)->getType() != "VarUseNode" && first(subexps)->getType() != "LetNode") ||
+                (first(rest(subexps))->getType() != "IntLiteralNode" && first(rest(subexps))->getType() != "VarUseNode" && first(rest(subexps))
+                ->getType() != "LetNode")) {
+            cerr << endl << "!Type error! cannot perform arithmetic operations on non-integers" << endl;
+            exit(99);
+        }
+    }
+
+	ContextInfo rhsContext = context.evalThisAfter();
+	ContextInfo lhsContext = context;  // just named for symmetry
+
+    string leftHERA = first(subexps)->generateHERA(lhsContext);
+    string rightHERA = first(rest(subexps))->generateHERA(rhsContext);
+
+    return  leftHERA + rightHERA + HERA_op(o)+"("+context.getReg()+", "+lhsContext.getReg()+", "+rhsContext.getReg()+")\n";
+}
+
+string VarUseNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered VarUseNode::generateHERA for variable " + n << endl;
+
+    return "LOAD(" + context.getReg() + ", " + to_string(declarationDict.lookup(n)) + ", FP)\n";
+}
+
+string CallNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered CallNode::generateHERA for call to " + n << endl;
+	
+	if (length(argList) != 0 || (n != "exit" && n != "getint")) {
+		throw "compiler incomplete/inconsistent: generateHERA for calls only implented for getint and exit";
+	}
+	// NOTE that calls to exit and getint don't need parameters and don't perturb registers
+	return ("MOVE(FP_alt, SP)\nCALL(FP_alt," + n + ")\n"+
+		(context.getReg()=="R1"?"":"MOVE("+context.getReg()+", R1)\n"));
+}
+
+string IfNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered IfNode::generateHERA" << endl;
+
+    if (expriftrue->getType() != "CallNode" && expriffalse->getType() != "CallNode") {
+        if (expriftrue->getType() != expriffalse->getType()) {
+            cerr << endl << "!Type error! \"then\" and \"else\" statements must be of the same type" << endl;
+            exit(45);
+        }
+    }
+
+    ContextInfo conditionContext = context;
+    ContextInfo expriftrueContext = context.evalThisAfter();
+    ContextInfo expriffalseContext = context.evalThisAfter().evalThisAfter();
+
+    ContextInfo labelContext1 = ContextInfo();
+    ContextInfo labelContext2 = ContextInfo();
+
+    string conditionHERA = condition->generateHERA(conditionContext);
+    string expriftrueHERA = expriftrue->generateHERA(expriftrueContext);
+    string expriffalseHERA = expriffalse->generateHERA(expriffalseContext);
+
+    return  conditionHERA + expriftrueHERA + expriffalseHERA +
+            "FLAGS(" + conditionContext.getReg() + ")\n" +
+            "BZ(" + labelContext1.getLabel() + ")\n" +
+            "MOVE(" + context.getReg() + ", " + expriftrueContext.getReg() + ")\n" +
+            "BR(" + labelContext2.getLabel() + ")\n" +
+            "LABEL(" + labelContext1.getLabel() + ")\n" +
+            "MOVE(" + context.getReg() + ", " + expriffalseContext.getReg() + ")\n" +
+            "LABEL(" + labelContext2.getLabel() + ")\n";
+}
+
+string LetNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered LetNode::generateHERA" << endl;
+    ContextInfo declarationsContext = context;
+    ContextInfo expressionsContext = context;
+
+    string expressionsHERA = "";
+    string declarationsHERA = declarations->generateHERA(declarationsContext);
+    expressionsHERA = expressionsHelper(expressionsHERA, expressions, expressionsContext);
+    return declarationsHERA + expressionsHERA;
+}
+
+string LetNode::expressionsHelper(string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const {
+    if (empty(expressions)) {
+        return expressionsHERA;
+    }
+    return expressionsHelper(expressionsHERA += first(expressions)->generateHERA(context), rest(expressions), context.evalThisAfter());
+}
+
+string DeclarationsNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered DeclarationsNode::generateHERA" << endl;
+    ContextInfo declarationsContext = context;
+
+    ContextInfo labelContext = ContextInfo();
+
+    string declarationsHERA = "";
+    return  declarationsHelper(declarationsHERA, declarations, context);
+}
+
+string DeclarationsNode::declarationsHelper(string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const {
+    if (empty(declarations)) {
+        return declarationsHERA;
+    }
+    return declarationsHelper(declarationsHERA += first(declarations)->generateHERA(context), rest(declarations),
+                              context);
+}
+
+string DeclarationNode::generateHERA(const ContextInfo &context) const
+{
+    auto literal = expr;
+    string value;
+    if (declType == "IntLiteralNode") {
+        *literal = intLiteral;
+        value = to_string(intLiteral.getValue());
+    }
+    else if (declType == "BoolLiteralNode") {
+        *literal = boolLiteral;
+        value = boolLiteral.getValue();
+    }
+    else if (declType == "definedVar") {
+        *literal = definedVar;
+        value = definedVar.getValue();
+    }
+
+    trace << "Entered DeclarationNode::generateHERA for declaration " + variable.getValue() + ((declType == "ExprNode")? " = expression" : " = " +
+    value) << endl;
+
+    if (declType == "definedVar") {
+        value = to_string(declarationDict.lookup(value));
+    }
+
+    FPoffset += 1;
+
+    declarationDict.add(variable.getValue(), FPoffset);
+
+    return ((declType == "ExprNode")? literal->generateHERA(context) :
+           (declType == "definedVar")? "LOAD(" + context.getReg() + ", " + value + ", FP)\n" :
+           "SET(" + context.getReg() + ", " + value + ")\n") +
+           "STORE(" + context.getReg() + ", " + std::to_string(FPoffset) + ", FP)\n";
+}
+
+
+
+
diff --git a/Compiler/main.cc b/Compiler/main.cc
new file mode 100644
index 0000000000000000000000000000000000000000..1c612ebde989904917f118f2dd39f1e20d317dbb
--- /dev/null
+++ b/Compiler/main.cc
@@ -0,0 +1,132 @@
+/*
+ * "Compiler" project for HaverRacket
+ *  Translate a subset of Racket into HERA
+ *
+ * To run this project and run the program tests/01-multiply.hrk, use the command:
+ *   Debug/Compiler-C++ < tests/01-multiply.hrk | tee Compiler.out
+ * and then run the HERA program with the command
+ *   HERA-C-Run Compiler.out
+ */
+
+#include <iostream>
+#include <cstdlib>
+#include "scannerDemo.h"
+#include "parser.h"
+#include "ContextInfo.h"
+#include "hc_list_helpers.h" // ez_list
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+
+#include "streams.h"
+#include "Dictionary.h"
+
+// to change trace output, compile with
+//   e.g. -DTRACE_OUTPUT_HERE="./my-trace-output.txt"
+//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to throw away trace output
+//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to always use cerr
+//     or -DTRACE_OUTPUT_HERE=(getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
+//        # that last, the default (I hope) should allow run-time selection via e.g.,
+//        HAVERRACKET_TRACE=my-trace-output1.txt Debug/Compiler-C++
+//
+//  similarly for -DPROMPT_OUTPUT_HERE, which defaults to getenv("HAVERRACKET_PROMPT")
+//    note that prompt is not currently used, though
+
+#if ! defined TRACE_OUTPUT_HERE
+#define TRACE_OUTPUT_HERE (getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
+#endif
+#if ! defined PROMPT_OUTPUT_HERE
+#define PROMPT_OUTPUT_HERE (getenv("HAVERRACKET_PROMPT")?getenv("HAVERRACKET_PROMPT"):"/dev/stderr")
+#endif
+
+#include <fstream>  /* needed for ofstream below */
+std::ofstream _HaverRacket_trace(TRACE_OUTPUT_HERE);
+std::ostream &trace  = _HaverRacket_trace;
+std::ofstream _HaverRacket_prompt(PROMPT_OUTPUT_HERE);
+std::ostream &prompt = _HaverRacket_prompt;
+
+#if ! defined AbstractSyntaxTest
+#define AbstractSyntaxTest build_example1   /* this lets us use a different test easily with a special command line */
+#endif
+
+ParserResult AbstractSyntaxTest();
+
+int main(int numberOfCommandLineArguments, char *theCommandLineArguments[])
+{
+	try {
+		bool testScannerInstead = false;
+        if (numberOfCommandLineArguments == 2 && theCommandLineArguments[1] == string("testScannerInstead")) {
+			trace << "Testing Scanner instead." << endl;
+			testScannerInstead = true;
+		}
+
+		if (testScannerInstead) {
+			cout << "Demonstrating lexical scanner. Enter tokens followed by <EOF>." << endl;
+			scannerDemo();
+		} else {
+			if (!getenv("HAVERRACKET_TEST_CODE_HERA") ||
+			    getenv("HAVERRACKET_TEST_CODE_HERA") == string("#t"))
+			{
+				try {
+					ParserResult example1 = AbstractSyntaxTest();
+
+					trace << "confirming codegen basic functionality on test example1:" << endl;
+					string code = generateFullHERA(example1);
+					trace << code << endl;
+					delete example1;  // we're done with example1 now.
+
+				} catch (const char *message) {
+					cerr << "code generation confirmation test threw exception: " << message << endl;
+					return 2;
+				}
+			}
+
+            trace << "Type in new input!" << endl;
+
+            try {
+				ParserResult AST = matchStartSymbolAndEOF();
+//				trace << "Completed Parsing, got AST: " << AST.toCode() << endl;
+				try {
+                    trace << "\nNow generating code: " << endl;
+					trace << generateFullHERA(AST) << endl;
+				} catch (const char *message) {
+					cerr << "eval threw exception (typically an unhandled case): " << message << endl;
+					return 4;
+				}
+#if FREE_AST_VIA_DESTRUCTORS
+				delete AST;
+#endif
+			} catch (const char *message) {
+				cerr << "that's odd, parser threw exception: " << message << endl;
+				return 3;
+			}
+		}
+
+		return 0;  // indicate successful translation if no exit with non-0 before this
+	} catch (range_error) {
+		cerr << "Yikes! Uncaught exception" << endl;
+		return 66;
+	}
+}
+
+
+	    
+
+ParserResult build_example1()
+{
+//	ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new IntLiteralNode(3), new IntLiteralNode(7)));
+//    ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new BoolLiteralNode("#t"), new BoolLiteralNode("#f")));
+    ExprNode *product = new IfNode(new ComparisonNode("<=", new IntLiteralNode(6), new IntLiteralNode(7)), new BoolLiteralNode("#t"), new
+    BoolLiteralNode("#f"));
+
+    return product;
+/*
+  NOTE that the starter files ExprNode classes do _not_ support the following due to memory allocation techniques,
+    though it might seem at first to work:
+*/
+	// return new ArithmeticNode("+", HaverfordCS::ez_list<ExprNode *>(product, product));
+	// return new ComparisonNode("<=", product, product);
+}
+
diff --git a/Compiler/parser.cc b/Compiler/parser.cc
new file mode 100644
index 0000000000000000000000000000000000000000..9d33bc188510041ae54ff68d34e4426a99d98e50
--- /dev/null
+++ b/Compiler/parser.cc
@@ -0,0 +1,241 @@
+#include <iostream>
+#include <cstdlib>  // for 'exit' function to abandon the program
+#include <hc_list_helpers.h>
+#include "parser.h"
+#include "scanner.h"
+
+using std::string;
+using HaverfordCS::list;
+using HaverfordCS::ez_list;
+using std::cout;
+using std::cerr;
+using std::endl;
+
+#include "streams.h"
+
+// match this:
+// START -> E   <followed by end-of-input>
+// E -> integer
+// E -> boolean
+// E -> identifier
+// E -> ( E_IN_PARENS )
+// E? -> E E?
+// E? -> ""
+// E_IN_PARENS -> OP E E
+// E_IN_PARENS -> letstar E E E?
+// E_IN_PARENS -> [ E_IN_BRACKETS ] E_IN_PARENS
+// E_IN_PARENS -> ""
+// E_IN_PARENS -> EXIT
+// E_IN_PARENS -> GETINT   // New in this version, gets user input
+// E_IN_PARENS -> if E E E
+
+// E_IN_BRACKETS -> E E
+
+// OP --> +|-|*|<=|=|>= OP_COMPARE
+
+// Declare all functions, so they can call each other in any order
+//  (note: "static" means it's restricted to this scope, e.g. this file
+static ParserResult matchE();
+static ParserResult matchEInParens();
+static string matchOp();
+
+
+// FIRST and FOLLOW sets for those,
+//  built with lists rather than sets, for familiarity
+//  defined in terms of kindOfToken from scanner-regexp.h
+static list<kindOfToken> FIRST_OP  = ez_list(PLUS, MINUS, TIMES, OP_COMPARE);
+static list<kindOfToken> FIRST_EIP = FIRST_OP;
+static list<kindOfToken> FIRST_E   = ez_list(INT_LITERAL, BOOL_LITERAL, IDENTIFIER, LPAREN, LBRACKET);
+
+static list<kindOfToken> FOLLOW_OP  = FIRST_E;
+static list<kindOfToken> FOLLOW_EIP = ez_list(RPAREN);
+static list<kindOfToken> FOLLOW_E   = /* append(FOLLOW_EIP, FIRST_E) */
+		                              list<kindOfToken>(RPAREN, FIRST_E);
+	                                  /* Dave should put "append" into list_helpers */
+
+// first, some helpful functions:
+
+// mustGetNextToken:
+//    we call this when we need to get more input and we must find something there,
+//    i.e. when we want to move current_token along and end-of-input would be an error
+void mustGetNextToken()
+{
+	getNextToken();
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+}
+
+
+// currentTokenThenMove
+//   record currentToken (which must NOT be end-of-input), then move past it, return what it was
+static std::string currentTokenThenMove()
+{
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+	std::string curr = currentToken();
+	getNextToken();
+	return curr;
+}
+
+// confirmLiteral
+//   match a literal, assuming the token HAS been scanned already,
+//    i.e. that "currentToken" is _on_ the literal we wish to match
+//   leave "currentToken" on the very last token of the matched pattern ... this is not a "match" function
+static void confirmLiteral(string what)
+{
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+	if (currentToken() != what) {
+		cerr << "got " << currentToken() << " instead of " << what << " at token #" << tokenNumber() << endl;
+		exit(2);
+	}	
+}
+
+
+// match an "E", i.e, anything on the right hand side of any "E-->..." production
+//  assume the first token of the E has been scanned
+//   (i.e., assuming currentToken is the first token of the "E" we're matching)
+//  leave "currentToken" AFTER the very last token of the matched pattern
+static ParserResult matchE()
+{
+	trace << "Entering matchE, current token is " << currentToken() << endl;
+	if (currentTokenKind() == INT_LITERAL) {
+        return new IntLiteralNode(std::stoi(currentTokenThenMove()));
+    } else if (currentTokenKind() == BOOL_LITERAL) {
+        return new BoolLiteralNode(currentTokenThenMove());
+	} else if (currentTokenKind() == IDENTIFIER) {
+        return new VarUseNode(currentTokenThenMove());
+	} else if (currentTokenKind() == LPAREN) {	
+		confirmLiteral("(");
+		mustGetNextToken();
+		ParserResult it = matchEInParens();
+		trace << "After matchEInParens, back in matchE, current token is: " << currentToken() << endl;
+		// if that left off AFTER the end of the E_IN_PARENS, we still need a ")" in the E we're matching
+		confirmLiteral(")");
+		getNextToken();	 // we're AFTER the ) now
+		return it;
+	} else {				
+		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+		exit(3);
+	}
+}
+
+// match an "E_IN_PARENS",
+//  assuming that the currentToken is at the start of the E_IN_PARENS, e.g. a "+"
+//  leave the currentToken AFTER the last part of what was matched,
+//  i.e. *on* the ")" that should come after the E_IN_PARENS
+static ParserResult matchEInParens() {
+	trace << "Entering matchEInParens, current token is " << currentToken() << endl;
+	if (find(currentTokenKind(), FIRST_OP)) {
+        bool its_a_comparison_op = (currentTokenKind() == OP_COMPARE);
+        string theOp = matchOp();
+        ParserResult firstChild = matchE();
+        ParserResult secondChild = matchE();
+        if (its_a_comparison_op) { // a comparison
+            return new ComparisonNode(theOp, firstChild, secondChild);
+        } else {
+            return new ArithmeticNode(theOp, ez_list(firstChild, secondChild));
+        }
+    } else if (currentTokenKind() == LBRACKET) {
+        list<ExprNode *> declarations = list<ExprNode *>();
+	    while (currentTokenKind() != RPAREN) {
+            mustGetNextToken();
+            declarations = list(matchEinBrackets(), declarations);
+            confirmLiteral("]");
+            mustGetNextToken();
+        }
+	    return new DeclarationsNode(reverse(declarations, list<ExprNode *>()));
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "if") {
+	    mustGetNextToken();
+	    ParserResult condition = matchE();
+        ParserResult expriftrue = matchE();
+        ParserResult expriffalse = matchE();
+        return new IfNode(condition, expriftrue, expriffalse);
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "letstar") {
+        mustGetNextToken();
+        ParserResult declarations = matchE();
+        list<ExprNode *> expressions = list<ExprNode *>();
+        while (currentToken() != ")") {
+            expressions = list(matchE(), expressions);
+        }
+	    return new LetNode(declarations, reverse(expressions, list<ExprNode *>()));
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "exit") {
+		return new CallNode(currentTokenThenMove(), list<ParserResult>());
+	} else if (currentTokenKind() == IDENTIFIER && currentToken() == "getint") {
+		return new CallNode(currentTokenThenMove(), list<ParserResult>());
+	} else {
+		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+		exit(3);
+	}
+}
+
+static ParserResult matchEinBrackets() {
+    if (currentTokenKind() == IDENTIFIER) {
+        VarUseNode variable = VarUseNode(currentTokenThenMove());
+        if (currentTokenKind() == IDENTIFIER) {
+            VarUseNode definedVar = VarUseNode(currentTokenThenMove());
+            return new DeclarationNode(variable, definedVar, "definedVar");
+        }
+        else if (currentTokenKind() == INT_LITERAL) {
+            IntLiteralNode literal = IntLiteralNode(stoi(currentTokenThenMove()));
+            return new DeclarationNode(variable, literal, "IntLiteralNode");
+        }
+        else if (currentTokenKind() == BOOL_LITERAL) {
+            BoolLiteralNode literal = BoolLiteralNode(currentTokenThenMove());
+            return new DeclarationNode(variable, literal, "BoolLiteralNode");
+        }
+        else if (currentTokenKind() == LPAREN) {
+            ParserResult expr = matchE();
+            return new DeclarationNode(variable, expr, "ExprNode");
+        }
+    }
+    std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+    exit(3);
+}
+
+// match an operator, assuming that it is the currentToken
+//  leave the currentToken AFTER the last part of what was matched, i.e. unchanged
+static string matchOp()
+{
+	trace << "Entering matchOp, current token is " << currentToken() << endl;
+	// could do three cases here, but that's so tedious...
+	assert (find(currentTokenKind(), FIRST_OP));
+	return currentTokenThenMove();
+}
+
+
+ParserResult matchStartSymbolAndEOF()
+{
+	getNextToken();  // this will be the first one
+	if (!tokenAvailable()) {
+		cerr << "Illegal end of input" << endl;
+		exit(2);
+	}
+
+	ParserResult fullExpression = matchE();  // "E" is our start symbol
+
+	// now make sure there isn't anything else!
+	getNextToken();
+	if (tokenAvailable()) {
+		cerr << "Warning: extra input after end: " << currentToken() << endl;
+		exit (1);
+	}
+
+	return fullExpression;
+}
+
+list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList) {
+    if (empty(list)) {
+        return newList;
+    }
+    if (length(list) == 1) {
+        return ::list(first(list), newList);
+    }
+    return reverse(rest(list), ::list(first(list), newList));
+}
\ No newline at end of file
diff --git a/Compiler/parser.h b/Compiler/parser.h
new file mode 100644
index 0000000000000000000000000000000000000000..15ffe20d1b1c102d511f9bad3e92f9cd7ee846ef
--- /dev/null
+++ b/Compiler/parser.h
@@ -0,0 +1,18 @@
+#ifndef PARSER_H_
+#define PARSER_H_
+
+
+#include "AST.h"
+
+// The typedef below makes the name "translatedResult"
+//  mean a "Tree" object from our Expr_Node type heirarchy.
+typedef ExprNode *ParserResult;
+
+ParserResult matchStartSymbolAndEOF();
+static ParserResult matchE();
+static ParserResult matchEinParens();
+static ParserResult matchEinBrackets();
+static std::string matchOp();
+list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList);
+
+#endif /*PARSER_H_*/
diff --git a/Compiler/scanner-regexp.cc b/Compiler/scanner-regexp.cc
new file mode 100644
index 0000000000000000000000000000000000000000..b7ad7688e6baab205aa96ba07e3ab106334e876a
--- /dev/null
+++ b/Compiler/scanner-regexp.cc
@@ -0,0 +1,1871 @@
+
+#line 2 "<stdout>"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 4
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* begin standard C++ headers. */
+
+/* TODO: this is always defined, so inline it */
+#define yyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
+#else
+#define yynoreturn
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
+ */
+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin  )
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+    
+    #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	int yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = NULL;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart ( FILE *input_file  );
+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
+void yy_delete_buffer ( YY_BUFFER_STATE b  );
+void yy_flush_buffer ( YY_BUFFER_STATE b  );
+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state ( void );
+
+static void yyensure_buffer_stack ( void );
+static void yy_load_buffer_state ( void );
+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
+
+void *yyalloc ( yy_size_t  );
+void *yyrealloc ( void *, yy_size_t  );
+void yyfree ( void *  );
+
+#define yy_new_buffer yy_create_buffer
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+typedef flex_uint8_t YY_CHAR;
+
+FILE *yyin = NULL, *yyout = NULL;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+int yylineno = 1;
+
+extern char *yytext;
+#ifdef yytext_ptr
+#undef yytext_ptr
+#endif
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state ( void );
+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
+static int yy_get_next_buffer ( void );
+static void yynoreturn yy_fatal_error ( const char* msg  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+#define YY_NUM_RULES 19
+#define YY_END_OF_BUFFER 20
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static const flex_int16_t yy_accept[33] =
+    {   0,
+        0,    0,   20,   18,    1,    2,    2,   18,    4,    5,
+       10,    8,    9,   15,    3,   18,   11,   18,   17,    6,
+        7,   16,   15,    3,   12,    0,   13,   17,    0,    0,
+       14,    0
+    } ;
+
+static const YY_CHAR yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    5,    1,    1,    1,    1,    6,
+        7,    8,    9,    1,   10,    1,    1,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,    1,   12,   13,
+       14,   15,    1,    1,   16,   16,   16,   16,   17,   18,
+       16,   16,   16,   16,   16,   16,   16,   16,   19,   16,
+       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
+       20,    1,   21,    1,   22,    1,   23,   23,   23,   23,
+
+       23,   24,   23,   23,   23,   23,   23,   23,   23,   23,
+       23,   23,   23,   23,   23,   25,   23,   23,   23,   23,
+       23,   23,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static const YY_CHAR yy_meta[26] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        3,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    3,    3,    3
+    } ;
+
+static const flex_int16_t yy_base[35] =
+    {   0,
+        0,    0,   40,   41,   41,   41,   41,    2,   41,   41,
+       41,   41,   28,   27,    0,   14,   41,   23,    0,   41,
+       41,   41,   25,    0,   41,   16,   41,    0,   15,   15,
+       41,   41,   31,   26
+    } ;
+
+static const flex_int16_t yy_def[35] =
+    {   0,
+       32,    1,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   33,   32,   32,   32,   34,   32,
+       32,   32,   32,   33,   32,   32,   32,   34,   32,   32,
+       32,    0,   32,   32
+    } ;
+
+static const flex_int16_t yy_nxt[67] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,   15,   16,   17,   18,   19,   19,   19,   19,   20,
+       21,    4,   19,   19,   19,   22,   22,   25,   28,   31,
+       26,   24,   30,   24,   29,   23,   27,   23,   23,   32,
+        3,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32
+    } ;
+
+static const flex_int16_t yy_chk[67] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    8,    8,   16,   34,   30,
+       16,   33,   29,   33,   26,   23,   18,   14,   13,    3,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "scanner-regexp.l"
+#line 2 "scanner-regexp.l"
+/*
+
+   This is a lexical scanner specification for the "lex" (or "flex") language.
+   It can be translated into a "C++" file by running, in the project directory, the command
+
+    flex  -t scanner-regexp.l > scanner-regexp.cc
+
+
+   In this first section of the lex file (between %{ and %}),
+   we define C++ functions that will be used later in the actions of part 3.
+
+*/
+
+#include "scanner-regexp.h"
+
+// the code generated by the flex system requires we write this:
+extern "C" int yywrap()
+{
+ return 1;
+}
+
+#line 484 "<stdout>"
+/* In this second section of the lex file (after the %}),
+   we can define variables in terms of regular expressions.
+   C-style comments (like this one) are also legal. */
+/* In the third section of the lex file (after the %%),
+   we can define the patterns for each token
+   in terms of regular expressions and the variables above,
+   and give the action (as C++ code) for each token.
+   Comments are legal only inside the actions. */
+#line 493 "<stdout>"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals ( void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy ( void );
+
+int yyget_debug ( void );
+
+void yyset_debug ( int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra ( void );
+
+void yyset_extra ( YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in ( void );
+
+void yyset_in  ( FILE * _in_str  );
+
+FILE *yyget_out ( void );
+
+void yyset_out  ( FILE * _out_str  );
+
+			int yyget_leng ( void );
+
+char *yyget_text ( void );
+
+int yyget_lineno ( void );
+
+void yyset_lineno ( int _line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap ( void );
+#else
+extern int yywrap ( void );
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+    
+    static void yyunput ( int c, char *buf_ptr  );
+    
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy ( char *, const char *, int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen ( const char * );
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput ( void );
+#else
+static int input ( void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK /*LINTED*/break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
+    
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state(  );
+		}
+
+	{
+#line 38 "scanner-regexp.l"
+
+
+#line 713 "<stdout>"
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 33 )
+					yy_c = yy_meta[yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 41 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 40 "scanner-regexp.l"
+{ continue; }  /* do nothing with blank spaces */
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 41 "scanner-regexp.l"
+{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 42 "scanner-regexp.l"
+{ continue; }  /* treat comments like other blank space */
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 44 "scanner-regexp.l"
+{ tokenCount++; return LPAREN; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 45 "scanner-regexp.l"
+{ tokenCount++; return RPAREN; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 46 "scanner-regexp.l"
+{ tokenCount++; return LBRACKET; }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 47 "scanner-regexp.l"
+{ tokenCount++; return RBRACKET; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 48 "scanner-regexp.l"
+{ tokenCount++; return PLUS; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 49 "scanner-regexp.l"
+{ tokenCount++; return MINUS; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 50 "scanner-regexp.l"
+{ tokenCount++; return TIMES; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 51 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 52 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 53 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 55 "scanner-regexp.l"
+{ tokenCount++; return END_OF_INPUT; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 57 "scanner-regexp.l"
+{ tokenCount++; return INT_LITERAL; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 58 "scanner-regexp.l"
+{ tokenCount++; return BOOL_LITERAL; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 60 "scanner-regexp.l"
+{ tokenCount++; return IDENTIFIER; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 62 "scanner-regexp.l"
+{ scannerError(); continue; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 63 "scanner-regexp.l"
+ECHO;
+	YY_BREAK
+#line 866 "<stdout>"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap(  ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of user's declarations */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = (yytext_ptr);
+	int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc( (void *) b->yy_ch_buf,
+							 (yy_size_t) (b->yy_buf_size + 2)  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = NULL;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
+			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	yy_state_type yy_current_state;
+	char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 33 )
+				yy_c = yy_meta[yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	int yy_is_jam;
+    	char *yy_cp = (yy_c_buf_p);
+
+	YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 33 )
+			yy_c = yy_meta[yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+	yy_is_jam = (yy_current_state == 32);
+
+		return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_UNPUT
+
+    static void yyunput (int c, char * yy_bp )
+{
+	char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		int number_to_move = (yy_n_chars) + 2;
+		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap(  ) )
+						return 0;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer( yyin, YY_BUF_SIZE );
+	}
+
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state(  );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree( (void *) b->yy_ch_buf  );
+
+	yyfree( (void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state(  );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state(  );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state(  );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	yy_size_t num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return NULL;
+
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = NULL;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (const char * yystr )
+{
+    
+	return yy_scan_bytes( yystr, (int) strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = (yy_size_t) (_yybytes_len + 2);
+	buf = (char *) yyalloc( n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yynoreturn yy_fatal_error (const char* msg )
+{
+			fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+    
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param _line_number line number
+ * 
+ */
+void yyset_lineno (int  _line_number )
+{
+    
+    yylineno = _line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param _in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  _in_str )
+{
+        yyin = _in_str ;
+}
+
+void yyset_out (FILE *  _out_str )
+{
+        yyout = _out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  _bdebug )
+{
+        yy_flex_debug = _bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = NULL;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = NULL;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = NULL;
+    yyout = NULL;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, const char * s2, int n )
+{
+		
+	int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (const char * s )
+{
+	int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+			return malloc(size);
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+		
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return realloc(ptr, size);
+}
+
+void yyfree (void * ptr )
+{
+			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 63 "scanner-regexp.l"
diff --git a/Compiler/scanner-regexp.h b/Compiler/scanner-regexp.h
new file mode 100644
index 0000000000000000000000000000000000000000..5fa81c7468cafb661690537bdcabda0390bf56a7
--- /dev/null
+++ b/Compiler/scanner-regexp.h
@@ -0,0 +1,13 @@
+enum kindOfToken {
+	END_OF_INPUT = 0,   // defined by flex system
+	LPAREN,	RPAREN,
+	PLUS,	MINUS,	TIMES,
+	OP_COMPARE,
+	INT_LITERAL, BOOL_LITERAL,
+	IDENTIFIER, LBRACKET,
+	RBRACKET
+};
+
+void scannerError(); /// define in whatever uses the regexp-based scanner
+
+extern int tokenCount;  // not static because the .l file needs it too
diff --git a/Compiler/scanner-regexp.l b/Compiler/scanner-regexp.l
new file mode 100644
index 0000000000000000000000000000000000000000..f8a896b4eecb04d6369f19286b40cb45f4ec73b3
--- /dev/null
+++ b/Compiler/scanner-regexp.l
@@ -0,0 +1,62 @@
+%{
+/*
+
+   This is a lexical scanner specification for the "lex" (or "flex") language.
+   It can be translated into a "C++" file by running, in the project directory, the command
+
+    flex  -t scanner-regexp.l > scanner-regexp.cc
+
+
+   In this first section of the lex file (between %{ and %}),
+   we define C++ functions that will be used later in the actions of part 3.
+
+*/
+
+#include "scanner-regexp.h"
+
+// the code generated by the flex system requires we write this:
+extern "C" int yywrap()
+{
+ return 1;
+}
+
+%}
+
+/* In this second section of the lex file (after the %}),
+   we can define variables in terms of regular expressions.
+   C-style comments (like this one) are also legal. */
+
+digit		[0-9]
+identifier	[a-zA-Z][a-z0-9_]*
+
+/* In the third section of the lex file (after the %%),
+   we can define the patterns for each token
+   in terms of regular expressions and the variables above,
+   and give the action (as C++ code) for each token.
+   Comments are legal only inside the actions. */
+
+%%
+
+[ \t]		{ continue; }  /* do nothing with blank spaces */
+[\n\r]		{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
+\;.*		{ continue; }  /* treat comments like other blank space */
+
+"("			{ tokenCount++; return LPAREN; }
+")"			{ tokenCount++; return RPAREN; }
+"["			{ tokenCount++; return LBRACKET; }
+"]"			{ tokenCount++; return RBRACKET; }
+"+"			{ tokenCount++; return PLUS; }
+"-"			{ tokenCount++; return MINUS; }
+"*"			{ tokenCount++; return TIMES; }
+"="			{ tokenCount++; return OP_COMPARE; }
+"<="			{ tokenCount++; return OP_COMPARE; }
+">="			{ tokenCount++; return OP_COMPARE; }
+
+"<EOF>"		{ tokenCount++; return END_OF_INPUT; }
+
+-?{digit}+	  { tokenCount++; return INT_LITERAL; }
+(#t|#f)	  { tokenCount++; return BOOL_LITERAL; }
+
+{identifier}  { tokenCount++; return IDENTIFIER; }
+
+.			{ scannerError(); continue; }
diff --git a/Compiler/scanner.cc b/Compiler/scanner.cc
new file mode 100644
index 0000000000000000000000000000000000000000..6914da3cb3772f259411ae765eb35f0dc8d6517b
--- /dev/null
+++ b/Compiler/scanner.cc
@@ -0,0 +1,82 @@
+#include <iostream>
+#include <logic.h>
+#include "scanner.h"
+
+#if ! defined USE_YYLEX
+#define USE_YYLEX 1  /* Use the stuff from scanner-regexp.l by default */
+#endif
+
+using namespace std;
+
+int tokenCount = 0;  // not static because the .l file needs it too
+static bool endOfInput = false;
+static bool calledGetNextTokenAlready = false;
+static string current = "";
+static kindOfToken currentKind;
+
+// some things built into scanner-regexp.cc by the flex system:
+extern int yylex();
+extern char *yytext;  // C-style string
+
+
+string currentToken()
+{
+	precondition(calledGetNextTokenAlready);
+	precondition(tokenAvailable());
+	
+	return current;
+}
+enum kindOfToken currentTokenKind()
+{
+	precondition(calledGetNextTokenAlready);
+	precondition(tokenAvailable());
+
+	return currentKind;
+}
+
+bool tokenAvailable()
+{
+	precondition(calledGetNextTokenAlready);
+	
+	return !endOfInput;
+}
+
+int  tokenNumber()
+{
+	return tokenCount;
+}
+
+void getNextToken()
+{
+	if (calledGetNextTokenAlready && endOfInput) return;  // No soup for you!
+	
+	calledGetNextTokenAlready = true;
+#if USE_YYLEX
+	/// This interfaces with scanner-regexp.cc
+	/// remember to update it from scanner-regexp.l if that is changed!
+	currentKind = kindOfToken(yylex()); // yylex thinks it could return any int but we know better
+	if (currentKind == 0) {
+		endOfInput = true;
+		current      = "";
+	} else {
+		current      = yytext;
+	}
+#else
+	/// HERE IS THE OLD CODE, before I tried lex
+	if (endOfInput || !cin) {
+		endOfInput = true;
+	} else {
+		cin >> current;
+		if (cin && current != "<EOF>") {
+			tokenCount++;
+		} else {
+			endOfInput = true;
+		}
+	}
+#endif
+}
+
+void scannerError()
+{
+	cerr << "Error: illegal token: '" << yytext << "'\n";
+}
diff --git a/Compiler/scanner.h b/Compiler/scanner.h
new file mode 100644
index 0000000000000000000000000000000000000000..4f5e847c7e37bc31c039d0689e8a4d61aa8e61da
--- /dev/null
+++ b/Compiler/scanner.h
@@ -0,0 +1,27 @@
+#ifndef _SCANNER_H_
+#define _SCANNER_H_
+
+#include <string>
+#include "scanner-regexp.h"
+
+// A simple lexical scanner
+
+// return the current token
+//  precondition:     you have called getNextToken at least once
+//                and tokenAvialable did not return false
+std::string currentToken();
+enum kindOfToken currentTokenKind();
+
+// see if there is a token (return false for end-of-input or the special input <EOF>)
+//  precondition: you must have called getNextToken at least once
+bool tokenAvailable();
+
+// return the number of tokens scanned so far
+// precondition: true
+int  tokenNumber();
+
+// advance current token to the next input
+// precondition: true
+void getNextToken();
+
+#endif //_SCANNER_H_
diff --git a/Compiler/scannerDemo.cc b/Compiler/scannerDemo.cc
new file mode 100644
index 0000000000000000000000000000000000000000..208c53d98c9e7123e7d493a23ac1b672511904a1
--- /dev/null
+++ b/Compiler/scannerDemo.cc
@@ -0,0 +1,16 @@
+#include <iostream>
+#include "scanner.h"
+#include "scannerDemo.h"
+
+using std::cout;
+using std::endl;
+
+void scannerDemo()
+{
+	while (getNextToken(), tokenAvailable()) {
+		cout << "Token number " << tokenNumber() << " is ";
+		cout << "'" << currentToken() << "'";
+		cout << ", which is token kind " << kindOfToken(currentTokenKind()) << endl;
+	}
+	cout << "Reached end-of-file, now stopping!" << endl;
+}
diff --git a/Compiler/scannerDemo.h b/Compiler/scannerDemo.h
new file mode 100644
index 0000000000000000000000000000000000000000..7a767af034dc466d09612dc1c35e571617d4b380
--- /dev/null
+++ b/Compiler/scannerDemo.h
@@ -0,0 +1,13 @@
+/*
+ * scanner_demo.h
+ *
+ *  Created on: Oct 2, 2009
+ *      Author: davew
+ */
+
+#ifndef SCANNER_DEMO_H_
+#define SCANNER_DEMO_H_
+
+void scannerDemo();
+
+#endif /* SCANNER_DEMO_H_ */
diff --git a/Compiler/streams.h b/Compiler/streams.h
new file mode 100644
index 0000000000000000000000000000000000000000..7fb6c59e608e66bc3c4191565ad9e58c63ec9bb3
--- /dev/null
+++ b/Compiler/streams.h
@@ -0,0 +1,3 @@
+extern std::ostream &trace;
+extern std::ostream &prompt;
+// extern std::ostream &debug;  // could separate these if we had a reason to do so...
diff --git a/Compiler/tests/01-multiply.hrk b/Compiler/tests/01-multiply.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..93a3f65ef3836c85fd496c0688b7ac5ff194d3f8
--- /dev/null
+++ b/Compiler/tests/01-multiply.hrk
@@ -0,0 +1 @@
+(* 6 7)
diff --git a/Compiler/tests/02-add-and-mult.hrk b/Compiler/tests/02-add-and-mult.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..f35212807441cfcf33303be75c979f77563f03d1
--- /dev/null
+++ b/Compiler/tests/02-add-and-mult.hrk
@@ -0,0 +1 @@
+(* (+ 2 5) (+ (+ 1 (* 2 1)) (+ 2 1)))
diff --git a/Compiler/tests/03-mult-input.hrk b/Compiler/tests/03-mult-input.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..06969783b8af0aba0d6bf02916955cdbb0cdb750
--- /dev/null
+++ b/Compiler/tests/03-mult-input.hrk
@@ -0,0 +1 @@
+(* 3 (getint))
diff --git a/Compiler/tests/04-mult-exit.hrk b/Compiler/tests/04-mult-exit.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..7de54e54bb3b816fff8e9c3d353e35c6dbc78f48
--- /dev/null
+++ b/Compiler/tests/04-mult-exit.hrk
@@ -0,0 +1 @@
+(* 3 (exit))
diff --git a/Compiler/tests/arithmetic or comparison operation type error.txt b/Compiler/tests/arithmetic or comparison operation type error.txt
new file mode 100644
index 0000000000000000000000000000000000000000..74171143e261de0bc3b254b650af40c193bedf3e
--- /dev/null
+++ b/Compiler/tests/arithmetic or comparison operation type error.txt	
@@ -0,0 +1 @@
+( <= 4 #f ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/comparison.txt b/Compiler/tests/comparison.txt
new file mode 100644
index 0000000000000000000000000000000000000000..8bdf47dbd9ea3f0bc1319e04feb58aee6c3ce058
--- /dev/null
+++ b/Compiler/tests/comparison.txt
@@ -0,0 +1 @@
+( <= 4 5 ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if type error.txt b/Compiler/tests/if type error.txt
new file mode 100644
index 0000000000000000000000000000000000000000..60dca31173babb20287ac03e8cda9f9669101989
--- /dev/null
+++ b/Compiler/tests/if type error.txt	
@@ -0,0 +1 @@
+(if #t 3 h) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if.txt b/Compiler/tests/if.txt
new file mode 100644
index 0000000000000000000000000000000000000000..0fbbcb19e4e2929c3eaa6d30d03260f63901f1bb
--- /dev/null
+++ b/Compiler/tests/if.txt
@@ -0,0 +1 @@
+(if #t (if #f 2 3) (if #t 4 5)) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/let.txt b/Compiler/tests/let.txt
new file mode 100644
index 0000000000000000000000000000000000000000..3fe340a7484f889f26288b6a1175d4a6373d5e93
--- /dev/null
+++ b/Compiler/tests/let.txt
@@ -0,0 +1 @@
+(+ (letstar ( [x 1] [y 2] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/letstar.txt b/Compiler/tests/letstar.txt
new file mode 100644
index 0000000000000000000000000000000000000000..366eb923d0f93ca9fdb2006108e0a168112eb779
--- /dev/null
+++ b/Compiler/tests/letstar.txt
@@ -0,0 +1 @@
+(+ (letstar ( [x 3] [y x] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested let.txt b/Compiler/tests/nested let.txt
new file mode 100644
index 0000000000000000000000000000000000000000..17e52566013a6c055a7c8ad9fbb3ae9b235f7ece
--- /dev/null
+++ b/Compiler/tests/nested let.txt	
@@ -0,0 +1 @@
+(+ (letstar ( [x 1] [y 2] ) (+ x (letstar ( [z 3] [y 4] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested letstar.txt b/Compiler/tests/nested letstar.txt
new file mode 100644
index 0000000000000000000000000000000000000000..8808cc7ddf8d4f32094aa7e973959b70d9441474
--- /dev/null
+++ b/Compiler/tests/nested letstar.txt	
@@ -0,0 +1 @@
+(+ (letstar ( [x 4] [y 2] ) (+ x (letstar ( [z y] [y x] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file

From 4cd8bd35e2f16969c687a1253a3312cea84ac951 Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 15:36:58 +0300
Subject: [PATCH] rm compiler

---
 Compiler/.cproject                                 |   72 -
 Compiler/.gitignore                                |    8 -
 Compiler/.project                                  |   82 -
 Compiler/AST.cc                                    |  242 ---
 Compiler/AST.h                                     |  245 ---
 Compiler/CMakeLists.txt                            |   18 -
 Compiler/ContextInfo.cc                            |   46 -
 Compiler/ContextInfo.h                             |   22 -
 Compiler/Dictionary.cpp                            |  124 --
 Compiler/Dictionary.h                              |  101 --
 Compiler/README-Collaboration.txt                  |    1 -
 Compiler/README-Design.txt                         |   16 -
 Compiler/README_Sources.txt                        |    1 -
 Compiler/generateHERA.cc                           |  238 ---
 Compiler/main.cc                                   |  132 --
 Compiler/parser.cc                                 |  241 ---
 Compiler/parser.h                                  |   18 -
 Compiler/scanner-regexp.cc                         | 1871 --------------------
 Compiler/scanner-regexp.h                          |   13 -
 Compiler/scanner-regexp.l                          |   62 -
 Compiler/scanner.cc                                |   82 -
 Compiler/scanner.h                                 |   27 -
 Compiler/scannerDemo.cc                            |   16 -
 Compiler/scannerDemo.h                             |   13 -
 Compiler/streams.h                                 |    3 -
 Compiler/tests/01-multiply.hrk                     |    1 -
 Compiler/tests/02-add-and-mult.hrk                 |    1 -
 Compiler/tests/03-mult-input.hrk                   |    1 -
 Compiler/tests/04-mult-exit.hrk                    |    1 -
 ...ithmetic or comparison operation type error.txt |    1 -
 Compiler/tests/comparison.txt                      |    1 -
 Compiler/tests/if type error.txt                   |    1 -
 Compiler/tests/if.txt                              |    1 -
 Compiler/tests/let.txt                             |    1 -
 Compiler/tests/letstar.txt                         |    1 -
 Compiler/tests/nested let.txt                      |    1 -
 Compiler/tests/nested letstar.txt                  |    1 -
 37 files changed, 3706 deletions(-)

diff --git a/Compiler/.cproject b/Compiler/.cproject
deleted file mode 100644
index 909e19a7e90ca0f6e31541b0d3f726a9ead5b304..0000000000000000000000000000000000000000
--- a/Compiler/.cproject
+++ /dev/null
@@ -1,72 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
-	<storageModule moduleId="org.eclipse.cdt.core.settings">
-		<cconfiguration id="cdt.managedbuild.config.gnu.exe.debug.1161916250">
-			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" moduleId="org.eclipse.cdt.core.settings" name="Debug">
-				<externalSettings/>
-				<extensions>
-					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
-					<extension id="org.eclipse.cdt.core.MakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
-					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
-				</extensions>
-			</storageModule>
-			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
-				<configuration artifactExtension="" artifactName="Compiler-C++" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" errorParsers="org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.GASErrorParser" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" name="Debug" parent="cdt.managedbuild.config.gnu.exe.debug">
-					<folderInfo id="cdt.managedbuild.config.gnu.exe.debug.1161916250.1127859407" name="/" resourcePath="">
-						<toolChain id="cdt.managedbuild.toolchain.gnu.exe.debug.1737210637" name="GCC Tool Chain" superClass="cdt.managedbuild.toolchain.gnu.exe.debug">
-							<targetPlatform id="cdt.managedbuild.target.gnu.platform.exe.debug.1043903385" name="Debug Platform" superClass="cdt.managedbuild.target.gnu.platform.exe.debug"/>
-							<builder buildPath="${workspace_loc:/Interpreter-C++/Debug}" id="cdt.managedbuild.target.gnu.builder.exe.debug.1885040107" keepEnvironmentInBuildfile="false" name="Gnu Make Builder" superClass="cdt.managedbuild.target.gnu.builder.exe.debug"/>
-							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug.1315278191" name="GCC C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug">
-								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.compiler.option.include.paths.668525549" name="Include paths (-I)" superClass="gnu.cpp.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
-									<listOptionValue builtIn="false" value="/home/courses/include"/>
-								</option>
-								<option id="gnu.cpp.compiler.exe.debug.option.optimization.level.793100283" name="Optimization Level" superClass="gnu.cpp.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.optimization.level.none" valueType="enumerated"/>
-								<option id="gnu.cpp.compiler.exe.debug.option.debugging.level.1408142720" name="Debug Level" superClass="gnu.cpp.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.debugging.level.max" valueType="enumerated"/>
-								<option id="gnu.cpp.compiler.option.dialect.std.1577870906" name="Language standard" superClass="gnu.cpp.compiler.option.dialect.std" useByScannerDiscovery="true" value="gnu.cpp.compiler.dialect.c++1y" valueType="enumerated"/>
-								<inputType id="cdt.managedbuild.tool.gnu.cpp.compiler.input.842239186" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.input"/>
-							</tool>
-							<tool id="cdt.managedbuild.tool.gnu.c.compiler.exe.debug.351478677" name="GCC C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.exe.debug">
-								<option defaultValue="gnu.c.optimization.level.none" id="gnu.c.compiler.exe.debug.option.optimization.level.1879412635" name="Optimization Level" superClass="gnu.c.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" valueType="enumerated"/>
-								<option id="gnu.c.compiler.exe.debug.option.debugging.level.648859551" name="Debug Level" superClass="gnu.c.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.c.debugging.level.max" valueType="enumerated"/>
-								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.219263748" superClass="cdt.managedbuild.tool.gnu.c.compiler.input"/>
-							</tool>
-							<tool id="cdt.managedbuild.tool.gnu.c.linker.exe.debug.370219233" name="GCC C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.exe.debug"/>
-							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug.1321052876" name="GCC C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug">
-								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.libs.311614395" name="Libraries (-l)" superClass="gnu.cpp.link.option.libs" useByScannerDiscovery="false" valueType="libs">
-									<listOptionValue builtIn="false" value="courses"/>
-								</option>
-								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.paths.603027165" name="Library search path (-L)" superClass="gnu.cpp.link.option.paths" useByScannerDiscovery="false" valueType="stringList">
-									<listOptionValue builtIn="false" value="/home/courses/lib"/>
-								</option>
-								<inputType id="cdt.managedbuild.tool.gnu.cpp.linker.input.2141151307" superClass="cdt.managedbuild.tool.gnu.cpp.linker.input">
-									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
-									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
-								</inputType>
-							</tool>
-							<tool id="cdt.managedbuild.tool.gnu.assembler.exe.debug.1455701237" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.exe.debug">
-								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.1492382276" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
-							</tool>
-							<tool id="cdt.managedbuild.tool.gnu.archiver.base.1329154531" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.base"/>
-						</toolChain>
-					</folderInfo>
-				</configuration>
-			</storageModule>
-			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
-		</cconfiguration>
-	</storageModule>
-	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
-		<project id="Interpreter-C++.cdt.managedbuild.target.gnu.exe.1148232902" name="Executable (Gnu)" projectType="cdt.managedbuild.target.gnu.exe"/>
-	</storageModule>
-	<storageModule moduleId="scannerConfiguration"/>
-	<storageModule moduleId="refreshScope" versionNumber="2">
-		<configuration configurationName="Debug">
-			<resource resourceType="PROJECT" workspacePath="/Compiler-C++"/>
-		</configuration>
-	</storageModule>
-	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
-	<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
-</cproject>
diff --git a/Compiler/.gitignore b/Compiler/.gitignore
deleted file mode 100644
index 3f41ab15da41e4fbd4b9d23106bccda660f6c1bb..0000000000000000000000000000000000000000
--- a/Compiler/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-*~
-#*#
-cmake-build-debug
-Debug
-.settings
-.idea
-.DS_Store
-Compiler.out
diff --git a/Compiler/.project b/Compiler/.project
deleted file mode 100644
index fcf25eff71b070352f4ba0ab857e8c9b49fca63a..0000000000000000000000000000000000000000
--- a/Compiler/.project
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>Compiler-C++</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
-			<triggers>clean,full,incremental,</triggers>
-			<arguments>
-				<dictionary>
-					<key>?name?</key>
-					<value></value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.append_environment</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
-					<value>all</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildArguments</key>
-					<value></value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildCommand</key>
-					<value>make</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.buildLocation</key>
-					<value>${workspace_loc:/Tree-C++/Debug}</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
-					<value>clean</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.contents</key>
-					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
-					<value>false</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
-					<value>all</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.stopOnError</key>
-					<value>true</value>
-				</dictionary>
-				<dictionary>
-					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
-					<value>true</value>
-				</dictionary>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.cdt.core.cnature</nature>
-		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
-		<nature>org.eclipse.cdt.core.ccnature</nature>
-		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
-	</natures>
-</projectDescription>
diff --git a/Compiler/AST.cc b/Compiler/AST.cc
deleted file mode 100644
index fd946ffe54ebdaf973c285682036f46ed6f5dbfe..0000000000000000000000000000000000000000
--- a/Compiler/AST.cc
+++ /dev/null
@@ -1,242 +0,0 @@
-#include <hc_list.h>
-#include <hc_list_helpers.h>
-#include "parser.h"  // for n_errors count; this should really be refactored
-#include "streams.h"
-
-using std::string;
-using std::endl;
-using HaverfordCS::list;
-
-
-#include <fstream>  /* needed for ofstream below */
-#if defined TRACE_EXPR_ALLOCATIONS
-static std::ofstream  alloc_trace(TRACE_EXPR_ALLOCATIONS);
-#else
-// by default, allow option for control via environment variable, but it's not given, send to /dev/null (disappears)
-static std::ofstream alloc_trace(getenv("HAVERRACKET_ALLOC_TRACE")?getenv("HAVERRACKET_ALLOC_TRACE"):"/dev/null");
-// static std::ofstream &alloc_trace = trace;  // alternate easy option, just send to regular trace
-#endif
-
-
-
-// This file has the constructors and destructors;
-//   all the generateHERA methods are together in generateHERA.cc
-
-
-// C++ Usage Note:
-// The v(value) is like having v=value, but initializes v rather than assigning to it
-// i.e., writing "v = value" in the constructor _body_ is like writing
-// i.e., writing "v = value" in the constructor _body_ is like writing
-//     int i;
-//     i = 12;
-// whereas writing v(value) before the body is like writing
-//     int i=12;  // i is created with "12" from the start
-//
-// Those steps, as the call(s) to any superclass(es)' constructors, are done before the body of the IntLiteralNode itself
-IntLiteralNode::IntLiteralNode(int value) : v(value)
-{
-	// nothing else needs to be done here, since the stuff above defines "v" as "value"
-	alloc_trace << "(class IntLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
-}
-
-BoolLiteralNode::BoolLiteralNode(string value) : v((value == "#t")? 1 : 0)
-{
-    // nothing else needs to be done here, since the stuff above defines "v" as "value"
-    alloc_trace << "(class BoolLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
-}
-
-// (so, we should see this trace before the one above, for each int literal node)
-ExprNode::ExprNode()
-{
-	alloc_trace << "[superclass ExprNode constructor  called for node at memory " << this << endl;
-}
-
-ComparisonNode::ComparisonNode(string op, ExprNode *lhs, ExprNode *rhs) :
-	o(op),
-	left(lhs),
-	right(rhs)
-{
-	alloc_trace << "(class ComparisonNode constructor called for node at memory " << this << endl;
-}
-
-ArithmeticNode::ArithmeticNode(string op, list<ExprNode *>operands) :
-	o(op),
-	subexps(operands)
-{
-	alloc_trace << "(class ArithmeticNode constructor called for node at memory " << this << endl;
-}
-
-
-VarUseNode::VarUseNode(string name) : n(name)
-{
-	alloc_trace << "(class     VarUseNode constructor called for node at memory " << this << endl;
-}
-
-CallNode::CallNode(string funcName, HaverfordCS::list<ExprNode *>arguments) :
-	n(funcName),
-	argList(arguments)
-{
-	alloc_trace << "(class       CallNode constructor called for node at memory " << this << endl;
-}
-
-IfNode::IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse) :
-    condition(condition),
-    expriftrue(expriftrue),
-    expriffalse(expriffalse)
-{
-    alloc_trace << "(class IfNode constructor called for node at memory " << this << endl;
-}
-
-LetNode::LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions) :
-        declarations(declarations),
-        expressions(expressions)
-{
-    alloc_trace << "(class LetNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationsNode::DeclarationsNode(HaverfordCS::list<ExprNode *> declarations) :
-        declarations(declarations)
-{
-    alloc_trace << "(class DeclarationsNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationNode::DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType) :
-        variable(variable),
-        intLiteral(intLiteral),
-        declType(declType)
-{
-    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationNode::DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType) :
-        variable(variable),
-        boolLiteral(boolLiteral),
-        declType(declType)
-{
-    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationNode::DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType) :
-        variable(variable),
-        definedVar(definedVar),
-        declType(declType)
-{
-    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
-}
-
-DeclarationNode::DeclarationNode(VarUseNode variable, ExprNode *expr, string declType) :
-        variable(variable),
-        expr(expr),
-        declType(declType)
-{
-    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
-}
-
-// C++ Usage notes:
-//   When an object is destroyed, either because it is on the stack, e.g. as a variable,
-//     or because it is on the free-store heap, the _destructor(s)_ for the object,
-//     including those for the superclass(es) and data fields, are called before
-//     the memory for the object is released for potential re-use
-//     (destructors are called for those fields as they are released,
-//     and the superclass destructor is used after the class' own destructor is done).
-//
-//   Note that _pointers_ do not have destructor methods, so while e.g. when a "+" node
-//     goes away, the "string o" data field in the ArithmeticNode will automatically run,
-//     but nothing happens (by default) for the trees _pointed_to_ by "subexps".
-//     (ArithmeticNode's destructor also runs, of course, and so _it_ may take care of subexps)
-
-ExprNode::~ExprNode()  // nothing to do, but this ensures all subclasses will have virtual destructors, which C++ likes
-{
-	alloc_trace << " superclass ExprNode destructor   called for node at memory " << this << "]" << endl;
-}
-
-IntLiteralNode::~IntLiteralNode()
-{
-	alloc_trace << " class IntLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
-	// nothing needs to be done here,
-	//  except for tracing we could have omitted this.
-}
-
-BoolLiteralNode::~BoolLiteralNode()
-{
-    alloc_trace << " class BoolLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
-    // nothing needs to be done here,
-    //  except for tracing we could have omitted this.
-}
-
-#if FREE_AST_VIA_DESTRUCTORS
-
-// Memory management strategy:
-//   In a _Tree_, we know that any node will have at most one parent.
-//   Since the parser returns a pointer to the _root_,
-//     and no methods give access to any node's child pointers,
-//     we know that, when the root goes away, all the sub-trees can go away too.
-//   So, when the main program "delete"s the root,
-//     that will trigger the root's destructor; if that delete's any tree children,
-//     the whole thing will then be destroyed recursively.
-
-// Note that no destructor is needed for "IntLiteralNode".
-//   It has no subtrees, and data fields go away automatically when the node is deleted
-
-// In contrast, a ComparisonNode has subtree pointers "left" and "right".
-//   When we delete a ComparisonNode, those _pointers_ go away,
-//   but the trees on the free-store heap will last until we delete them.
-//   Since, as noted, we know there are no other pointers to them,
-//   we delete them when the ComparisonNode goes away:
-
-ComparisonNode::~ComparisonNode()
-{
-	alloc_trace << " class ComparisonNode  destructor called for node at memory " << this << ")" << endl;
-
-	delete left;
-	delete right;
-}
-
-void deleteAllSubtrees(list<ExprNode *>subtrees)
-{
-	if (!empty(subtrees)) {
-		delete head(subtrees);
-		deleteAllSubtrees(rest(subtrees));
-	}
-}
-
-ArithmeticNode::~ArithmeticNode()
-{
-	alloc_trace << " class ArithmeticNode  destructor called for node at memory " << this << ")" << endl;
-	
-	deleteAllSubtrees(subexps);
-}
-
-VarUseNode::~VarUseNode()
-{
-	alloc_trace << " class     VarUseNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-CallNode::~CallNode()
-{
-	alloc_trace << " class       CallNode  destructor called for node at memory " << this << ")" << endl;
-	
-	deleteAllSubtrees(argList);
-}
-
-IfNode::~IfNode()
-{
-    alloc_trace << " class     IfNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-LetNode::~LetNode()
-{
-    alloc_trace << " class     LetNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-DeclarationsNode::~DeclarationsNode()
-{
-    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-DeclarationNode::~DeclarationNode()
-{
-    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
-}
-
-#endif
diff --git a/Compiler/AST.h b/Compiler/AST.h
deleted file mode 100644
index c141d1ca1d54fa3a77ac7a8c4d0441da3b78cdc8..0000000000000000000000000000000000000000
--- a/Compiler/AST.h
+++ /dev/null
@@ -1,245 +0,0 @@
-#ifndef AST_H_
-#define AST_H_
-
-#include <string>
-#include <hc_list.h>
-#include "ContextInfo.h"
-#include "Dictionary.h"
-
-
-/*
- *  This file defines the heirarchy of different kinds of AST nodes.
- *  Currently we have:
- *    ExprNode (an "interface" class for expressions, with the following concrete subclasses ("implementers" of the interface):
- *	IntLiteralNode(int value)
- *	ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs)
- *	ArithmeticNode(std::string op, list<ExprNode *>)
- *	VarUseNode(std::string name)
- *	CallNode(std::string name, HaverfordCS::list<ExprNode *>arguments)
- *
- *  The "generateHERA" methods are usually called by calling generateFullHERA on the root,
- *      which puts "CBON" at the start.
- */
-
-#if ! defined FREE_AST_VIA_DESTRUCTORS
-#define FREE_AST_VIA_DESTRUCTORS true
-#endif
-
-// C++ Usage Note:
-// The empty class definition of ContextInfo below lets us declare "const ContextInfo &" parameters
-//   without having to define the whole class here, which is fine because, at this point,
-//   we don't care much about what's in it ... we just need to know that there's some way
-//   to pass information down to the subtrees as we evaluate them.
-
-
-// Define the information will we need to pass down the tree as we generate code, see ContextInfo.h
-class ContextInfo;
-
-extern Dictionary declarationDict;
-
-// C++ Usage Note:
-//
-// The word "virtual" is needed in C++ when inheritance is use,
-//   to explicitly tell the compiler that we might override a function in a subclass
-// Java has the correct default of allowing this, and the keyword "final" prevents it.
-//   Many C++ compilers fail to complain if you forget the word "virtual" and override a method anyway :-(
-//
-// Putting "= 0" at the end of a virtual function declaration means
-//   that the method _must_ be overridden in subclasses
-//
-// Classes with virtual functions and (in subclasses) data with destructors need to have
-//  virtual destructors, to help the C++ compiler be sure the right data destructors are called
-
-
-// Class ExprNode is an interface that defines the methods that all
-//   expression nodes in our AST will provide
-// C++ does not have Java's "interface" keyword, so instead
-//   we just create a superclass with no data and all functions virtual
-
-class ExprNode {
-public:
-	ExprNode();           // just used for memory allocation labs, to print trace information
-	virtual ~ExprNode();  // used for actual memory allocation, sometimes, and for tracing
-
-    virtual std::string generateHERA(const ContextInfo &info) const = 0;
-    virtual std::string getType() const = 0;
-
-    ExprNode* operator==(ExprNode *other) {
-        this->type = other->type;
-        return this;
-    }
-private:
-    std::string type;
-};
-
-std::string generateFullHERA(ExprNode *presumedRoot);
-
-
-
-// Now, the various specific kinds of expressions we might have:
-
-class IntLiteralNode : public ExprNode {
-	public:
-		IntLiteralNode(int value);
-		~IntLiteralNode();  // just used for trace output
-
-        int getValue() const { return v; }
-        std::string getType() const { return type; }
-
-		std::string generateHERA(const ContextInfo &info) const;
-	private:
-		int v;  // the value
-        const std::string type = "IntLiteralNode";
-};
-
-class BoolLiteralNode : public ExprNode {
-public:
-    BoolLiteralNode(std::string value);
-    ~BoolLiteralNode();  // just used for trace output
-
-    int getValue() const { return v; }
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    int v;  // the value
-    const std::string type = "BoolLiteralNode";
-};
-
-class ComparisonNode : public ExprNode {  // <= etc., _inherently_binary_ in HaverRacket
-public:
-    ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs);
-#if FREE_AST_VIA_DESTRUCTORS
-    ~ComparisonNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    std::string o;
-    ExprNode *left;
-    ExprNode *right;
-    const std::string type = "ComparisonNode";
-};
-
-class ArithmeticNode : public ExprNode {  // +, *, -, etc.
-	public:
-		ArithmeticNode(std::string op, HaverfordCS::list<ExprNode *>);
-#if FREE_AST_VIA_DESTRUCTORS
-		~ArithmeticNode();
-#endif
-        std::string getType() const { return type; }
-
-        std::string generateHERA(const ContextInfo &info) const;
-	private:
-		std::string o;
-		HaverfordCS::list<ExprNode *>subexps;
-        const std::string type = "ArithmeticNode";
-};
-
-/*
-   This represents the use of an identifier as an expression, e.g. the x in (* x 6).
-   Note that identifiers also exist in variable declarations, e.g. (let ((x 7)) ... )
-     but the x there doesn't count as an _expression_ since we're not asking for its value.
- */
-class VarUseNode : public ExprNode {
-	public:
-		VarUseNode(std::string name);
-		~VarUseNode();
-
-        std::string getValue() const { return n; }
-        std::string getType() const { return type; }
-
-        std::string generateHERA(const ContextInfo &info) const;
-	private:
-		std::string n;
-        const std::string type = "VarUseNode";
-};
-
-
-class CallNode : public ExprNode {
-	public:
-		CallNode(std::string funcName, HaverfordCS::list<ExprNode *>arguments);
-#if FREE_AST_VIA_DESTRUCTORS
-		~CallNode();
-#endif
-        std::string getType() const { return type; }
-
-        std::string generateHERA(const ContextInfo &info) const;
-	private:
-		std::string n;  // the name
-		HaverfordCS::list<ExprNode *>argList;
-        const std::string type = "CallNode";
-};
-
-class IfNode : public ExprNode {
-public:
-    IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse);
-#if FREE_AST_VIA_DESTRUCTORS
-    ~IfNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    ExprNode *condition;
-    ExprNode *expriftrue;
-    ExprNode *expriffalse;
-    const std::string type = "IfNode";
-};
-
-class DeclarationsNode : public ExprNode {
-public:
-    DeclarationsNode(HaverfordCS::list<ExprNode *> declarations);
-    HaverfordCS::list<ExprNode *> getDeclarations();
-    std::string declarationsHelper(std::string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const;
-#if FREE_AST_VIA_DESTRUCTORS
-    ~DeclarationsNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    HaverfordCS::list<ExprNode *> declarations;
-    const std::string type = "DeclarationsNode";
-};
-
-class DeclarationNode : public ExprNode {
-public:
-    DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType);
-    DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType);
-    DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType);
-    DeclarationNode(VarUseNode variable, ExprNode *expr, string declType);
-#if FREE_AST_VIA_DESTRUCTORS
-    ~DeclarationNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-private:
-    VarUseNode variable;
-    VarUseNode definedVar = VarUseNode("defaultVar");
-    std::string declType;
-    IntLiteralNode intLiteral = IntLiteralNode(0);
-    BoolLiteralNode boolLiteral = BoolLiteralNode("#f");
-    ExprNode *expr = new IntLiteralNode(0);
-    const std::string type = "DeclarationNode";
-};
-
-class LetNode : public ExprNode {
-public:
-    LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions);
-#if FREE_AST_VIA_DESTRUCTORS
-    ~LetNode();
-#endif
-    std::string getType() const { return type; }
-
-    std::string generateHERA(const ContextInfo &info) const;
-    std::string expressionsHelper(std::string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const;
-    private:
-    ExprNode *declarations;
-    HaverfordCS::list<ExprNode *> expressions;
-    const std::string type = "LetNode";
-};
-
-#endif /*AST_H_*/
diff --git a/Compiler/CMakeLists.txt b/Compiler/CMakeLists.txt
deleted file mode 100755
index 062dc130adcaafeef166e748f727927ef412fda0..0000000000000000000000000000000000000000
--- a/Compiler/CMakeLists.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-cmake_minimum_required(VERSION 3.1)
-project(Compiler_C++)
-
-set(CMAKE_CXX_STANDARD 20)
-
-add_executable(Compiler_C++
-  scanner-regexp
-  scanner
-  scannerDemo
-  parser
-  AST
-  ContextInfo
-  generateHERA
-  main
-  Dictionary
-)
-
-include_directories(../HaverfordCS/include /home/courses/include)
diff --git a/Compiler/ContextInfo.cc b/Compiler/ContextInfo.cc
deleted file mode 100644
index 30bffca0697ed8a4f056bf899bbafcae2864f5dc..0000000000000000000000000000000000000000
--- a/Compiler/ContextInfo.cc
+++ /dev/null
@@ -1,46 +0,0 @@
-#include "ContextInfo.h"
-#include <string.h>
-
-// To provide unique register numbers for each subexpression, with leftmost-executed-first
-//   we'll start with 1 at the root, make the rightmost child's number same as its parent,
-//   and make each other child one more than the sibling to its right.
-
-static const int minRegNum= 1;  // Lowest  register number we're going to use
-static const int maxRegNum=10;  // Highest register number we're going to use
-static const char labeler[] = "abcdefghijklmnopqrstuvwxyz";
-std::string label;
-
-ContextInfo::ContextInfo():
-	myRegNumber(maxRegNum)
-{
-}
-
-// Private constructor for use in e.g. evalThisFirst
-ContextInfo::ContextInfo(int r):
-	myRegNumber(r)
-{
-}
-
-ContextInfo ContextInfo::evalThisAfter() const
-{
-	if (myRegNumber <= minRegNum) {
-		throw "Out of register numbers, expression to complicated";
-	}
-	return ContextInfo(this->myRegNumber-1);
-}
-
-std::string ContextInfo::getReg() const
-{
-	return "R"+std::to_string(myRegNumber);
-}
-
-std::string ContextInfo::labelfunc() const
-{
-    std::string label = "";
-    return label + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26];
-}
-
-std::string ContextInfo::getLabel() const
-{
-    return label;
-}
diff --git a/Compiler/ContextInfo.h b/Compiler/ContextInfo.h
deleted file mode 100644
index 7b17f253d940e1e9f8b451530aaf436d4b77c927..0000000000000000000000000000000000000000
--- a/Compiler/ContextInfo.h
+++ /dev/null
@@ -1,22 +0,0 @@
-#include <string>
-#ifndef CONTEXT_INFO
-#define CONTEXT_INFO
-class ContextInfo {
-public:
-	ContextInfo(); // create an empty one, appropriate for the TOP of a parse tree
-
-	ContextInfo evalThisAfter() const; // create another context for something to be evaluated later
-
-	std::string getReg() const;
-	std::string labelfunc() const;
-    std::string getLabel() const;
-private:
-	// "myRegNumber" will tell each expression what register number they should use for their result
-	//  should generally be different for the subexpressions of a node,
-	//  and if X is evalualuated before Y, it should have a higher number.
-
-	ContextInfo(int myRegNum);  // called by e.g. evalThisFirst, to build new contexts
-	int myRegNumber;
-	std::string label = labelfunc();
-};
-#endif //CONTEXT_INFO
\ No newline at end of file
diff --git a/Compiler/Dictionary.cpp b/Compiler/Dictionary.cpp
deleted file mode 100644
index 6c3416da026a2490ddf986e501ec7c15fee7f317..0000000000000000000000000000000000000000
--- a/Compiler/Dictionary.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-//
-// Created by Keith_Mburu on 3/15/2021.
-//
-
-#include "Dictionary.h"
-
-// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
-/**
- * method that recurses through dictionary checking for entry
- *
- * @return true or false
- */
-bool Dictionary::containsHelper (const list<pair<string,int>> &dList, const string &entry) {
-    if (empty(dList)) {
-        return false;
-    }
-    else {
-        if ((get<0>(head(dList)) == entry)) {
-            return true;
-        }
-        return containsHelper(rest(dList), entry);
-    }
-}
-
-/**
- * method that checks if entry is in dictionary
- *
- * @return true or false
- */
-bool Dictionary::contains (const string &entry) {
-    return containsHelper(getList(), entry);
-}
-
-// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
-/**
- * method that recurses through dictionary until it finds and returns integer assigned to entry
- *
- * @param entry string being looked up
- * @param dList dictionary data field
- * @return the integer
- */
-int Dictionary::lookupHelper (const list<pair<string,int>> &dList, const string &entry) {
-    if (empty(dList)) {
-        return -1;
-    }
-    else if ((get<0>(head(dList)) == entry)) {
-        return get<1>(head(dList));
-    }
-    return lookupHelper(rest(dList), entry);
-}
-
-/**
- * method that checks the integer assigned to entry of dictionary
- *
- * @param entry string being looked up
- * @return the integer
- */
-int Dictionary::lookup (const string &entry) {
-    return lookupHelper(getList(), entry);
-}
-
-/**
- * method that converts dictionary to the string that constructs it
- *
- * @return the string
- */
-string Dictionary::toCode () {
-    if (empty(dictList)) {
-        return "Dictionary()\n";
-    }
-    list<pair<string, int>> temp = dictList;
-    string dictCode = "Dictionary()";
-    for (int i = 0; i < length(dictList); i++) {
-        // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
-        dictCode = "Dictionary(" + dictCode + ", \"" + get<0>(first(temp)) + "\", " + to_string(get<1>(first(temp))) +
-                ")";
-        temp = rest(temp);
-    }
-    return dictCode;
-}
-
-/**
- * method that adds new entry to dictionary by constructing new data field
- *
- * @param entry string to be added
- * @param integer integer assigned to the string
- */
-void Dictionary::add (string entry, int integer) {
-    list<pair<string, int>> newList = list<pair<string, int>>(pair<string, int>(entry, integer), dictList);
-    dictList = newList;
-}
-
-// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
-/**
- * method that builds new dictionary data field with redefined entry
- *
- * @return true if successful
- */
-bool Dictionary::replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int
-integer) {
-    if (empty(dList)) {
-        // finished recursion, now replace dictionary data field
-        setList(newList);
-        return true;
-    }
-    if ((get<0>(head(dList)) == entry)) {
-        newList = list<pair<string, int>>(pair<string, int>(get<0>(head(dList)), integer), newList);
-        // continue recursing to build the rest of the dictionary
-        return replaceHelper(newList, rest(dList), entry, integer);
-    }
-    newList = list<pair<string, int>>(head(dList), newList);
-    return replaceHelper(newList, rest(dList), entry, integer);
-}
-
-/**
- * method that replaces the integer assigned to an entry of a dictionary
- *
- * @return true if the replacement was successful
- */
-bool Dictionary::replace (const string &entry, int integer) {
-    replaceHelper(list<pair<string, int>>(), getList(), entry, integer);
-}
-
-
diff --git a/Compiler/Dictionary.h b/Compiler/Dictionary.h
deleted file mode 100644
index 3696da9d645c34ecf1fbc5f519c9a829818955ce..0000000000000000000000000000000000000000
--- a/Compiler/Dictionary.h
+++ /dev/null
@@ -1,101 +0,0 @@
-//
-// Created by Keith_Mburu on 3/15/2021.
-//
-
-#ifndef DICTIONARY_H
-#define DICTIONARY_H
-
-#include <hc_list.h>
-#include <hc_list_helpers.h>
-#include <utility>
-
-using namespace HaverfordCS;
-using namespace std;
-
-/**
- * class that instantiates dictionary with string : integer entries
- *
- * @author Keith Mburu
- * @version 3/24/2021
- */
-class Dictionary {
-
-public:
-
-    /**
-     * constructor method for empty dictionary
-     */
-    Dictionary() {
-        dictList = list<std::pair<string,int>>();
-    }
-
-    /**
-     * constructor method for new dictionary with old dictionary plus new entry
-     *
-     * @param oldDict old dictionary
-     * @param entry string to be added to old dictionary
-     * @param integer integer to be assigned to new entry
-     */
-    Dictionary(const Dictionary &oldDict, const string &entry, const int &integer) {
-        dictList = list<pair<string,int>>(pair<string,int>(entry, integer), oldDict.dictList);
-    }
-
-    /**
-     * getter method for list that stores dictionary data
-     *
-     * @return list that stores dictionary data
-     */
-    list<pair<string,int>> getList() {
-        return dictList;
-    }
-
-    /**
-     * setter method for list that stores dictionary data
-     *
-     * @param newList list to replace dictionary list
-     */
-    void setList(list<pair<string, int>> newList) {
-        dictList = newList;
-    }
-
-    // learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
-    // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
-    /**
-     * method that accumulates dictionary entries in string
-     *
-     * @return string containing dictionary entries
-     */
-    string toStringHelper(const list<pair<string,int>> &dictList, string dictString) {
-        if (empty(rest(dictList))) {
-            return dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList)));
-        }
-        dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList))) + "\n";
-        return toStringHelper(rest(dictList), dictString);
-    }
-
-    /**
-     * method that represents dictionary as a string
-     *
-     * @return string containing dictionary entries
-     */
-    string toString() {
-        return toStringHelper(getList(), "");
-    }
-
-    // other methods defined in Dictionary.cpp
-    int lookup (const string &entry);
-    int lookupHelper (const list<pair<string,int>> &dList, const string &entry);
-    bool contains (const string &entry);
-    bool containsHelper (const list<pair<string,int>> &dList, const string &entry);
-    void add (string entry, int integer);
-    bool replace (const string &entry, int integer);
-    bool replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int integer);
-    string toCode ();
-
-private:
-
-    list<pair<string,int>> dictList; // list that stores dictionary data
-
-};
-
-#endif
\ No newline at end of file
diff --git a/Compiler/README-Collaboration.txt b/Compiler/README-Collaboration.txt
deleted file mode 100644
index a4d117a958e7f176f9f498aed0dfc60aee767f99..0000000000000000000000000000000000000000
--- a/Compiler/README-Collaboration.txt
+++ /dev/null
@@ -1 +0,0 @@
-Working alone
\ No newline at end of file
diff --git a/Compiler/README-Design.txt b/Compiler/README-Design.txt
deleted file mode 100644
index 4545104538e0f6df575cb443d81afeccdbcf6821..0000000000000000000000000000000000000000
--- a/Compiler/README-Design.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-PLEASE DO NOT EDIT THIS PRELIMINARY VERISON OF THE FILE, TO AVOID GIT CONFLICTS LATER
- (if you're working before the update version is available, make a copy and edit that)
-
-Important Design Decisions:
-
-   * Sticking to node-based AST structure
-
-
-Project Status (T = code completed and test suite exists, C = code completed, P = in-progress, N = not started):
-
-   T  Parse + and * operations, constants and identifiers
-   T  Build an Object-Oriented AST from the above
-   T  Appropriately allocate registers for arithmetic operations
-   T  Generate HERA code for +, *, and constants
-
- ---- more will be added later ----
diff --git a/Compiler/README_Sources.txt b/Compiler/README_Sources.txt
deleted file mode 100644
index dcbdecf608edb7dcfa732b27c5506086a27df60d..0000000000000000000000000000000000000000
--- a/Compiler/README_Sources.txt
+++ /dev/null
@@ -1 +0,0 @@
-Copy assignment operators - https://en.cppreference.com/w/cpp/language/copy_assignment
\ No newline at end of file
diff --git a/Compiler/generateHERA.cc b/Compiler/generateHERA.cc
deleted file mode 100644
index fd07e5c355fe7202aca4775c9b4e485aeab6ab72..0000000000000000000000000000000000000000
--- a/Compiler/generateHERA.cc
+++ /dev/null
@@ -1,238 +0,0 @@
-#include "AST.h"
-#include "ContextInfo.h"
-#include "hc_list_helpers.h"
-#include "streams.h"
-
-using std::string;
-using std::endl;
-
-Dictionary declarationDict = Dictionary();
-int FPoffset = -1;
-
-std::string generateFullHERA(ExprNode *presumedRoot)
-{
-    return "\nCBON()\n" + presumedRoot->generateHERA(ContextInfo());
-}
-
-string IntLiteralNode::generateHERA(const ContextInfo &context) const
-{
-	trace << "Entered IntLiteralNode::generateHERA for integer " + std::to_string(v) << endl;
-	return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
-}
-
-string BoolLiteralNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered BoolLiteralNode::generateHERA for boolean " + std::to_string(v) << endl;
-    return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
-}
-
-std::string HERA_op(const std::string &AST_op_name)
-{
-	if (AST_op_name == "+") {
-		return "ADD";
-	} else if (AST_op_name == "-") {
-		return "SUB";
-	} else if (AST_op_name == "*") {
-		return "MUL";
-    } else if (AST_op_name == "=") {
-        return "CMP";
-    } else if (AST_op_name == ">=") {
-        return "CMP";
-    } else if (AST_op_name == "<=") {
-        return "CMP";
-	} else {
-		throw "Internal compiler inconsistency/incompleteness: HERA_op not implemented for " + AST_op_name;
-	}
-}
-
-string ComparisonNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered ComparisonNode::generateHERA for comparison " + o << endl;
-
-    // see arithmetic node for more about the "context" stuff:
-    //	trace << "need to compare the result of left-hand-side:\n" << left->generateHERA(context) << endl;
-    //	trace << "                        with right-hand-side:\n" << left->generateHERA(context.evalThisAfter()) << endl;
-
-    if (left->getType() != "CallNode" && right->getType() != "CallNode") {
-        if ((left->getType() != "IntLiteralNode" && left->getType() != "VarUseNode" && left->getType() != "LetNode") ||
-                (right->getType() != "IntLiteralNode" && right->getType() != "VarUseNode" && right->getType() != "LetNode")) {
-            cerr << endl << "!Type error! cannot perform comparison operations on non-integers" << endl;
-            exit(98);
-        }
-    }
-
-    ContextInfo rhsContext = context.evalThisAfter();
-    ContextInfo lhsContext = context;  // just named for symmetry
-
-    ContextInfo labelContext1 = ContextInfo();
-    ContextInfo endLabelContext = ContextInfo();
-
-    return left->generateHERA(lhsContext) +
-           right->generateHERA(rhsContext) +
-           HERA_op(o)+"("+lhsContext.getReg()+", "+rhsContext.getReg()+")\n" +
-           "BZ(" + context.getLabel() + ")\n" +
-            ((o == "=")? "SET(" + context.getReg() + ", " + "0)\n" :
-             (o == "<=" || o == ">=")? "BS(" + labelContext1.getLabel() + ")\n" : "") +
-            ((o == ">=")? "SET(" + context.getReg() + ", " + "1)\n" :
-             (o == "<=")? "SET(" + context.getReg() + ", " + "0)\n" : "") +
-            "BR(" + endLabelContext.getLabel() + ")\n" +
-            "LABEL(" + context.getLabel() + ")\n" +
-            "SET(" + context.getReg() + ", " + "1)\n" +
-            "BR(" + endLabelContext.getLabel() + ")\n" +
-            ((o == "<=" || o == ">=")? ("LABEL(" + labelContext1.getLabel() + ")\n" +
-            ((o == "<=")? "SET(" + context.getReg() + ", " + "1)\n" :
-             "SET(" + context.getReg() + ", " + "0)\n")) : "") +
-             "LABEL(" + endLabelContext.getLabel() + ")\n";
-}
-
-string ArithmeticNode::generateHERA(const ContextInfo &context) const
-{
-	trace << "Entered ArithmeticNode::generateHERA for operator " + o << endl;
-	if (length(subexps) != 2) {
-		throw "compiler incomplete/inconsistent: generateHERA not implemented for non-binary arithmetic";
-	}
-
-    if (first(subexps)->getType() != "CallNode" && first(rest(subexps))->getType() != "CallNode") {
-        if ((first(subexps)->getType() != "IntLiteralNode" && first(subexps)->getType() != "VarUseNode" && first(subexps)->getType() != "LetNode") ||
-                (first(rest(subexps))->getType() != "IntLiteralNode" && first(rest(subexps))->getType() != "VarUseNode" && first(rest(subexps))
-                ->getType() != "LetNode")) {
-            cerr << endl << "!Type error! cannot perform arithmetic operations on non-integers" << endl;
-            exit(99);
-        }
-    }
-
-	ContextInfo rhsContext = context.evalThisAfter();
-	ContextInfo lhsContext = context;  // just named for symmetry
-
-    string leftHERA = first(subexps)->generateHERA(lhsContext);
-    string rightHERA = first(rest(subexps))->generateHERA(rhsContext);
-
-    return  leftHERA + rightHERA + HERA_op(o)+"("+context.getReg()+", "+lhsContext.getReg()+", "+rhsContext.getReg()+")\n";
-}
-
-string VarUseNode::generateHERA(const ContextInfo &context) const
-{
-	trace << "Entered VarUseNode::generateHERA for variable " + n << endl;
-
-    return "LOAD(" + context.getReg() + ", " + to_string(declarationDict.lookup(n)) + ", FP)\n";
-}
-
-string CallNode::generateHERA(const ContextInfo &context) const
-{
-	trace << "Entered CallNode::generateHERA for call to " + n << endl;
-	
-	if (length(argList) != 0 || (n != "exit" && n != "getint")) {
-		throw "compiler incomplete/inconsistent: generateHERA for calls only implented for getint and exit";
-	}
-	// NOTE that calls to exit and getint don't need parameters and don't perturb registers
-	return ("MOVE(FP_alt, SP)\nCALL(FP_alt," + n + ")\n"+
-		(context.getReg()=="R1"?"":"MOVE("+context.getReg()+", R1)\n"));
-}
-
-string IfNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered IfNode::generateHERA" << endl;
-
-    if (expriftrue->getType() != "CallNode" && expriffalse->getType() != "CallNode") {
-        if (expriftrue->getType() != expriffalse->getType()) {
-            cerr << endl << "!Type error! \"then\" and \"else\" statements must be of the same type" << endl;
-            exit(45);
-        }
-    }
-
-    ContextInfo conditionContext = context;
-    ContextInfo expriftrueContext = context.evalThisAfter();
-    ContextInfo expriffalseContext = context.evalThisAfter().evalThisAfter();
-
-    ContextInfo labelContext1 = ContextInfo();
-    ContextInfo labelContext2 = ContextInfo();
-
-    string conditionHERA = condition->generateHERA(conditionContext);
-    string expriftrueHERA = expriftrue->generateHERA(expriftrueContext);
-    string expriffalseHERA = expriffalse->generateHERA(expriffalseContext);
-
-    return  conditionHERA + expriftrueHERA + expriffalseHERA +
-            "FLAGS(" + conditionContext.getReg() + ")\n" +
-            "BZ(" + labelContext1.getLabel() + ")\n" +
-            "MOVE(" + context.getReg() + ", " + expriftrueContext.getReg() + ")\n" +
-            "BR(" + labelContext2.getLabel() + ")\n" +
-            "LABEL(" + labelContext1.getLabel() + ")\n" +
-            "MOVE(" + context.getReg() + ", " + expriffalseContext.getReg() + ")\n" +
-            "LABEL(" + labelContext2.getLabel() + ")\n";
-}
-
-string LetNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered LetNode::generateHERA" << endl;
-    ContextInfo declarationsContext = context;
-    ContextInfo expressionsContext = context;
-
-    string expressionsHERA = "";
-    string declarationsHERA = declarations->generateHERA(declarationsContext);
-    expressionsHERA = expressionsHelper(expressionsHERA, expressions, expressionsContext);
-    return declarationsHERA + expressionsHERA;
-}
-
-string LetNode::expressionsHelper(string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const {
-    if (empty(expressions)) {
-        return expressionsHERA;
-    }
-    return expressionsHelper(expressionsHERA += first(expressions)->generateHERA(context), rest(expressions), context.evalThisAfter());
-}
-
-string DeclarationsNode::generateHERA(const ContextInfo &context) const
-{
-    trace << "Entered DeclarationsNode::generateHERA" << endl;
-    ContextInfo declarationsContext = context;
-
-    ContextInfo labelContext = ContextInfo();
-
-    string declarationsHERA = "";
-    return  declarationsHelper(declarationsHERA, declarations, context);
-}
-
-string DeclarationsNode::declarationsHelper(string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const {
-    if (empty(declarations)) {
-        return declarationsHERA;
-    }
-    return declarationsHelper(declarationsHERA += first(declarations)->generateHERA(context), rest(declarations),
-                              context);
-}
-
-string DeclarationNode::generateHERA(const ContextInfo &context) const
-{
-    auto literal = expr;
-    string value;
-    if (declType == "IntLiteralNode") {
-        *literal = intLiteral;
-        value = to_string(intLiteral.getValue());
-    }
-    else if (declType == "BoolLiteralNode") {
-        *literal = boolLiteral;
-        value = boolLiteral.getValue();
-    }
-    else if (declType == "definedVar") {
-        *literal = definedVar;
-        value = definedVar.getValue();
-    }
-
-    trace << "Entered DeclarationNode::generateHERA for declaration " + variable.getValue() + ((declType == "ExprNode")? " = expression" : " = " +
-    value) << endl;
-
-    if (declType == "definedVar") {
-        value = to_string(declarationDict.lookup(value));
-    }
-
-    FPoffset += 1;
-
-    declarationDict.add(variable.getValue(), FPoffset);
-
-    return ((declType == "ExprNode")? literal->generateHERA(context) :
-           (declType == "definedVar")? "LOAD(" + context.getReg() + ", " + value + ", FP)\n" :
-           "SET(" + context.getReg() + ", " + value + ")\n") +
-           "STORE(" + context.getReg() + ", " + std::to_string(FPoffset) + ", FP)\n";
-}
-
-
-
-
diff --git a/Compiler/main.cc b/Compiler/main.cc
deleted file mode 100644
index 1c612ebde989904917f118f2dd39f1e20d317dbb..0000000000000000000000000000000000000000
--- a/Compiler/main.cc
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * "Compiler" project for HaverRacket
- *  Translate a subset of Racket into HERA
- *
- * To run this project and run the program tests/01-multiply.hrk, use the command:
- *   Debug/Compiler-C++ < tests/01-multiply.hrk | tee Compiler.out
- * and then run the HERA program with the command
- *   HERA-C-Run Compiler.out
- */
-
-#include <iostream>
-#include <cstdlib>
-#include "scannerDemo.h"
-#include "parser.h"
-#include "ContextInfo.h"
-#include "hc_list_helpers.h" // ez_list
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-
-#include "streams.h"
-#include "Dictionary.h"
-
-// to change trace output, compile with
-//   e.g. -DTRACE_OUTPUT_HERE="./my-trace-output.txt"
-//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to throw away trace output
-//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to always use cerr
-//     or -DTRACE_OUTPUT_HERE=(getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
-//        # that last, the default (I hope) should allow run-time selection via e.g.,
-//        HAVERRACKET_TRACE=my-trace-output1.txt Debug/Compiler-C++
-//
-//  similarly for -DPROMPT_OUTPUT_HERE, which defaults to getenv("HAVERRACKET_PROMPT")
-//    note that prompt is not currently used, though
-
-#if ! defined TRACE_OUTPUT_HERE
-#define TRACE_OUTPUT_HERE (getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
-#endif
-#if ! defined PROMPT_OUTPUT_HERE
-#define PROMPT_OUTPUT_HERE (getenv("HAVERRACKET_PROMPT")?getenv("HAVERRACKET_PROMPT"):"/dev/stderr")
-#endif
-
-#include <fstream>  /* needed for ofstream below */
-std::ofstream _HaverRacket_trace(TRACE_OUTPUT_HERE);
-std::ostream &trace  = _HaverRacket_trace;
-std::ofstream _HaverRacket_prompt(PROMPT_OUTPUT_HERE);
-std::ostream &prompt = _HaverRacket_prompt;
-
-#if ! defined AbstractSyntaxTest
-#define AbstractSyntaxTest build_example1   /* this lets us use a different test easily with a special command line */
-#endif
-
-ParserResult AbstractSyntaxTest();
-
-int main(int numberOfCommandLineArguments, char *theCommandLineArguments[])
-{
-	try {
-		bool testScannerInstead = false;
-        if (numberOfCommandLineArguments == 2 && theCommandLineArguments[1] == string("testScannerInstead")) {
-			trace << "Testing Scanner instead." << endl;
-			testScannerInstead = true;
-		}
-
-		if (testScannerInstead) {
-			cout << "Demonstrating lexical scanner. Enter tokens followed by <EOF>." << endl;
-			scannerDemo();
-		} else {
-			if (!getenv("HAVERRACKET_TEST_CODE_HERA") ||
-			    getenv("HAVERRACKET_TEST_CODE_HERA") == string("#t"))
-			{
-				try {
-					ParserResult example1 = AbstractSyntaxTest();
-
-					trace << "confirming codegen basic functionality on test example1:" << endl;
-					string code = generateFullHERA(example1);
-					trace << code << endl;
-					delete example1;  // we're done with example1 now.
-
-				} catch (const char *message) {
-					cerr << "code generation confirmation test threw exception: " << message << endl;
-					return 2;
-				}
-			}
-
-            trace << "Type in new input!" << endl;
-
-            try {
-				ParserResult AST = matchStartSymbolAndEOF();
-//				trace << "Completed Parsing, got AST: " << AST.toCode() << endl;
-				try {
-                    trace << "\nNow generating code: " << endl;
-					trace << generateFullHERA(AST) << endl;
-				} catch (const char *message) {
-					cerr << "eval threw exception (typically an unhandled case): " << message << endl;
-					return 4;
-				}
-#if FREE_AST_VIA_DESTRUCTORS
-				delete AST;
-#endif
-			} catch (const char *message) {
-				cerr << "that's odd, parser threw exception: " << message << endl;
-				return 3;
-			}
-		}
-
-		return 0;  // indicate successful translation if no exit with non-0 before this
-	} catch (range_error) {
-		cerr << "Yikes! Uncaught exception" << endl;
-		return 66;
-	}
-}
-
-
-	    
-
-ParserResult build_example1()
-{
-//	ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new IntLiteralNode(3), new IntLiteralNode(7)));
-//    ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new BoolLiteralNode("#t"), new BoolLiteralNode("#f")));
-    ExprNode *product = new IfNode(new ComparisonNode("<=", new IntLiteralNode(6), new IntLiteralNode(7)), new BoolLiteralNode("#t"), new
-    BoolLiteralNode("#f"));
-
-    return product;
-/*
-  NOTE that the starter files ExprNode classes do _not_ support the following due to memory allocation techniques,
-    though it might seem at first to work:
-*/
-	// return new ArithmeticNode("+", HaverfordCS::ez_list<ExprNode *>(product, product));
-	// return new ComparisonNode("<=", product, product);
-}
-
diff --git a/Compiler/parser.cc b/Compiler/parser.cc
deleted file mode 100644
index 9d33bc188510041ae54ff68d34e4426a99d98e50..0000000000000000000000000000000000000000
--- a/Compiler/parser.cc
+++ /dev/null
@@ -1,241 +0,0 @@
-#include <iostream>
-#include <cstdlib>  // for 'exit' function to abandon the program
-#include <hc_list_helpers.h>
-#include "parser.h"
-#include "scanner.h"
-
-using std::string;
-using HaverfordCS::list;
-using HaverfordCS::ez_list;
-using std::cout;
-using std::cerr;
-using std::endl;
-
-#include "streams.h"
-
-// match this:
-// START -> E   <followed by end-of-input>
-// E -> integer
-// E -> boolean
-// E -> identifier
-// E -> ( E_IN_PARENS )
-// E? -> E E?
-// E? -> ""
-// E_IN_PARENS -> OP E E
-// E_IN_PARENS -> letstar E E E?
-// E_IN_PARENS -> [ E_IN_BRACKETS ] E_IN_PARENS
-// E_IN_PARENS -> ""
-// E_IN_PARENS -> EXIT
-// E_IN_PARENS -> GETINT   // New in this version, gets user input
-// E_IN_PARENS -> if E E E
-
-// E_IN_BRACKETS -> E E
-
-// OP --> +|-|*|<=|=|>= OP_COMPARE
-
-// Declare all functions, so they can call each other in any order
-//  (note: "static" means it's restricted to this scope, e.g. this file
-static ParserResult matchE();
-static ParserResult matchEInParens();
-static string matchOp();
-
-
-// FIRST and FOLLOW sets for those,
-//  built with lists rather than sets, for familiarity
-//  defined in terms of kindOfToken from scanner-regexp.h
-static list<kindOfToken> FIRST_OP  = ez_list(PLUS, MINUS, TIMES, OP_COMPARE);
-static list<kindOfToken> FIRST_EIP = FIRST_OP;
-static list<kindOfToken> FIRST_E   = ez_list(INT_LITERAL, BOOL_LITERAL, IDENTIFIER, LPAREN, LBRACKET);
-
-static list<kindOfToken> FOLLOW_OP  = FIRST_E;
-static list<kindOfToken> FOLLOW_EIP = ez_list(RPAREN);
-static list<kindOfToken> FOLLOW_E   = /* append(FOLLOW_EIP, FIRST_E) */
-		                              list<kindOfToken>(RPAREN, FIRST_E);
-	                                  /* Dave should put "append" into list_helpers */
-
-// first, some helpful functions:
-
-// mustGetNextToken:
-//    we call this when we need to get more input and we must find something there,
-//    i.e. when we want to move current_token along and end-of-input would be an error
-void mustGetNextToken()
-{
-	getNextToken();
-	if (!tokenAvailable()) {
-		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
-		exit(5);
-	}
-}
-
-
-// currentTokenThenMove
-//   record currentToken (which must NOT be end-of-input), then move past it, return what it was
-static std::string currentTokenThenMove()
-{
-	if (!tokenAvailable()) {
-		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
-		exit(5);
-	}
-	std::string curr = currentToken();
-	getNextToken();
-	return curr;
-}
-
-// confirmLiteral
-//   match a literal, assuming the token HAS been scanned already,
-//    i.e. that "currentToken" is _on_ the literal we wish to match
-//   leave "currentToken" on the very last token of the matched pattern ... this is not a "match" function
-static void confirmLiteral(string what)
-{
-	if (!tokenAvailable()) {
-		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
-		exit(5);
-	}
-	if (currentToken() != what) {
-		cerr << "got " << currentToken() << " instead of " << what << " at token #" << tokenNumber() << endl;
-		exit(2);
-	}	
-}
-
-
-// match an "E", i.e, anything on the right hand side of any "E-->..." production
-//  assume the first token of the E has been scanned
-//   (i.e., assuming currentToken is the first token of the "E" we're matching)
-//  leave "currentToken" AFTER the very last token of the matched pattern
-static ParserResult matchE()
-{
-	trace << "Entering matchE, current token is " << currentToken() << endl;
-	if (currentTokenKind() == INT_LITERAL) {
-        return new IntLiteralNode(std::stoi(currentTokenThenMove()));
-    } else if (currentTokenKind() == BOOL_LITERAL) {
-        return new BoolLiteralNode(currentTokenThenMove());
-	} else if (currentTokenKind() == IDENTIFIER) {
-        return new VarUseNode(currentTokenThenMove());
-	} else if (currentTokenKind() == LPAREN) {	
-		confirmLiteral("(");
-		mustGetNextToken();
-		ParserResult it = matchEInParens();
-		trace << "After matchEInParens, back in matchE, current token is: " << currentToken() << endl;
-		// if that left off AFTER the end of the E_IN_PARENS, we still need a ")" in the E we're matching
-		confirmLiteral(")");
-		getNextToken();	 // we're AFTER the ) now
-		return it;
-	} else {				
-		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
-		exit(3);
-	}
-}
-
-// match an "E_IN_PARENS",
-//  assuming that the currentToken is at the start of the E_IN_PARENS, e.g. a "+"
-//  leave the currentToken AFTER the last part of what was matched,
-//  i.e. *on* the ")" that should come after the E_IN_PARENS
-static ParserResult matchEInParens() {
-	trace << "Entering matchEInParens, current token is " << currentToken() << endl;
-	if (find(currentTokenKind(), FIRST_OP)) {
-        bool its_a_comparison_op = (currentTokenKind() == OP_COMPARE);
-        string theOp = matchOp();
-        ParserResult firstChild = matchE();
-        ParserResult secondChild = matchE();
-        if (its_a_comparison_op) { // a comparison
-            return new ComparisonNode(theOp, firstChild, secondChild);
-        } else {
-            return new ArithmeticNode(theOp, ez_list(firstChild, secondChild));
-        }
-    } else if (currentTokenKind() == LBRACKET) {
-        list<ExprNode *> declarations = list<ExprNode *>();
-	    while (currentTokenKind() != RPAREN) {
-            mustGetNextToken();
-            declarations = list(matchEinBrackets(), declarations);
-            confirmLiteral("]");
-            mustGetNextToken();
-        }
-	    return new DeclarationsNode(reverse(declarations, list<ExprNode *>()));
-    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "if") {
-	    mustGetNextToken();
-	    ParserResult condition = matchE();
-        ParserResult expriftrue = matchE();
-        ParserResult expriffalse = matchE();
-        return new IfNode(condition, expriftrue, expriffalse);
-    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "letstar") {
-        mustGetNextToken();
-        ParserResult declarations = matchE();
-        list<ExprNode *> expressions = list<ExprNode *>();
-        while (currentToken() != ")") {
-            expressions = list(matchE(), expressions);
-        }
-	    return new LetNode(declarations, reverse(expressions, list<ExprNode *>()));
-    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "exit") {
-		return new CallNode(currentTokenThenMove(), list<ParserResult>());
-	} else if (currentTokenKind() == IDENTIFIER && currentToken() == "getint") {
-		return new CallNode(currentTokenThenMove(), list<ParserResult>());
-	} else {
-		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
-		exit(3);
-	}
-}
-
-static ParserResult matchEinBrackets() {
-    if (currentTokenKind() == IDENTIFIER) {
-        VarUseNode variable = VarUseNode(currentTokenThenMove());
-        if (currentTokenKind() == IDENTIFIER) {
-            VarUseNode definedVar = VarUseNode(currentTokenThenMove());
-            return new DeclarationNode(variable, definedVar, "definedVar");
-        }
-        else if (currentTokenKind() == INT_LITERAL) {
-            IntLiteralNode literal = IntLiteralNode(stoi(currentTokenThenMove()));
-            return new DeclarationNode(variable, literal, "IntLiteralNode");
-        }
-        else if (currentTokenKind() == BOOL_LITERAL) {
-            BoolLiteralNode literal = BoolLiteralNode(currentTokenThenMove());
-            return new DeclarationNode(variable, literal, "BoolLiteralNode");
-        }
-        else if (currentTokenKind() == LPAREN) {
-            ParserResult expr = matchE();
-            return new DeclarationNode(variable, expr, "ExprNode");
-        }
-    }
-    std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
-    exit(3);
-}
-
-// match an operator, assuming that it is the currentToken
-//  leave the currentToken AFTER the last part of what was matched, i.e. unchanged
-static string matchOp()
-{
-	trace << "Entering matchOp, current token is " << currentToken() << endl;
-	// could do three cases here, but that's so tedious...
-	assert (find(currentTokenKind(), FIRST_OP));
-	return currentTokenThenMove();
-}
-
-
-ParserResult matchStartSymbolAndEOF()
-{
-	getNextToken();  // this will be the first one
-	if (!tokenAvailable()) {
-		cerr << "Illegal end of input" << endl;
-		exit(2);
-	}
-
-	ParserResult fullExpression = matchE();  // "E" is our start symbol
-
-	// now make sure there isn't anything else!
-	getNextToken();
-	if (tokenAvailable()) {
-		cerr << "Warning: extra input after end: " << currentToken() << endl;
-		exit (1);
-	}
-
-	return fullExpression;
-}
-
-list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList) {
-    if (empty(list)) {
-        return newList;
-    }
-    if (length(list) == 1) {
-        return ::list(first(list), newList);
-    }
-    return reverse(rest(list), ::list(first(list), newList));
-}
\ No newline at end of file
diff --git a/Compiler/parser.h b/Compiler/parser.h
deleted file mode 100644
index 15ffe20d1b1c102d511f9bad3e92f9cd7ee846ef..0000000000000000000000000000000000000000
--- a/Compiler/parser.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef PARSER_H_
-#define PARSER_H_
-
-
-#include "AST.h"
-
-// The typedef below makes the name "translatedResult"
-//  mean a "Tree" object from our Expr_Node type heirarchy.
-typedef ExprNode *ParserResult;
-
-ParserResult matchStartSymbolAndEOF();
-static ParserResult matchE();
-static ParserResult matchEinParens();
-static ParserResult matchEinBrackets();
-static std::string matchOp();
-list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList);
-
-#endif /*PARSER_H_*/
diff --git a/Compiler/scanner-regexp.cc b/Compiler/scanner-regexp.cc
deleted file mode 100644
index b7ad7688e6baab205aa96ba07e3ab106334e876a..0000000000000000000000000000000000000000
--- a/Compiler/scanner-regexp.cc
+++ /dev/null
@@ -1,1871 +0,0 @@
-
-#line 2 "<stdout>"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 4
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#ifndef SIZE_MAX
-#define SIZE_MAX               (~(size_t)0)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-/* begin standard C++ headers. */
-
-/* TODO: this is always defined, so inline it */
-#define yyconst const
-
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
-#else
-#define yynoreturn
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an
- *   integer in range [0..255] for use as an array index.
- */
-#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN (yy_start) = 1 + 2 *
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin  )
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
-#define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-extern int yyleng;
-
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-    
-    #define YY_LESS_LINENO(n)
-    #define YY_LINENO_REWIND_TO(ptr)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-#define unput(c) yyunput( c, (yytext_ptr)  )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	int yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = NULL;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart ( FILE *input_file  );
-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
-void yy_delete_buffer ( YY_BUFFER_STATE b  );
-void yy_flush_buffer ( YY_BUFFER_STATE b  );
-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state ( void );
-
-static void yyensure_buffer_stack ( void );
-static void yy_load_buffer_state ( void );
-static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
-#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
-
-void *yyalloc ( yy_size_t  );
-void *yyrealloc ( void *, yy_size_t  );
-void yyfree ( void *  );
-
-#define yy_new_buffer yy_create_buffer
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-typedef flex_uint8_t YY_CHAR;
-
-FILE *yyin = NULL, *yyout = NULL;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-int yylineno = 1;
-
-extern char *yytext;
-#ifdef yytext_ptr
-#undef yytext_ptr
-#endif
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state ( void );
-static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
-static int yy_get_next_buffer ( void );
-static void yynoreturn yy_fatal_error ( const char* msg  );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	(yy_c_buf_p) = yy_cp;
-#define YY_NUM_RULES 19
-#define YY_END_OF_BUFFER 20
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static const flex_int16_t yy_accept[33] =
-    {   0,
-        0,    0,   20,   18,    1,    2,    2,   18,    4,    5,
-       10,    8,    9,   15,    3,   18,   11,   18,   17,    6,
-        7,   16,   15,    3,   12,    0,   13,   17,    0,    0,
-       14,    0
-    } ;
-
-static const YY_CHAR yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    1,    5,    1,    1,    1,    1,    6,
-        7,    8,    9,    1,   10,    1,    1,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,    1,   12,   13,
-       14,   15,    1,    1,   16,   16,   16,   16,   17,   18,
-       16,   16,   16,   16,   16,   16,   16,   16,   19,   16,
-       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
-       20,    1,   21,    1,   22,    1,   23,   23,   23,   23,
-
-       23,   24,   23,   23,   23,   23,   23,   23,   23,   23,
-       23,   23,   23,   23,   23,   25,   23,   23,   23,   23,
-       23,   23,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static const YY_CHAR yy_meta[26] =
-    {   0,
-        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
-        3,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    3,    3,    3,    3
-    } ;
-
-static const flex_int16_t yy_base[35] =
-    {   0,
-        0,    0,   40,   41,   41,   41,   41,    2,   41,   41,
-       41,   41,   28,   27,    0,   14,   41,   23,    0,   41,
-       41,   41,   25,    0,   41,   16,   41,    0,   15,   15,
-       41,   41,   31,   26
-    } ;
-
-static const flex_int16_t yy_def[35] =
-    {   0,
-       32,    1,   32,   32,   32,   32,   32,   32,   32,   32,
-       32,   32,   32,   32,   33,   32,   32,   32,   34,   32,
-       32,   32,   32,   33,   32,   32,   32,   34,   32,   32,
-       32,    0,   32,   32
-    } ;
-
-static const flex_int16_t yy_nxt[67] =
-    {   0,
-        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
-       14,   15,   16,   17,   18,   19,   19,   19,   19,   20,
-       21,    4,   19,   19,   19,   22,   22,   25,   28,   31,
-       26,   24,   30,   24,   29,   23,   27,   23,   23,   32,
-        3,   32,   32,   32,   32,   32,   32,   32,   32,   32,
-       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
-       32,   32,   32,   32,   32,   32
-    } ;
-
-static const flex_int16_t yy_chk[67] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    8,    8,   16,   34,   30,
-       16,   33,   29,   33,   26,   23,   18,   14,   13,    3,
-       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
-       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
-       32,   32,   32,   32,   32,   32
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "scanner-regexp.l"
-#line 2 "scanner-regexp.l"
-/*
-
-   This is a lexical scanner specification for the "lex" (or "flex") language.
-   It can be translated into a "C++" file by running, in the project directory, the command
-
-    flex  -t scanner-regexp.l > scanner-regexp.cc
-
-
-   In this first section of the lex file (between %{ and %}),
-   we define C++ functions that will be used later in the actions of part 3.
-
-*/
-
-#include "scanner-regexp.h"
-
-// the code generated by the flex system requires we write this:
-extern "C" int yywrap()
-{
- return 1;
-}
-
-#line 484 "<stdout>"
-/* In this second section of the lex file (after the %}),
-   we can define variables in terms of regular expressions.
-   C-style comments (like this one) are also legal. */
-/* In the third section of the lex file (after the %%),
-   we can define the patterns for each token
-   in terms of regular expressions and the variables above,
-   and give the action (as C++ code) for each token.
-   Comments are legal only inside the actions. */
-#line 493 "<stdout>"
-
-#define INITIAL 0
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals ( void );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy ( void );
-
-int yyget_debug ( void );
-
-void yyset_debug ( int debug_flag  );
-
-YY_EXTRA_TYPE yyget_extra ( void );
-
-void yyset_extra ( YY_EXTRA_TYPE user_defined  );
-
-FILE *yyget_in ( void );
-
-void yyset_in  ( FILE * _in_str  );
-
-FILE *yyget_out ( void );
-
-void yyset_out  ( FILE * _out_str  );
-
-			int yyget_leng ( void );
-
-char *yyget_text ( void );
-
-int yyget_lineno ( void );
-
-void yyset_lineno ( int _line_number  );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap ( void );
-#else
-extern int yywrap ( void );
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-    
-    static void yyunput ( int c, char *buf_ptr  );
-    
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy ( char *, const char *, int );
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen ( const char * );
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput ( void );
-#else
-static int input ( void );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
-#define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		int n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK /*LINTED*/break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	yy_state_type yy_current_state;
-	char *yy_cp, *yy_bp;
-	int yy_act;
-    
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state(  );
-		}
-
-	{
-#line 38 "scanner-regexp.l"
-
-
-#line 713 "<stdout>"
-
-	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-yy_match:
-		do
-			{
-			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 33 )
-					yy_c = yy_meta[yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 41 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 40 "scanner-regexp.l"
-{ continue; }  /* do nothing with blank spaces */
-	YY_BREAK
-case 2:
-/* rule 2 can match eol */
-YY_RULE_SETUP
-#line 41 "scanner-regexp.l"
-{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 42 "scanner-regexp.l"
-{ continue; }  /* treat comments like other blank space */
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 44 "scanner-regexp.l"
-{ tokenCount++; return LPAREN; }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 45 "scanner-regexp.l"
-{ tokenCount++; return RPAREN; }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 46 "scanner-regexp.l"
-{ tokenCount++; return LBRACKET; }
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 47 "scanner-regexp.l"
-{ tokenCount++; return RBRACKET; }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 48 "scanner-regexp.l"
-{ tokenCount++; return PLUS; }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 49 "scanner-regexp.l"
-{ tokenCount++; return MINUS; }
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 50 "scanner-regexp.l"
-{ tokenCount++; return TIMES; }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 51 "scanner-regexp.l"
-{ tokenCount++; return OP_COMPARE; }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 52 "scanner-regexp.l"
-{ tokenCount++; return OP_COMPARE; }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 53 "scanner-regexp.l"
-{ tokenCount++; return OP_COMPARE; }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 55 "scanner-regexp.l"
-{ tokenCount++; return END_OF_INPUT; }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 57 "scanner-regexp.l"
-{ tokenCount++; return INT_LITERAL; }
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 58 "scanner-regexp.l"
-{ tokenCount++; return BOOL_LITERAL; }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 60 "scanner-regexp.l"
-{ tokenCount++; return IDENTIFIER; }
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 62 "scanner-regexp.l"
-{ scannerError(); continue; }
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 63 "scanner-regexp.l"
-ECHO;
-	YY_BREAK
-#line 866 "<stdout>"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_c_buf_p);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap(  ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of user's declarations */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	char *source = (yytext_ptr);
-	int number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			int num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc( (void *) b->yy_ch_buf,
-							 (yy_size_t) (b->yy_buf_size + 2)  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = NULL;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
-			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-		/* "- 2" to take care of EOB's */
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
-	}
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
-
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (void)
-{
-	yy_state_type yy_current_state;
-	char *yy_cp;
-    
-	yy_current_state = (yy_start);
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 33 )
-				yy_c = yy_meta[yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	int yy_is_jam;
-    	char *yy_cp = (yy_c_buf_p);
-
-	YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 33 )
-			yy_c = yy_meta[yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-	yy_is_jam = (yy_current_state == 32);
-
-		return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_UNPUT
-
-    static void yyunput (int c, char * yy_bp )
-{
-	char *yy_cp;
-    
-    yy_cp = (yy_c_buf_p);
-
-	/* undo effects of setting up yytext */
-	*yy_cp = (yy_hold_char);
-
-	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		int number_to_move = (yy_n_chars) + 2;
-		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
-					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		char *source =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
-
-		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
-
-		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-	(yytext_ptr) = yy_bp;
-	(yy_hold_char) = *yy_cp;
-	(yy_c_buf_p) = yy_cp;
-}
-
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap(  ) )
-						return 0;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer( yyin, YY_BUF_SIZE );
-	}
-
-	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
-	yy_load_buffer_state(  );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state(  );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree( (void *) b->yy_ch_buf  );
-
-	yyfree( (void *) b  );
-}
-
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
-
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state(  );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state(  );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state(  );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	yy_size_t num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		yy_size_t grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return NULL;
-
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = NULL;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b  );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (const char * yystr )
-{
-    
-	return yy_scan_bytes( yystr, (int) strlen(yystr) );
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param yybytes the byte buffer to scan
- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = (yy_size_t) (_yybytes_len + 2);
-	buf = (char *) yyalloc( n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yynoreturn yy_fatal_error (const char* msg )
-{
-			fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-    
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-int yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param _line_number line number
- * 
- */
-void yyset_lineno (int  _line_number )
-{
-    
-    yylineno = _line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param _in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  _in_str )
-{
-        yyin = _in_str ;
-}
-
-void yyset_out (FILE *  _out_str )
-{
-        yyout = _out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  _bdebug )
-{
-        yy_flex_debug = _bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = NULL;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = NULL;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = NULL;
-    yyout = NULL;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer( YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, const char * s2, int n )
-{
-		
-	int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (const char * s )
-{
-	int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size )
-{
-			return malloc(size);
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-		
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return realloc(ptr, size);
-}
-
-void yyfree (void * ptr )
-{
-			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 63 "scanner-regexp.l"
diff --git a/Compiler/scanner-regexp.h b/Compiler/scanner-regexp.h
deleted file mode 100644
index 5fa81c7468cafb661690537bdcabda0390bf56a7..0000000000000000000000000000000000000000
--- a/Compiler/scanner-regexp.h
+++ /dev/null
@@ -1,13 +0,0 @@
-enum kindOfToken {
-	END_OF_INPUT = 0,   // defined by flex system
-	LPAREN,	RPAREN,
-	PLUS,	MINUS,	TIMES,
-	OP_COMPARE,
-	INT_LITERAL, BOOL_LITERAL,
-	IDENTIFIER, LBRACKET,
-	RBRACKET
-};
-
-void scannerError(); /// define in whatever uses the regexp-based scanner
-
-extern int tokenCount;  // not static because the .l file needs it too
diff --git a/Compiler/scanner-regexp.l b/Compiler/scanner-regexp.l
deleted file mode 100644
index f8a896b4eecb04d6369f19286b40cb45f4ec73b3..0000000000000000000000000000000000000000
--- a/Compiler/scanner-regexp.l
+++ /dev/null
@@ -1,62 +0,0 @@
-%{
-/*
-
-   This is a lexical scanner specification for the "lex" (or "flex") language.
-   It can be translated into a "C++" file by running, in the project directory, the command
-
-    flex  -t scanner-regexp.l > scanner-regexp.cc
-
-
-   In this first section of the lex file (between %{ and %}),
-   we define C++ functions that will be used later in the actions of part 3.
-
-*/
-
-#include "scanner-regexp.h"
-
-// the code generated by the flex system requires we write this:
-extern "C" int yywrap()
-{
- return 1;
-}
-
-%}
-
-/* In this second section of the lex file (after the %}),
-   we can define variables in terms of regular expressions.
-   C-style comments (like this one) are also legal. */
-
-digit		[0-9]
-identifier	[a-zA-Z][a-z0-9_]*
-
-/* In the third section of the lex file (after the %%),
-   we can define the patterns for each token
-   in terms of regular expressions and the variables above,
-   and give the action (as C++ code) for each token.
-   Comments are legal only inside the actions. */
-
-%%
-
-[ \t]		{ continue; }  /* do nothing with blank spaces */
-[\n\r]		{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
-\;.*		{ continue; }  /* treat comments like other blank space */
-
-"("			{ tokenCount++; return LPAREN; }
-")"			{ tokenCount++; return RPAREN; }
-"["			{ tokenCount++; return LBRACKET; }
-"]"			{ tokenCount++; return RBRACKET; }
-"+"			{ tokenCount++; return PLUS; }
-"-"			{ tokenCount++; return MINUS; }
-"*"			{ tokenCount++; return TIMES; }
-"="			{ tokenCount++; return OP_COMPARE; }
-"<="			{ tokenCount++; return OP_COMPARE; }
-">="			{ tokenCount++; return OP_COMPARE; }
-
-"<EOF>"		{ tokenCount++; return END_OF_INPUT; }
-
--?{digit}+	  { tokenCount++; return INT_LITERAL; }
-(#t|#f)	  { tokenCount++; return BOOL_LITERAL; }
-
-{identifier}  { tokenCount++; return IDENTIFIER; }
-
-.			{ scannerError(); continue; }
diff --git a/Compiler/scanner.cc b/Compiler/scanner.cc
deleted file mode 100644
index 6914da3cb3772f259411ae765eb35f0dc8d6517b..0000000000000000000000000000000000000000
--- a/Compiler/scanner.cc
+++ /dev/null
@@ -1,82 +0,0 @@
-#include <iostream>
-#include <logic.h>
-#include "scanner.h"
-
-#if ! defined USE_YYLEX
-#define USE_YYLEX 1  /* Use the stuff from scanner-regexp.l by default */
-#endif
-
-using namespace std;
-
-int tokenCount = 0;  // not static because the .l file needs it too
-static bool endOfInput = false;
-static bool calledGetNextTokenAlready = false;
-static string current = "";
-static kindOfToken currentKind;
-
-// some things built into scanner-regexp.cc by the flex system:
-extern int yylex();
-extern char *yytext;  // C-style string
-
-
-string currentToken()
-{
-	precondition(calledGetNextTokenAlready);
-	precondition(tokenAvailable());
-	
-	return current;
-}
-enum kindOfToken currentTokenKind()
-{
-	precondition(calledGetNextTokenAlready);
-	precondition(tokenAvailable());
-
-	return currentKind;
-}
-
-bool tokenAvailable()
-{
-	precondition(calledGetNextTokenAlready);
-	
-	return !endOfInput;
-}
-
-int  tokenNumber()
-{
-	return tokenCount;
-}
-
-void getNextToken()
-{
-	if (calledGetNextTokenAlready && endOfInput) return;  // No soup for you!
-	
-	calledGetNextTokenAlready = true;
-#if USE_YYLEX
-	/// This interfaces with scanner-regexp.cc
-	/// remember to update it from scanner-regexp.l if that is changed!
-	currentKind = kindOfToken(yylex()); // yylex thinks it could return any int but we know better
-	if (currentKind == 0) {
-		endOfInput = true;
-		current      = "";
-	} else {
-		current      = yytext;
-	}
-#else
-	/// HERE IS THE OLD CODE, before I tried lex
-	if (endOfInput || !cin) {
-		endOfInput = true;
-	} else {
-		cin >> current;
-		if (cin && current != "<EOF>") {
-			tokenCount++;
-		} else {
-			endOfInput = true;
-		}
-	}
-#endif
-}
-
-void scannerError()
-{
-	cerr << "Error: illegal token: '" << yytext << "'\n";
-}
diff --git a/Compiler/scanner.h b/Compiler/scanner.h
deleted file mode 100644
index 4f5e847c7e37bc31c039d0689e8a4d61aa8e61da..0000000000000000000000000000000000000000
--- a/Compiler/scanner.h
+++ /dev/null
@@ -1,27 +0,0 @@
-#ifndef _SCANNER_H_
-#define _SCANNER_H_
-
-#include <string>
-#include "scanner-regexp.h"
-
-// A simple lexical scanner
-
-// return the current token
-//  precondition:     you have called getNextToken at least once
-//                and tokenAvialable did not return false
-std::string currentToken();
-enum kindOfToken currentTokenKind();
-
-// see if there is a token (return false for end-of-input or the special input <EOF>)
-//  precondition: you must have called getNextToken at least once
-bool tokenAvailable();
-
-// return the number of tokens scanned so far
-// precondition: true
-int  tokenNumber();
-
-// advance current token to the next input
-// precondition: true
-void getNextToken();
-
-#endif //_SCANNER_H_
diff --git a/Compiler/scannerDemo.cc b/Compiler/scannerDemo.cc
deleted file mode 100644
index 208c53d98c9e7123e7d493a23ac1b672511904a1..0000000000000000000000000000000000000000
--- a/Compiler/scannerDemo.cc
+++ /dev/null
@@ -1,16 +0,0 @@
-#include <iostream>
-#include "scanner.h"
-#include "scannerDemo.h"
-
-using std::cout;
-using std::endl;
-
-void scannerDemo()
-{
-	while (getNextToken(), tokenAvailable()) {
-		cout << "Token number " << tokenNumber() << " is ";
-		cout << "'" << currentToken() << "'";
-		cout << ", which is token kind " << kindOfToken(currentTokenKind()) << endl;
-	}
-	cout << "Reached end-of-file, now stopping!" << endl;
-}
diff --git a/Compiler/scannerDemo.h b/Compiler/scannerDemo.h
deleted file mode 100644
index 7a767af034dc466d09612dc1c35e571617d4b380..0000000000000000000000000000000000000000
--- a/Compiler/scannerDemo.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * scanner_demo.h
- *
- *  Created on: Oct 2, 2009
- *      Author: davew
- */
-
-#ifndef SCANNER_DEMO_H_
-#define SCANNER_DEMO_H_
-
-void scannerDemo();
-
-#endif /* SCANNER_DEMO_H_ */
diff --git a/Compiler/streams.h b/Compiler/streams.h
deleted file mode 100644
index 7fb6c59e608e66bc3c4191565ad9e58c63ec9bb3..0000000000000000000000000000000000000000
--- a/Compiler/streams.h
+++ /dev/null
@@ -1,3 +0,0 @@
-extern std::ostream &trace;
-extern std::ostream &prompt;
-// extern std::ostream &debug;  // could separate these if we had a reason to do so...
diff --git a/Compiler/tests/01-multiply.hrk b/Compiler/tests/01-multiply.hrk
deleted file mode 100644
index 93a3f65ef3836c85fd496c0688b7ac5ff194d3f8..0000000000000000000000000000000000000000
--- a/Compiler/tests/01-multiply.hrk
+++ /dev/null
@@ -1 +0,0 @@
-(* 6 7)
diff --git a/Compiler/tests/02-add-and-mult.hrk b/Compiler/tests/02-add-and-mult.hrk
deleted file mode 100644
index f35212807441cfcf33303be75c979f77563f03d1..0000000000000000000000000000000000000000
--- a/Compiler/tests/02-add-and-mult.hrk
+++ /dev/null
@@ -1 +0,0 @@
-(* (+ 2 5) (+ (+ 1 (* 2 1)) (+ 2 1)))
diff --git a/Compiler/tests/03-mult-input.hrk b/Compiler/tests/03-mult-input.hrk
deleted file mode 100644
index 06969783b8af0aba0d6bf02916955cdbb0cdb750..0000000000000000000000000000000000000000
--- a/Compiler/tests/03-mult-input.hrk
+++ /dev/null
@@ -1 +0,0 @@
-(* 3 (getint))
diff --git a/Compiler/tests/04-mult-exit.hrk b/Compiler/tests/04-mult-exit.hrk
deleted file mode 100644
index 7de54e54bb3b816fff8e9c3d353e35c6dbc78f48..0000000000000000000000000000000000000000
--- a/Compiler/tests/04-mult-exit.hrk
+++ /dev/null
@@ -1 +0,0 @@
-(* 3 (exit))
diff --git a/Compiler/tests/arithmetic or comparison operation type error.txt b/Compiler/tests/arithmetic or comparison operation type error.txt
deleted file mode 100644
index 74171143e261de0bc3b254b650af40c193bedf3e..0000000000000000000000000000000000000000
--- a/Compiler/tests/arithmetic or comparison operation type error.txt	
+++ /dev/null
@@ -1 +0,0 @@
-( <= 4 #f ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/comparison.txt b/Compiler/tests/comparison.txt
deleted file mode 100644
index 8bdf47dbd9ea3f0bc1319e04feb58aee6c3ce058..0000000000000000000000000000000000000000
--- a/Compiler/tests/comparison.txt
+++ /dev/null
@@ -1 +0,0 @@
-( <= 4 5 ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if type error.txt b/Compiler/tests/if type error.txt
deleted file mode 100644
index 60dca31173babb20287ac03e8cda9f9669101989..0000000000000000000000000000000000000000
--- a/Compiler/tests/if type error.txt	
+++ /dev/null
@@ -1 +0,0 @@
-(if #t 3 h) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if.txt b/Compiler/tests/if.txt
deleted file mode 100644
index 0fbbcb19e4e2929c3eaa6d30d03260f63901f1bb..0000000000000000000000000000000000000000
--- a/Compiler/tests/if.txt
+++ /dev/null
@@ -1 +0,0 @@
-(if #t (if #f 2 3) (if #t 4 5)) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/let.txt b/Compiler/tests/let.txt
deleted file mode 100644
index 3fe340a7484f889f26288b6a1175d4a6373d5e93..0000000000000000000000000000000000000000
--- a/Compiler/tests/let.txt
+++ /dev/null
@@ -1 +0,0 @@
-(+ (letstar ( [x 1] [y 2] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/letstar.txt b/Compiler/tests/letstar.txt
deleted file mode 100644
index 366eb923d0f93ca9fdb2006108e0a168112eb779..0000000000000000000000000000000000000000
--- a/Compiler/tests/letstar.txt
+++ /dev/null
@@ -1 +0,0 @@
-(+ (letstar ( [x 3] [y x] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested let.txt b/Compiler/tests/nested let.txt
deleted file mode 100644
index 17e52566013a6c055a7c8ad9fbb3ae9b235f7ece..0000000000000000000000000000000000000000
--- a/Compiler/tests/nested let.txt	
+++ /dev/null
@@ -1 +0,0 @@
-(+ (letstar ( [x 1] [y 2] ) (+ x (letstar ( [z 3] [y 4] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested letstar.txt b/Compiler/tests/nested letstar.txt
deleted file mode 100644
index 8808cc7ddf8d4f32094aa7e973959b70d9441474..0000000000000000000000000000000000000000
--- a/Compiler/tests/nested letstar.txt	
+++ /dev/null
@@ -1 +0,0 @@
-(+ (letstar ( [x 4] [y 2] ) (+ x (letstar ( [z y] [y x] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file

From f5af1e4e37a4303dde37dd4c54878aa95baa4ffa Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 15:55:21 +0300
Subject: [PATCH] getint, exit corner case

---
 Compiler | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Compiler b/Compiler
new file mode 160000
index 0000000000000000000000000000000000000000..a0339f4fd01790127bc51fc1da091d5742115811
--- /dev/null
+++ b/Compiler
@@ -0,0 +1 @@
+Subproject commit a0339f4fd01790127bc51fc1da091d5742115811

From 9774cc3faddee9cf546b17f36e166a90394cff1b Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 16:06:15 +0300
Subject: [PATCH] rm submodule

---
 Compiler | 1 -
 1 file changed, 1 deletion(-)

diff --git a/Compiler b/Compiler
deleted file mode 160000
index a0339f4fd01790127bc51fc1da091d5742115811..0000000000000000000000000000000000000000
--- a/Compiler
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit a0339f4fd01790127bc51fc1da091d5742115811

From 4644df7aafa70b8157e5746ab85e83f41d2c7b28 Mon Sep 17 00:00:00 2001
From: kmburu <keithmburu1@gmail.com>
Date: Mon, 18 Jul 2022 16:51:07 +0300
Subject: [PATCH] getint, exit corner case

---
 Compiler/.cproject                                 |   72 +
 Compiler/.gitignore                                |    8 +
 Compiler/.project                                  |   82 +
 Compiler/AST.cc                                    |  242 +++
 Compiler/AST.h                                     |  245 +++
 Compiler/CMakeLists.txt                            |   18 +
 Compiler/ContextInfo.cc                            |   46 +
 Compiler/ContextInfo.h                             |   22 +
 Compiler/Dictionary.cpp                            |  124 ++
 Compiler/Dictionary.h                              |  101 ++
 Compiler/README-Collaboration.txt                  |    1 +
 Compiler/README-Design.txt                         |   16 +
 Compiler/README_Sources.txt                        |    1 +
 Compiler/generateHERA.cc                           |  238 +++
 Compiler/main.cc                                   |  132 ++
 Compiler/parser.cc                                 |  241 +++
 Compiler/parser.h                                  |   18 +
 Compiler/scanner-regexp.cc                         | 1871 ++++++++++++++++++++
 Compiler/scanner-regexp.h                          |   13 +
 Compiler/scanner-regexp.l                          |   62 +
 Compiler/scanner.cc                                |   82 +
 Compiler/scanner.h                                 |   27 +
 Compiler/scannerDemo.cc                            |   16 +
 Compiler/scannerDemo.h                             |   13 +
 Compiler/streams.h                                 |    3 +
 Compiler/tests/01-multiply.hrk                     |    1 +
 Compiler/tests/02-add-and-mult.hrk                 |    1 +
 Compiler/tests/03-mult-input.hrk                   |    1 +
 Compiler/tests/04-mult-exit.hrk                    |    1 +
 ...ithmetic or comparison operation type error.txt |    1 +
 Compiler/tests/comparison.txt                      |    1 +
 Compiler/tests/if type error.txt                   |    1 +
 Compiler/tests/if.txt                              |    1 +
 Compiler/tests/let.txt                             |    1 +
 Compiler/tests/letstar.txt                         |    1 +
 Compiler/tests/nested let.txt                      |    1 +
 Compiler/tests/nested letstar.txt                  |    1 +
 37 files changed, 3706 insertions(+)

diff --git a/Compiler/.cproject b/Compiler/.cproject
new file mode 100644
index 0000000000000000000000000000000000000000..909e19a7e90ca0f6e31541b0d3f726a9ead5b304
--- /dev/null
+++ b/Compiler/.cproject
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="cdt.managedbuild.config.gnu.exe.debug.1161916250">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" moduleId="org.eclipse.cdt.core.settings" name="Debug">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.MakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactExtension="" artifactName="Compiler-C++" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" errorParsers="org.eclipse.cdt.core.MakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.GASErrorParser" id="cdt.managedbuild.config.gnu.exe.debug.1161916250" name="Debug" parent="cdt.managedbuild.config.gnu.exe.debug">
+					<folderInfo id="cdt.managedbuild.config.gnu.exe.debug.1161916250.1127859407" name="/" resourcePath="">
+						<toolChain id="cdt.managedbuild.toolchain.gnu.exe.debug.1737210637" name="GCC Tool Chain" superClass="cdt.managedbuild.toolchain.gnu.exe.debug">
+							<targetPlatform id="cdt.managedbuild.target.gnu.platform.exe.debug.1043903385" name="Debug Platform" superClass="cdt.managedbuild.target.gnu.platform.exe.debug"/>
+							<builder buildPath="${workspace_loc:/Interpreter-C++/Debug}" id="cdt.managedbuild.target.gnu.builder.exe.debug.1885040107" keepEnvironmentInBuildfile="false" name="Gnu Make Builder" superClass="cdt.managedbuild.target.gnu.builder.exe.debug"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug.1315278191" name="GCC C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.exe.debug">
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.compiler.option.include.paths.668525549" name="Include paths (-I)" superClass="gnu.cpp.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
+									<listOptionValue builtIn="false" value="/home/courses/include"/>
+								</option>
+								<option id="gnu.cpp.compiler.exe.debug.option.optimization.level.793100283" name="Optimization Level" superClass="gnu.cpp.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.optimization.level.none" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.exe.debug.option.debugging.level.1408142720" name="Debug Level" superClass="gnu.cpp.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.debugging.level.max" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.option.dialect.std.1577870906" name="Language standard" superClass="gnu.cpp.compiler.option.dialect.std" useByScannerDiscovery="true" value="gnu.cpp.compiler.dialect.c++1y" valueType="enumerated"/>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.compiler.input.842239186" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.c.compiler.exe.debug.351478677" name="GCC C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.exe.debug">
+								<option defaultValue="gnu.c.optimization.level.none" id="gnu.c.compiler.exe.debug.option.optimization.level.1879412635" name="Optimization Level" superClass="gnu.c.compiler.exe.debug.option.optimization.level" useByScannerDiscovery="false" valueType="enumerated"/>
+								<option id="gnu.c.compiler.exe.debug.option.debugging.level.648859551" name="Debug Level" superClass="gnu.c.compiler.exe.debug.option.debugging.level" useByScannerDiscovery="false" value="gnu.c.debugging.level.max" valueType="enumerated"/>
+								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.219263748" superClass="cdt.managedbuild.tool.gnu.c.compiler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.c.linker.exe.debug.370219233" name="GCC C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.exe.debug"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug.1321052876" name="GCC C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.exe.debug">
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.libs.311614395" name="Libraries (-l)" superClass="gnu.cpp.link.option.libs" useByScannerDiscovery="false" valueType="libs">
+									<listOptionValue builtIn="false" value="courses"/>
+								</option>
+								<option IS_BUILTIN_EMPTY="false" IS_VALUE_EMPTY="false" id="gnu.cpp.link.option.paths.603027165" name="Library search path (-L)" superClass="gnu.cpp.link.option.paths" useByScannerDiscovery="false" valueType="stringList">
+									<listOptionValue builtIn="false" value="/home/courses/lib"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.linker.input.2141151307" superClass="cdt.managedbuild.tool.gnu.cpp.linker.input">
+									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
+									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
+								</inputType>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.assembler.exe.debug.1455701237" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.exe.debug">
+								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.1492382276" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.archiver.base.1329154531" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.base"/>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="Interpreter-C++.cdt.managedbuild.target.gnu.exe.1148232902" name="Executable (Gnu)" projectType="cdt.managedbuild.target.gnu.exe"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration"/>
+	<storageModule moduleId="refreshScope" versionNumber="2">
+		<configuration configurationName="Debug">
+			<resource resourceType="PROJECT" workspacePath="/Compiler-C++"/>
+		</configuration>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+	<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
+</cproject>
diff --git a/Compiler/.gitignore b/Compiler/.gitignore
new file mode 100644
index 0000000000000000000000000000000000000000..3f41ab15da41e4fbd4b9d23106bccda660f6c1bb
--- /dev/null
+++ b/Compiler/.gitignore
@@ -0,0 +1,8 @@
+*~
+#*#
+cmake-build-debug
+Debug
+.settings
+.idea
+.DS_Store
+Compiler.out
diff --git a/Compiler/.project b/Compiler/.project
new file mode 100644
index 0000000000000000000000000000000000000000..fcf25eff71b070352f4ba0ab857e8c9b49fca63a
--- /dev/null
+++ b/Compiler/.project
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>Compiler-C++</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>make</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<value>${workspace_loc:/Tree-C++/Debug}</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/Compiler/AST.cc b/Compiler/AST.cc
new file mode 100644
index 0000000000000000000000000000000000000000..fd946ffe54ebdaf973c285682036f46ed6f5dbfe
--- /dev/null
+++ b/Compiler/AST.cc
@@ -0,0 +1,242 @@
+#include <hc_list.h>
+#include <hc_list_helpers.h>
+#include "parser.h"  // for n_errors count; this should really be refactored
+#include "streams.h"
+
+using std::string;
+using std::endl;
+using HaverfordCS::list;
+
+
+#include <fstream>  /* needed for ofstream below */
+#if defined TRACE_EXPR_ALLOCATIONS
+static std::ofstream  alloc_trace(TRACE_EXPR_ALLOCATIONS);
+#else
+// by default, allow option for control via environment variable, but it's not given, send to /dev/null (disappears)
+static std::ofstream alloc_trace(getenv("HAVERRACKET_ALLOC_TRACE")?getenv("HAVERRACKET_ALLOC_TRACE"):"/dev/null");
+// static std::ofstream &alloc_trace = trace;  // alternate easy option, just send to regular trace
+#endif
+
+
+
+// This file has the constructors and destructors;
+//   all the generateHERA methods are together in generateHERA.cc
+
+
+// C++ Usage Note:
+// The v(value) is like having v=value, but initializes v rather than assigning to it
+// i.e., writing "v = value" in the constructor _body_ is like writing
+// i.e., writing "v = value" in the constructor _body_ is like writing
+//     int i;
+//     i = 12;
+// whereas writing v(value) before the body is like writing
+//     int i=12;  // i is created with "12" from the start
+//
+// Those steps, as the call(s) to any superclass(es)' constructors, are done before the body of the IntLiteralNode itself
+IntLiteralNode::IntLiteralNode(int value) : v(value)
+{
+	// nothing else needs to be done here, since the stuff above defines "v" as "value"
+	alloc_trace << "(class IntLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
+}
+
+BoolLiteralNode::BoolLiteralNode(string value) : v((value == "#t")? 1 : 0)
+{
+    // nothing else needs to be done here, since the stuff above defines "v" as "value"
+    alloc_trace << "(class BoolLiteralNode constructor called for node at memory " << this << " and value=" << value << endl;
+}
+
+// (so, we should see this trace before the one above, for each int literal node)
+ExprNode::ExprNode()
+{
+	alloc_trace << "[superclass ExprNode constructor  called for node at memory " << this << endl;
+}
+
+ComparisonNode::ComparisonNode(string op, ExprNode *lhs, ExprNode *rhs) :
+	o(op),
+	left(lhs),
+	right(rhs)
+{
+	alloc_trace << "(class ComparisonNode constructor called for node at memory " << this << endl;
+}
+
+ArithmeticNode::ArithmeticNode(string op, list<ExprNode *>operands) :
+	o(op),
+	subexps(operands)
+{
+	alloc_trace << "(class ArithmeticNode constructor called for node at memory " << this << endl;
+}
+
+
+VarUseNode::VarUseNode(string name) : n(name)
+{
+	alloc_trace << "(class     VarUseNode constructor called for node at memory " << this << endl;
+}
+
+CallNode::CallNode(string funcName, HaverfordCS::list<ExprNode *>arguments) :
+	n(funcName),
+	argList(arguments)
+{
+	alloc_trace << "(class       CallNode constructor called for node at memory " << this << endl;
+}
+
+IfNode::IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse) :
+    condition(condition),
+    expriftrue(expriftrue),
+    expriffalse(expriffalse)
+{
+    alloc_trace << "(class IfNode constructor called for node at memory " << this << endl;
+}
+
+LetNode::LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions) :
+        declarations(declarations),
+        expressions(expressions)
+{
+    alloc_trace << "(class LetNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationsNode::DeclarationsNode(HaverfordCS::list<ExprNode *> declarations) :
+        declarations(declarations)
+{
+    alloc_trace << "(class DeclarationsNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType) :
+        variable(variable),
+        intLiteral(intLiteral),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType) :
+        variable(variable),
+        boolLiteral(boolLiteral),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType) :
+        variable(variable),
+        definedVar(definedVar),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+DeclarationNode::DeclarationNode(VarUseNode variable, ExprNode *expr, string declType) :
+        variable(variable),
+        expr(expr),
+        declType(declType)
+{
+    alloc_trace << "(class DeclarationNode constructor called for node at memory " << this << endl;
+}
+
+// C++ Usage notes:
+//   When an object is destroyed, either because it is on the stack, e.g. as a variable,
+//     or because it is on the free-store heap, the _destructor(s)_ for the object,
+//     including those for the superclass(es) and data fields, are called before
+//     the memory for the object is released for potential re-use
+//     (destructors are called for those fields as they are released,
+//     and the superclass destructor is used after the class' own destructor is done).
+//
+//   Note that _pointers_ do not have destructor methods, so while e.g. when a "+" node
+//     goes away, the "string o" data field in the ArithmeticNode will automatically run,
+//     but nothing happens (by default) for the trees _pointed_to_ by "subexps".
+//     (ArithmeticNode's destructor also runs, of course, and so _it_ may take care of subexps)
+
+ExprNode::~ExprNode()  // nothing to do, but this ensures all subclasses will have virtual destructors, which C++ likes
+{
+	alloc_trace << " superclass ExprNode destructor   called for node at memory " << this << "]" << endl;
+}
+
+IntLiteralNode::~IntLiteralNode()
+{
+	alloc_trace << " class IntLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
+	// nothing needs to be done here,
+	//  except for tracing we could have omitted this.
+}
+
+BoolLiteralNode::~BoolLiteralNode()
+{
+    alloc_trace << " class BoolLiteralNode  destructor called for node at memory " << this << " that had value=" << v << ")" << endl;
+    // nothing needs to be done here,
+    //  except for tracing we could have omitted this.
+}
+
+#if FREE_AST_VIA_DESTRUCTORS
+
+// Memory management strategy:
+//   In a _Tree_, we know that any node will have at most one parent.
+//   Since the parser returns a pointer to the _root_,
+//     and no methods give access to any node's child pointers,
+//     we know that, when the root goes away, all the sub-trees can go away too.
+//   So, when the main program "delete"s the root,
+//     that will trigger the root's destructor; if that delete's any tree children,
+//     the whole thing will then be destroyed recursively.
+
+// Note that no destructor is needed for "IntLiteralNode".
+//   It has no subtrees, and data fields go away automatically when the node is deleted
+
+// In contrast, a ComparisonNode has subtree pointers "left" and "right".
+//   When we delete a ComparisonNode, those _pointers_ go away,
+//   but the trees on the free-store heap will last until we delete them.
+//   Since, as noted, we know there are no other pointers to them,
+//   we delete them when the ComparisonNode goes away:
+
+ComparisonNode::~ComparisonNode()
+{
+	alloc_trace << " class ComparisonNode  destructor called for node at memory " << this << ")" << endl;
+
+	delete left;
+	delete right;
+}
+
+void deleteAllSubtrees(list<ExprNode *>subtrees)
+{
+	if (!empty(subtrees)) {
+		delete head(subtrees);
+		deleteAllSubtrees(rest(subtrees));
+	}
+}
+
+ArithmeticNode::~ArithmeticNode()
+{
+	alloc_trace << " class ArithmeticNode  destructor called for node at memory " << this << ")" << endl;
+	
+	deleteAllSubtrees(subexps);
+}
+
+VarUseNode::~VarUseNode()
+{
+	alloc_trace << " class     VarUseNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+CallNode::~CallNode()
+{
+	alloc_trace << " class       CallNode  destructor called for node at memory " << this << ")" << endl;
+	
+	deleteAllSubtrees(argList);
+}
+
+IfNode::~IfNode()
+{
+    alloc_trace << " class     IfNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+LetNode::~LetNode()
+{
+    alloc_trace << " class     LetNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+DeclarationsNode::~DeclarationsNode()
+{
+    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+DeclarationNode::~DeclarationNode()
+{
+    alloc_trace << " class     DeclarationsNode  destructor called for node at memory " << this << ")" << endl;
+}
+
+#endif
diff --git a/Compiler/AST.h b/Compiler/AST.h
new file mode 100644
index 0000000000000000000000000000000000000000..c141d1ca1d54fa3a77ac7a8c4d0441da3b78cdc8
--- /dev/null
+++ b/Compiler/AST.h
@@ -0,0 +1,245 @@
+#ifndef AST_H_
+#define AST_H_
+
+#include <string>
+#include <hc_list.h>
+#include "ContextInfo.h"
+#include "Dictionary.h"
+
+
+/*
+ *  This file defines the heirarchy of different kinds of AST nodes.
+ *  Currently we have:
+ *    ExprNode (an "interface" class for expressions, with the following concrete subclasses ("implementers" of the interface):
+ *	IntLiteralNode(int value)
+ *	ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs)
+ *	ArithmeticNode(std::string op, list<ExprNode *>)
+ *	VarUseNode(std::string name)
+ *	CallNode(std::string name, HaverfordCS::list<ExprNode *>arguments)
+ *
+ *  The "generateHERA" methods are usually called by calling generateFullHERA on the root,
+ *      which puts "CBON" at the start.
+ */
+
+#if ! defined FREE_AST_VIA_DESTRUCTORS
+#define FREE_AST_VIA_DESTRUCTORS true
+#endif
+
+// C++ Usage Note:
+// The empty class definition of ContextInfo below lets us declare "const ContextInfo &" parameters
+//   without having to define the whole class here, which is fine because, at this point,
+//   we don't care much about what's in it ... we just need to know that there's some way
+//   to pass information down to the subtrees as we evaluate them.
+
+
+// Define the information will we need to pass down the tree as we generate code, see ContextInfo.h
+class ContextInfo;
+
+extern Dictionary declarationDict;
+
+// C++ Usage Note:
+//
+// The word "virtual" is needed in C++ when inheritance is use,
+//   to explicitly tell the compiler that we might override a function in a subclass
+// Java has the correct default of allowing this, and the keyword "final" prevents it.
+//   Many C++ compilers fail to complain if you forget the word "virtual" and override a method anyway :-(
+//
+// Putting "= 0" at the end of a virtual function declaration means
+//   that the method _must_ be overridden in subclasses
+//
+// Classes with virtual functions and (in subclasses) data with destructors need to have
+//  virtual destructors, to help the C++ compiler be sure the right data destructors are called
+
+
+// Class ExprNode is an interface that defines the methods that all
+//   expression nodes in our AST will provide
+// C++ does not have Java's "interface" keyword, so instead
+//   we just create a superclass with no data and all functions virtual
+
+class ExprNode {
+public:
+	ExprNode();           // just used for memory allocation labs, to print trace information
+	virtual ~ExprNode();  // used for actual memory allocation, sometimes, and for tracing
+
+    virtual std::string generateHERA(const ContextInfo &info) const = 0;
+    virtual std::string getType() const = 0;
+
+    ExprNode* operator==(ExprNode *other) {
+        this->type = other->type;
+        return this;
+    }
+private:
+    std::string type;
+};
+
+std::string generateFullHERA(ExprNode *presumedRoot);
+
+
+
+// Now, the various specific kinds of expressions we might have:
+
+class IntLiteralNode : public ExprNode {
+	public:
+		IntLiteralNode(int value);
+		~IntLiteralNode();  // just used for trace output
+
+        int getValue() const { return v; }
+        std::string getType() const { return type; }
+
+		std::string generateHERA(const ContextInfo &info) const;
+	private:
+		int v;  // the value
+        const std::string type = "IntLiteralNode";
+};
+
+class BoolLiteralNode : public ExprNode {
+public:
+    BoolLiteralNode(std::string value);
+    ~BoolLiteralNode();  // just used for trace output
+
+    int getValue() const { return v; }
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    int v;  // the value
+    const std::string type = "BoolLiteralNode";
+};
+
+class ComparisonNode : public ExprNode {  // <= etc., _inherently_binary_ in HaverRacket
+public:
+    ComparisonNode(std::string op, ExprNode *lhs, ExprNode *rhs);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~ComparisonNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    std::string o;
+    ExprNode *left;
+    ExprNode *right;
+    const std::string type = "ComparisonNode";
+};
+
+class ArithmeticNode : public ExprNode {  // +, *, -, etc.
+	public:
+		ArithmeticNode(std::string op, HaverfordCS::list<ExprNode *>);
+#if FREE_AST_VIA_DESTRUCTORS
+		~ArithmeticNode();
+#endif
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string o;
+		HaverfordCS::list<ExprNode *>subexps;
+        const std::string type = "ArithmeticNode";
+};
+
+/*
+   This represents the use of an identifier as an expression, e.g. the x in (* x 6).
+   Note that identifiers also exist in variable declarations, e.g. (let ((x 7)) ... )
+     but the x there doesn't count as an _expression_ since we're not asking for its value.
+ */
+class VarUseNode : public ExprNode {
+	public:
+		VarUseNode(std::string name);
+		~VarUseNode();
+
+        std::string getValue() const { return n; }
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string n;
+        const std::string type = "VarUseNode";
+};
+
+
+class CallNode : public ExprNode {
+	public:
+		CallNode(std::string funcName, HaverfordCS::list<ExprNode *>arguments);
+#if FREE_AST_VIA_DESTRUCTORS
+		~CallNode();
+#endif
+        std::string getType() const { return type; }
+
+        std::string generateHERA(const ContextInfo &info) const;
+	private:
+		std::string n;  // the name
+		HaverfordCS::list<ExprNode *>argList;
+        const std::string type = "CallNode";
+};
+
+class IfNode : public ExprNode {
+public:
+    IfNode(ExprNode *condition, ExprNode *expriftrue, ExprNode *expriffalse);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~IfNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    ExprNode *condition;
+    ExprNode *expriftrue;
+    ExprNode *expriffalse;
+    const std::string type = "IfNode";
+};
+
+class DeclarationsNode : public ExprNode {
+public:
+    DeclarationsNode(HaverfordCS::list<ExprNode *> declarations);
+    HaverfordCS::list<ExprNode *> getDeclarations();
+    std::string declarationsHelper(std::string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const;
+#if FREE_AST_VIA_DESTRUCTORS
+    ~DeclarationsNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    HaverfordCS::list<ExprNode *> declarations;
+    const std::string type = "DeclarationsNode";
+};
+
+class DeclarationNode : public ExprNode {
+public:
+    DeclarationNode(VarUseNode variable, IntLiteralNode intLiteral, string declType);
+    DeclarationNode(VarUseNode variable, BoolLiteralNode boolLiteral, string declType);
+    DeclarationNode(VarUseNode variable, VarUseNode definedVar, string declType);
+    DeclarationNode(VarUseNode variable, ExprNode *expr, string declType);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~DeclarationNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+private:
+    VarUseNode variable;
+    VarUseNode definedVar = VarUseNode("defaultVar");
+    std::string declType;
+    IntLiteralNode intLiteral = IntLiteralNode(0);
+    BoolLiteralNode boolLiteral = BoolLiteralNode("#f");
+    ExprNode *expr = new IntLiteralNode(0);
+    const std::string type = "DeclarationNode";
+};
+
+class LetNode : public ExprNode {
+public:
+    LetNode(ExprNode *declarations, HaverfordCS::list<ExprNode *> expressions);
+#if FREE_AST_VIA_DESTRUCTORS
+    ~LetNode();
+#endif
+    std::string getType() const { return type; }
+
+    std::string generateHERA(const ContextInfo &info) const;
+    std::string expressionsHelper(std::string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const;
+    private:
+    ExprNode *declarations;
+    HaverfordCS::list<ExprNode *> expressions;
+    const std::string type = "LetNode";
+};
+
+#endif /*AST_H_*/
diff --git a/Compiler/CMakeLists.txt b/Compiler/CMakeLists.txt
new file mode 100755
index 0000000000000000000000000000000000000000..062dc130adcaafeef166e748f727927ef412fda0
--- /dev/null
+++ b/Compiler/CMakeLists.txt
@@ -0,0 +1,18 @@
+cmake_minimum_required(VERSION 3.1)
+project(Compiler_C++)
+
+set(CMAKE_CXX_STANDARD 20)
+
+add_executable(Compiler_C++
+  scanner-regexp
+  scanner
+  scannerDemo
+  parser
+  AST
+  ContextInfo
+  generateHERA
+  main
+  Dictionary
+)
+
+include_directories(../HaverfordCS/include /home/courses/include)
diff --git a/Compiler/ContextInfo.cc b/Compiler/ContextInfo.cc
new file mode 100644
index 0000000000000000000000000000000000000000..30bffca0697ed8a4f056bf899bbafcae2864f5dc
--- /dev/null
+++ b/Compiler/ContextInfo.cc
@@ -0,0 +1,46 @@
+#include "ContextInfo.h"
+#include <string.h>
+
+// To provide unique register numbers for each subexpression, with leftmost-executed-first
+//   we'll start with 1 at the root, make the rightmost child's number same as its parent,
+//   and make each other child one more than the sibling to its right.
+
+static const int minRegNum= 1;  // Lowest  register number we're going to use
+static const int maxRegNum=10;  // Highest register number we're going to use
+static const char labeler[] = "abcdefghijklmnopqrstuvwxyz";
+std::string label;
+
+ContextInfo::ContextInfo():
+	myRegNumber(maxRegNum)
+{
+}
+
+// Private constructor for use in e.g. evalThisFirst
+ContextInfo::ContextInfo(int r):
+	myRegNumber(r)
+{
+}
+
+ContextInfo ContextInfo::evalThisAfter() const
+{
+	if (myRegNumber <= minRegNum) {
+		throw "Out of register numbers, expression to complicated";
+	}
+	return ContextInfo(this->myRegNumber-1);
+}
+
+std::string ContextInfo::getReg() const
+{
+	return "R"+std::to_string(myRegNumber);
+}
+
+std::string ContextInfo::labelfunc() const
+{
+    std::string label = "";
+    return label + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26] + labeler[random() % 26];
+}
+
+std::string ContextInfo::getLabel() const
+{
+    return label;
+}
diff --git a/Compiler/ContextInfo.h b/Compiler/ContextInfo.h
new file mode 100644
index 0000000000000000000000000000000000000000..7b17f253d940e1e9f8b451530aaf436d4b77c927
--- /dev/null
+++ b/Compiler/ContextInfo.h
@@ -0,0 +1,22 @@
+#include <string>
+#ifndef CONTEXT_INFO
+#define CONTEXT_INFO
+class ContextInfo {
+public:
+	ContextInfo(); // create an empty one, appropriate for the TOP of a parse tree
+
+	ContextInfo evalThisAfter() const; // create another context for something to be evaluated later
+
+	std::string getReg() const;
+	std::string labelfunc() const;
+    std::string getLabel() const;
+private:
+	// "myRegNumber" will tell each expression what register number they should use for their result
+	//  should generally be different for the subexpressions of a node,
+	//  and if X is evalualuated before Y, it should have a higher number.
+
+	ContextInfo(int myRegNum);  // called by e.g. evalThisFirst, to build new contexts
+	int myRegNumber;
+	std::string label = labelfunc();
+};
+#endif //CONTEXT_INFO
\ No newline at end of file
diff --git a/Compiler/Dictionary.cpp b/Compiler/Dictionary.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..6c3416da026a2490ddf986e501ec7c15fee7f317
--- /dev/null
+++ b/Compiler/Dictionary.cpp
@@ -0,0 +1,124 @@
+//
+// Created by Keith_Mburu on 3/15/2021.
+//
+
+#include "Dictionary.h"
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that recurses through dictionary checking for entry
+ *
+ * @return true or false
+ */
+bool Dictionary::containsHelper (const list<pair<string,int>> &dList, const string &entry) {
+    if (empty(dList)) {
+        return false;
+    }
+    else {
+        if ((get<0>(head(dList)) == entry)) {
+            return true;
+        }
+        return containsHelper(rest(dList), entry);
+    }
+}
+
+/**
+ * method that checks if entry is in dictionary
+ *
+ * @return true or false
+ */
+bool Dictionary::contains (const string &entry) {
+    return containsHelper(getList(), entry);
+}
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that recurses through dictionary until it finds and returns integer assigned to entry
+ *
+ * @param entry string being looked up
+ * @param dList dictionary data field
+ * @return the integer
+ */
+int Dictionary::lookupHelper (const list<pair<string,int>> &dList, const string &entry) {
+    if (empty(dList)) {
+        return -1;
+    }
+    else if ((get<0>(head(dList)) == entry)) {
+        return get<1>(head(dList));
+    }
+    return lookupHelper(rest(dList), entry);
+}
+
+/**
+ * method that checks the integer assigned to entry of dictionary
+ *
+ * @param entry string being looked up
+ * @return the integer
+ */
+int Dictionary::lookup (const string &entry) {
+    return lookupHelper(getList(), entry);
+}
+
+/**
+ * method that converts dictionary to the string that constructs it
+ *
+ * @return the string
+ */
+string Dictionary::toCode () {
+    if (empty(dictList)) {
+        return "Dictionary()\n";
+    }
+    list<pair<string, int>> temp = dictList;
+    string dictCode = "Dictionary()";
+    for (int i = 0; i < length(dictList); i++) {
+        // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
+        dictCode = "Dictionary(" + dictCode + ", \"" + get<0>(first(temp)) + "\", " + to_string(get<1>(first(temp))) +
+                ")";
+        temp = rest(temp);
+    }
+    return dictCode;
+}
+
+/**
+ * method that adds new entry to dictionary by constructing new data field
+ *
+ * @param entry string to be added
+ * @param integer integer assigned to the string
+ */
+void Dictionary::add (string entry, int integer) {
+    list<pair<string, int>> newList = list<pair<string, int>>(pair<string, int>(entry, integer), dictList);
+    dictList = newList;
+}
+
+// learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+/**
+ * method that builds new dictionary data field with redefined entry
+ *
+ * @return true if successful
+ */
+bool Dictionary::replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int
+integer) {
+    if (empty(dList)) {
+        // finished recursion, now replace dictionary data field
+        setList(newList);
+        return true;
+    }
+    if ((get<0>(head(dList)) == entry)) {
+        newList = list<pair<string, int>>(pair<string, int>(get<0>(head(dList)), integer), newList);
+        // continue recursing to build the rest of the dictionary
+        return replaceHelper(newList, rest(dList), entry, integer);
+    }
+    newList = list<pair<string, int>>(head(dList), newList);
+    return replaceHelper(newList, rest(dList), entry, integer);
+}
+
+/**
+ * method that replaces the integer assigned to an entry of a dictionary
+ *
+ * @return true if the replacement was successful
+ */
+bool Dictionary::replace (const string &entry, int integer) {
+    replaceHelper(list<pair<string, int>>(), getList(), entry, integer);
+}
+
+
diff --git a/Compiler/Dictionary.h b/Compiler/Dictionary.h
new file mode 100644
index 0000000000000000000000000000000000000000..3696da9d645c34ecf1fbc5f519c9a829818955ce
--- /dev/null
+++ b/Compiler/Dictionary.h
@@ -0,0 +1,101 @@
+//
+// Created by Keith_Mburu on 3/15/2021.
+//
+
+#ifndef DICTIONARY_H
+#define DICTIONARY_H
+
+#include <hc_list.h>
+#include <hc_list_helpers.h>
+#include <utility>
+
+using namespace HaverfordCS;
+using namespace std;
+
+/**
+ * class that instantiates dictionary with string : integer entries
+ *
+ * @author Keith Mburu
+ * @version 3/24/2021
+ */
+class Dictionary {
+
+public:
+
+    /**
+     * constructor method for empty dictionary
+     */
+    Dictionary() {
+        dictList = list<std::pair<string,int>>();
+    }
+
+    /**
+     * constructor method for new dictionary with old dictionary plus new entry
+     *
+     * @param oldDict old dictionary
+     * @param entry string to be added to old dictionary
+     * @param integer integer to be assigned to new entry
+     */
+    Dictionary(const Dictionary &oldDict, const string &entry, const int &integer) {
+        dictList = list<pair<string,int>>(pair<string,int>(entry, integer), oldDict.dictList);
+    }
+
+    /**
+     * getter method for list that stores dictionary data
+     *
+     * @return list that stores dictionary data
+     */
+    list<pair<string,int>> getList() {
+        return dictList;
+    }
+
+    /**
+     * setter method for list that stores dictionary data
+     *
+     * @param newList list to replace dictionary list
+     */
+    void setList(list<pair<string, int>> newList) {
+        dictList = newList;
+    }
+
+    // learnt std::pair get<i>() method from https://en.cppreference.com/w/cpp/utility/pair
+    // learnt to_string for int to string from http://www.cplusplus.com/reference/string/to_string/
+    /**
+     * method that accumulates dictionary entries in string
+     *
+     * @return string containing dictionary entries
+     */
+    string toStringHelper(const list<pair<string,int>> &dictList, string dictString) {
+        if (empty(rest(dictList))) {
+            return dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList)));
+        }
+        dictString += get<0>(head(dictList)) + " : " + to_string(get<1>(head(dictList))) + "\n";
+        return toStringHelper(rest(dictList), dictString);
+    }
+
+    /**
+     * method that represents dictionary as a string
+     *
+     * @return string containing dictionary entries
+     */
+    string toString() {
+        return toStringHelper(getList(), "");
+    }
+
+    // other methods defined in Dictionary.cpp
+    int lookup (const string &entry);
+    int lookupHelper (const list<pair<string,int>> &dList, const string &entry);
+    bool contains (const string &entry);
+    bool containsHelper (const list<pair<string,int>> &dList, const string &entry);
+    void add (string entry, int integer);
+    bool replace (const string &entry, int integer);
+    bool replaceHelper (list<pair<string, int>> newList, list<pair<string,int>> dList, const string &entry, int integer);
+    string toCode ();
+
+private:
+
+    list<pair<string,int>> dictList; // list that stores dictionary data
+
+};
+
+#endif
\ No newline at end of file
diff --git a/Compiler/README-Collaboration.txt b/Compiler/README-Collaboration.txt
new file mode 100644
index 0000000000000000000000000000000000000000..a4d117a958e7f176f9f498aed0dfc60aee767f99
--- /dev/null
+++ b/Compiler/README-Collaboration.txt
@@ -0,0 +1 @@
+Working alone
\ No newline at end of file
diff --git a/Compiler/README-Design.txt b/Compiler/README-Design.txt
new file mode 100644
index 0000000000000000000000000000000000000000..4545104538e0f6df575cb443d81afeccdbcf6821
--- /dev/null
+++ b/Compiler/README-Design.txt
@@ -0,0 +1,16 @@
+PLEASE DO NOT EDIT THIS PRELIMINARY VERISON OF THE FILE, TO AVOID GIT CONFLICTS LATER
+ (if you're working before the update version is available, make a copy and edit that)
+
+Important Design Decisions:
+
+   * Sticking to node-based AST structure
+
+
+Project Status (T = code completed and test suite exists, C = code completed, P = in-progress, N = not started):
+
+   T  Parse + and * operations, constants and identifiers
+   T  Build an Object-Oriented AST from the above
+   T  Appropriately allocate registers for arithmetic operations
+   T  Generate HERA code for +, *, and constants
+
+ ---- more will be added later ----
diff --git a/Compiler/README_Sources.txt b/Compiler/README_Sources.txt
new file mode 100644
index 0000000000000000000000000000000000000000..dcbdecf608edb7dcfa732b27c5506086a27df60d
--- /dev/null
+++ b/Compiler/README_Sources.txt
@@ -0,0 +1 @@
+Copy assignment operators - https://en.cppreference.com/w/cpp/language/copy_assignment
\ No newline at end of file
diff --git a/Compiler/generateHERA.cc b/Compiler/generateHERA.cc
new file mode 100644
index 0000000000000000000000000000000000000000..fd07e5c355fe7202aca4775c9b4e485aeab6ab72
--- /dev/null
+++ b/Compiler/generateHERA.cc
@@ -0,0 +1,238 @@
+#include "AST.h"
+#include "ContextInfo.h"
+#include "hc_list_helpers.h"
+#include "streams.h"
+
+using std::string;
+using std::endl;
+
+Dictionary declarationDict = Dictionary();
+int FPoffset = -1;
+
+std::string generateFullHERA(ExprNode *presumedRoot)
+{
+    return "\nCBON()\n" + presumedRoot->generateHERA(ContextInfo());
+}
+
+string IntLiteralNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered IntLiteralNode::generateHERA for integer " + std::to_string(v) << endl;
+	return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
+}
+
+string BoolLiteralNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered BoolLiteralNode::generateHERA for boolean " + std::to_string(v) << endl;
+    return "SET(" + context.getReg() + ", " + std::to_string(v) + ")\n";
+}
+
+std::string HERA_op(const std::string &AST_op_name)
+{
+	if (AST_op_name == "+") {
+		return "ADD";
+	} else if (AST_op_name == "-") {
+		return "SUB";
+	} else if (AST_op_name == "*") {
+		return "MUL";
+    } else if (AST_op_name == "=") {
+        return "CMP";
+    } else if (AST_op_name == ">=") {
+        return "CMP";
+    } else if (AST_op_name == "<=") {
+        return "CMP";
+	} else {
+		throw "Internal compiler inconsistency/incompleteness: HERA_op not implemented for " + AST_op_name;
+	}
+}
+
+string ComparisonNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered ComparisonNode::generateHERA for comparison " + o << endl;
+
+    // see arithmetic node for more about the "context" stuff:
+    //	trace << "need to compare the result of left-hand-side:\n" << left->generateHERA(context) << endl;
+    //	trace << "                        with right-hand-side:\n" << left->generateHERA(context.evalThisAfter()) << endl;
+
+    if (left->getType() != "CallNode" && right->getType() != "CallNode") {
+        if ((left->getType() != "IntLiteralNode" && left->getType() != "VarUseNode" && left->getType() != "LetNode") ||
+                (right->getType() != "IntLiteralNode" && right->getType() != "VarUseNode" && right->getType() != "LetNode")) {
+            cerr << endl << "!Type error! cannot perform comparison operations on non-integers" << endl;
+            exit(98);
+        }
+    }
+
+    ContextInfo rhsContext = context.evalThisAfter();
+    ContextInfo lhsContext = context;  // just named for symmetry
+
+    ContextInfo labelContext1 = ContextInfo();
+    ContextInfo endLabelContext = ContextInfo();
+
+    return left->generateHERA(lhsContext) +
+           right->generateHERA(rhsContext) +
+           HERA_op(o)+"("+lhsContext.getReg()+", "+rhsContext.getReg()+")\n" +
+           "BZ(" + context.getLabel() + ")\n" +
+            ((o == "=")? "SET(" + context.getReg() + ", " + "0)\n" :
+             (o == "<=" || o == ">=")? "BS(" + labelContext1.getLabel() + ")\n" : "") +
+            ((o == ">=")? "SET(" + context.getReg() + ", " + "1)\n" :
+             (o == "<=")? "SET(" + context.getReg() + ", " + "0)\n" : "") +
+            "BR(" + endLabelContext.getLabel() + ")\n" +
+            "LABEL(" + context.getLabel() + ")\n" +
+            "SET(" + context.getReg() + ", " + "1)\n" +
+            "BR(" + endLabelContext.getLabel() + ")\n" +
+            ((o == "<=" || o == ">=")? ("LABEL(" + labelContext1.getLabel() + ")\n" +
+            ((o == "<=")? "SET(" + context.getReg() + ", " + "1)\n" :
+             "SET(" + context.getReg() + ", " + "0)\n")) : "") +
+             "LABEL(" + endLabelContext.getLabel() + ")\n";
+}
+
+string ArithmeticNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered ArithmeticNode::generateHERA for operator " + o << endl;
+	if (length(subexps) != 2) {
+		throw "compiler incomplete/inconsistent: generateHERA not implemented for non-binary arithmetic";
+	}
+
+    if (first(subexps)->getType() != "CallNode" && first(rest(subexps))->getType() != "CallNode") {
+        if ((first(subexps)->getType() != "IntLiteralNode" && first(subexps)->getType() != "VarUseNode" && first(subexps)->getType() != "LetNode") ||
+                (first(rest(subexps))->getType() != "IntLiteralNode" && first(rest(subexps))->getType() != "VarUseNode" && first(rest(subexps))
+                ->getType() != "LetNode")) {
+            cerr << endl << "!Type error! cannot perform arithmetic operations on non-integers" << endl;
+            exit(99);
+        }
+    }
+
+	ContextInfo rhsContext = context.evalThisAfter();
+	ContextInfo lhsContext = context;  // just named for symmetry
+
+    string leftHERA = first(subexps)->generateHERA(lhsContext);
+    string rightHERA = first(rest(subexps))->generateHERA(rhsContext);
+
+    return  leftHERA + rightHERA + HERA_op(o)+"("+context.getReg()+", "+lhsContext.getReg()+", "+rhsContext.getReg()+")\n";
+}
+
+string VarUseNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered VarUseNode::generateHERA for variable " + n << endl;
+
+    return "LOAD(" + context.getReg() + ", " + to_string(declarationDict.lookup(n)) + ", FP)\n";
+}
+
+string CallNode::generateHERA(const ContextInfo &context) const
+{
+	trace << "Entered CallNode::generateHERA for call to " + n << endl;
+	
+	if (length(argList) != 0 || (n != "exit" && n != "getint")) {
+		throw "compiler incomplete/inconsistent: generateHERA for calls only implented for getint and exit";
+	}
+	// NOTE that calls to exit and getint don't need parameters and don't perturb registers
+	return ("MOVE(FP_alt, SP)\nCALL(FP_alt," + n + ")\n"+
+		(context.getReg()=="R1"?"":"MOVE("+context.getReg()+", R1)\n"));
+}
+
+string IfNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered IfNode::generateHERA" << endl;
+
+    if (expriftrue->getType() != "CallNode" && expriffalse->getType() != "CallNode") {
+        if (expriftrue->getType() != expriffalse->getType()) {
+            cerr << endl << "!Type error! \"then\" and \"else\" statements must be of the same type" << endl;
+            exit(45);
+        }
+    }
+
+    ContextInfo conditionContext = context;
+    ContextInfo expriftrueContext = context.evalThisAfter();
+    ContextInfo expriffalseContext = context.evalThisAfter().evalThisAfter();
+
+    ContextInfo labelContext1 = ContextInfo();
+    ContextInfo labelContext2 = ContextInfo();
+
+    string conditionHERA = condition->generateHERA(conditionContext);
+    string expriftrueHERA = expriftrue->generateHERA(expriftrueContext);
+    string expriffalseHERA = expriffalse->generateHERA(expriffalseContext);
+
+    return  conditionHERA + expriftrueHERA + expriffalseHERA +
+            "FLAGS(" + conditionContext.getReg() + ")\n" +
+            "BZ(" + labelContext1.getLabel() + ")\n" +
+            "MOVE(" + context.getReg() + ", " + expriftrueContext.getReg() + ")\n" +
+            "BR(" + labelContext2.getLabel() + ")\n" +
+            "LABEL(" + labelContext1.getLabel() + ")\n" +
+            "MOVE(" + context.getReg() + ", " + expriffalseContext.getReg() + ")\n" +
+            "LABEL(" + labelContext2.getLabel() + ")\n";
+}
+
+string LetNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered LetNode::generateHERA" << endl;
+    ContextInfo declarationsContext = context;
+    ContextInfo expressionsContext = context;
+
+    string expressionsHERA = "";
+    string declarationsHERA = declarations->generateHERA(declarationsContext);
+    expressionsHERA = expressionsHelper(expressionsHERA, expressions, expressionsContext);
+    return declarationsHERA + expressionsHERA;
+}
+
+string LetNode::expressionsHelper(string expressionsHERA, HaverfordCS::list<ExprNode *> expressions, ContextInfo context) const {
+    if (empty(expressions)) {
+        return expressionsHERA;
+    }
+    return expressionsHelper(expressionsHERA += first(expressions)->generateHERA(context), rest(expressions), context.evalThisAfter());
+}
+
+string DeclarationsNode::generateHERA(const ContextInfo &context) const
+{
+    trace << "Entered DeclarationsNode::generateHERA" << endl;
+    ContextInfo declarationsContext = context;
+
+    ContextInfo labelContext = ContextInfo();
+
+    string declarationsHERA = "";
+    return  declarationsHelper(declarationsHERA, declarations, context);
+}
+
+string DeclarationsNode::declarationsHelper(string declarationsHERA, HaverfordCS::list<ExprNode *> declarations, ContextInfo context) const {
+    if (empty(declarations)) {
+        return declarationsHERA;
+    }
+    return declarationsHelper(declarationsHERA += first(declarations)->generateHERA(context), rest(declarations),
+                              context);
+}
+
+string DeclarationNode::generateHERA(const ContextInfo &context) const
+{
+    auto literal = expr;
+    string value;
+    if (declType == "IntLiteralNode") {
+        *literal = intLiteral;
+        value = to_string(intLiteral.getValue());
+    }
+    else if (declType == "BoolLiteralNode") {
+        *literal = boolLiteral;
+        value = boolLiteral.getValue();
+    }
+    else if (declType == "definedVar") {
+        *literal = definedVar;
+        value = definedVar.getValue();
+    }
+
+    trace << "Entered DeclarationNode::generateHERA for declaration " + variable.getValue() + ((declType == "ExprNode")? " = expression" : " = " +
+    value) << endl;
+
+    if (declType == "definedVar") {
+        value = to_string(declarationDict.lookup(value));
+    }
+
+    FPoffset += 1;
+
+    declarationDict.add(variable.getValue(), FPoffset);
+
+    return ((declType == "ExprNode")? literal->generateHERA(context) :
+           (declType == "definedVar")? "LOAD(" + context.getReg() + ", " + value + ", FP)\n" :
+           "SET(" + context.getReg() + ", " + value + ")\n") +
+           "STORE(" + context.getReg() + ", " + std::to_string(FPoffset) + ", FP)\n";
+}
+
+
+
+
diff --git a/Compiler/main.cc b/Compiler/main.cc
new file mode 100644
index 0000000000000000000000000000000000000000..1c612ebde989904917f118f2dd39f1e20d317dbb
--- /dev/null
+++ b/Compiler/main.cc
@@ -0,0 +1,132 @@
+/*
+ * "Compiler" project for HaverRacket
+ *  Translate a subset of Racket into HERA
+ *
+ * To run this project and run the program tests/01-multiply.hrk, use the command:
+ *   Debug/Compiler-C++ < tests/01-multiply.hrk | tee Compiler.out
+ * and then run the HERA program with the command
+ *   HERA-C-Run Compiler.out
+ */
+
+#include <iostream>
+#include <cstdlib>
+#include "scannerDemo.h"
+#include "parser.h"
+#include "ContextInfo.h"
+#include "hc_list_helpers.h" // ez_list
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+
+#include "streams.h"
+#include "Dictionary.h"
+
+// to change trace output, compile with
+//   e.g. -DTRACE_OUTPUT_HERE="./my-trace-output.txt"
+//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to throw away trace output
+//     or -DTRACE_OUTPUT_HERE="/dev/stderr" # (on linux), to always use cerr
+//     or -DTRACE_OUTPUT_HERE=(getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
+//        # that last, the default (I hope) should allow run-time selection via e.g.,
+//        HAVERRACKET_TRACE=my-trace-output1.txt Debug/Compiler-C++
+//
+//  similarly for -DPROMPT_OUTPUT_HERE, which defaults to getenv("HAVERRACKET_PROMPT")
+//    note that prompt is not currently used, though
+
+#if ! defined TRACE_OUTPUT_HERE
+#define TRACE_OUTPUT_HERE (getenv("HAVERRACKET_TRACE")?getenv("HAVERRACKET_TRACE"):"/dev/stderr")
+#endif
+#if ! defined PROMPT_OUTPUT_HERE
+#define PROMPT_OUTPUT_HERE (getenv("HAVERRACKET_PROMPT")?getenv("HAVERRACKET_PROMPT"):"/dev/stderr")
+#endif
+
+#include <fstream>  /* needed for ofstream below */
+std::ofstream _HaverRacket_trace(TRACE_OUTPUT_HERE);
+std::ostream &trace  = _HaverRacket_trace;
+std::ofstream _HaverRacket_prompt(PROMPT_OUTPUT_HERE);
+std::ostream &prompt = _HaverRacket_prompt;
+
+#if ! defined AbstractSyntaxTest
+#define AbstractSyntaxTest build_example1   /* this lets us use a different test easily with a special command line */
+#endif
+
+ParserResult AbstractSyntaxTest();
+
+int main(int numberOfCommandLineArguments, char *theCommandLineArguments[])
+{
+	try {
+		bool testScannerInstead = false;
+        if (numberOfCommandLineArguments == 2 && theCommandLineArguments[1] == string("testScannerInstead")) {
+			trace << "Testing Scanner instead." << endl;
+			testScannerInstead = true;
+		}
+
+		if (testScannerInstead) {
+			cout << "Demonstrating lexical scanner. Enter tokens followed by <EOF>." << endl;
+			scannerDemo();
+		} else {
+			if (!getenv("HAVERRACKET_TEST_CODE_HERA") ||
+			    getenv("HAVERRACKET_TEST_CODE_HERA") == string("#t"))
+			{
+				try {
+					ParserResult example1 = AbstractSyntaxTest();
+
+					trace << "confirming codegen basic functionality on test example1:" << endl;
+					string code = generateFullHERA(example1);
+					trace << code << endl;
+					delete example1;  // we're done with example1 now.
+
+				} catch (const char *message) {
+					cerr << "code generation confirmation test threw exception: " << message << endl;
+					return 2;
+				}
+			}
+
+            trace << "Type in new input!" << endl;
+
+            try {
+				ParserResult AST = matchStartSymbolAndEOF();
+//				trace << "Completed Parsing, got AST: " << AST.toCode() << endl;
+				try {
+                    trace << "\nNow generating code: " << endl;
+					trace << generateFullHERA(AST) << endl;
+				} catch (const char *message) {
+					cerr << "eval threw exception (typically an unhandled case): " << message << endl;
+					return 4;
+				}
+#if FREE_AST_VIA_DESTRUCTORS
+				delete AST;
+#endif
+			} catch (const char *message) {
+				cerr << "that's odd, parser threw exception: " << message << endl;
+				return 3;
+			}
+		}
+
+		return 0;  // indicate successful translation if no exit with non-0 before this
+	} catch (range_error) {
+		cerr << "Yikes! Uncaught exception" << endl;
+		return 66;
+	}
+}
+
+
+	    
+
+ParserResult build_example1()
+{
+//	ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new IntLiteralNode(3), new IntLiteralNode(7)));
+//    ExprNode *product = new ArithmeticNode("*", HaverfordCS::ez_list<ExprNode *>(new BoolLiteralNode("#t"), new BoolLiteralNode("#f")));
+    ExprNode *product = new IfNode(new ComparisonNode("<=", new IntLiteralNode(6), new IntLiteralNode(7)), new BoolLiteralNode("#t"), new
+    BoolLiteralNode("#f"));
+
+    return product;
+/*
+  NOTE that the starter files ExprNode classes do _not_ support the following due to memory allocation techniques,
+    though it might seem at first to work:
+*/
+	// return new ArithmeticNode("+", HaverfordCS::ez_list<ExprNode *>(product, product));
+	// return new ComparisonNode("<=", product, product);
+}
+
diff --git a/Compiler/parser.cc b/Compiler/parser.cc
new file mode 100644
index 0000000000000000000000000000000000000000..9d33bc188510041ae54ff68d34e4426a99d98e50
--- /dev/null
+++ b/Compiler/parser.cc
@@ -0,0 +1,241 @@
+#include <iostream>
+#include <cstdlib>  // for 'exit' function to abandon the program
+#include <hc_list_helpers.h>
+#include "parser.h"
+#include "scanner.h"
+
+using std::string;
+using HaverfordCS::list;
+using HaverfordCS::ez_list;
+using std::cout;
+using std::cerr;
+using std::endl;
+
+#include "streams.h"
+
+// match this:
+// START -> E   <followed by end-of-input>
+// E -> integer
+// E -> boolean
+// E -> identifier
+// E -> ( E_IN_PARENS )
+// E? -> E E?
+// E? -> ""
+// E_IN_PARENS -> OP E E
+// E_IN_PARENS -> letstar E E E?
+// E_IN_PARENS -> [ E_IN_BRACKETS ] E_IN_PARENS
+// E_IN_PARENS -> ""
+// E_IN_PARENS -> EXIT
+// E_IN_PARENS -> GETINT   // New in this version, gets user input
+// E_IN_PARENS -> if E E E
+
+// E_IN_BRACKETS -> E E
+
+// OP --> +|-|*|<=|=|>= OP_COMPARE
+
+// Declare all functions, so they can call each other in any order
+//  (note: "static" means it's restricted to this scope, e.g. this file
+static ParserResult matchE();
+static ParserResult matchEInParens();
+static string matchOp();
+
+
+// FIRST and FOLLOW sets for those,
+//  built with lists rather than sets, for familiarity
+//  defined in terms of kindOfToken from scanner-regexp.h
+static list<kindOfToken> FIRST_OP  = ez_list(PLUS, MINUS, TIMES, OP_COMPARE);
+static list<kindOfToken> FIRST_EIP = FIRST_OP;
+static list<kindOfToken> FIRST_E   = ez_list(INT_LITERAL, BOOL_LITERAL, IDENTIFIER, LPAREN, LBRACKET);
+
+static list<kindOfToken> FOLLOW_OP  = FIRST_E;
+static list<kindOfToken> FOLLOW_EIP = ez_list(RPAREN);
+static list<kindOfToken> FOLLOW_E   = /* append(FOLLOW_EIP, FIRST_E) */
+		                              list<kindOfToken>(RPAREN, FIRST_E);
+	                                  /* Dave should put "append" into list_helpers */
+
+// first, some helpful functions:
+
+// mustGetNextToken:
+//    we call this when we need to get more input and we must find something there,
+//    i.e. when we want to move current_token along and end-of-input would be an error
+void mustGetNextToken()
+{
+	getNextToken();
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+}
+
+
+// currentTokenThenMove
+//   record currentToken (which must NOT be end-of-input), then move past it, return what it was
+static std::string currentTokenThenMove()
+{
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+	std::string curr = currentToken();
+	getNextToken();
+	return curr;
+}
+
+// confirmLiteral
+//   match a literal, assuming the token HAS been scanned already,
+//    i.e. that "currentToken" is _on_ the literal we wish to match
+//   leave "currentToken" on the very last token of the matched pattern ... this is not a "match" function
+static void confirmLiteral(string what)
+{
+	if (!tokenAvailable()) {
+		cerr << "unexpected end of input at token #" << tokenNumber() << endl;
+		exit(5);
+	}
+	if (currentToken() != what) {
+		cerr << "got " << currentToken() << " instead of " << what << " at token #" << tokenNumber() << endl;
+		exit(2);
+	}	
+}
+
+
+// match an "E", i.e, anything on the right hand side of any "E-->..." production
+//  assume the first token of the E has been scanned
+//   (i.e., assuming currentToken is the first token of the "E" we're matching)
+//  leave "currentToken" AFTER the very last token of the matched pattern
+static ParserResult matchE()
+{
+	trace << "Entering matchE, current token is " << currentToken() << endl;
+	if (currentTokenKind() == INT_LITERAL) {
+        return new IntLiteralNode(std::stoi(currentTokenThenMove()));
+    } else if (currentTokenKind() == BOOL_LITERAL) {
+        return new BoolLiteralNode(currentTokenThenMove());
+	} else if (currentTokenKind() == IDENTIFIER) {
+        return new VarUseNode(currentTokenThenMove());
+	} else if (currentTokenKind() == LPAREN) {	
+		confirmLiteral("(");
+		mustGetNextToken();
+		ParserResult it = matchEInParens();
+		trace << "After matchEInParens, back in matchE, current token is: " << currentToken() << endl;
+		// if that left off AFTER the end of the E_IN_PARENS, we still need a ")" in the E we're matching
+		confirmLiteral(")");
+		getNextToken();	 // we're AFTER the ) now
+		return it;
+	} else {				
+		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+		exit(3);
+	}
+}
+
+// match an "E_IN_PARENS",
+//  assuming that the currentToken is at the start of the E_IN_PARENS, e.g. a "+"
+//  leave the currentToken AFTER the last part of what was matched,
+//  i.e. *on* the ")" that should come after the E_IN_PARENS
+static ParserResult matchEInParens() {
+	trace << "Entering matchEInParens, current token is " << currentToken() << endl;
+	if (find(currentTokenKind(), FIRST_OP)) {
+        bool its_a_comparison_op = (currentTokenKind() == OP_COMPARE);
+        string theOp = matchOp();
+        ParserResult firstChild = matchE();
+        ParserResult secondChild = matchE();
+        if (its_a_comparison_op) { // a comparison
+            return new ComparisonNode(theOp, firstChild, secondChild);
+        } else {
+            return new ArithmeticNode(theOp, ez_list(firstChild, secondChild));
+        }
+    } else if (currentTokenKind() == LBRACKET) {
+        list<ExprNode *> declarations = list<ExprNode *>();
+	    while (currentTokenKind() != RPAREN) {
+            mustGetNextToken();
+            declarations = list(matchEinBrackets(), declarations);
+            confirmLiteral("]");
+            mustGetNextToken();
+        }
+	    return new DeclarationsNode(reverse(declarations, list<ExprNode *>()));
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "if") {
+	    mustGetNextToken();
+	    ParserResult condition = matchE();
+        ParserResult expriftrue = matchE();
+        ParserResult expriffalse = matchE();
+        return new IfNode(condition, expriftrue, expriffalse);
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "letstar") {
+        mustGetNextToken();
+        ParserResult declarations = matchE();
+        list<ExprNode *> expressions = list<ExprNode *>();
+        while (currentToken() != ")") {
+            expressions = list(matchE(), expressions);
+        }
+	    return new LetNode(declarations, reverse(expressions, list<ExprNode *>()));
+    } else if (currentTokenKind() == IDENTIFIER && currentToken() == "exit") {
+		return new CallNode(currentTokenThenMove(), list<ParserResult>());
+	} else if (currentTokenKind() == IDENTIFIER && currentToken() == "getint") {
+		return new CallNode(currentTokenThenMove(), list<ParserResult>());
+	} else {
+		std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+		exit(3);
+	}
+}
+
+static ParserResult matchEinBrackets() {
+    if (currentTokenKind() == IDENTIFIER) {
+        VarUseNode variable = VarUseNode(currentTokenThenMove());
+        if (currentTokenKind() == IDENTIFIER) {
+            VarUseNode definedVar = VarUseNode(currentTokenThenMove());
+            return new DeclarationNode(variable, definedVar, "definedVar");
+        }
+        else if (currentTokenKind() == INT_LITERAL) {
+            IntLiteralNode literal = IntLiteralNode(stoi(currentTokenThenMove()));
+            return new DeclarationNode(variable, literal, "IntLiteralNode");
+        }
+        else if (currentTokenKind() == BOOL_LITERAL) {
+            BoolLiteralNode literal = BoolLiteralNode(currentTokenThenMove());
+            return new DeclarationNode(variable, literal, "BoolLiteralNode");
+        }
+        else if (currentTokenKind() == LPAREN) {
+            ParserResult expr = matchE();
+            return new DeclarationNode(variable, expr, "ExprNode");
+        }
+    }
+    std::cerr << "Illegal token (" << currentToken() << ") at token #" << tokenNumber() << endl;
+    exit(3);
+}
+
+// match an operator, assuming that it is the currentToken
+//  leave the currentToken AFTER the last part of what was matched, i.e. unchanged
+static string matchOp()
+{
+	trace << "Entering matchOp, current token is " << currentToken() << endl;
+	// could do three cases here, but that's so tedious...
+	assert (find(currentTokenKind(), FIRST_OP));
+	return currentTokenThenMove();
+}
+
+
+ParserResult matchStartSymbolAndEOF()
+{
+	getNextToken();  // this will be the first one
+	if (!tokenAvailable()) {
+		cerr << "Illegal end of input" << endl;
+		exit(2);
+	}
+
+	ParserResult fullExpression = matchE();  // "E" is our start symbol
+
+	// now make sure there isn't anything else!
+	getNextToken();
+	if (tokenAvailable()) {
+		cerr << "Warning: extra input after end: " << currentToken() << endl;
+		exit (1);
+	}
+
+	return fullExpression;
+}
+
+list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList) {
+    if (empty(list)) {
+        return newList;
+    }
+    if (length(list) == 1) {
+        return ::list(first(list), newList);
+    }
+    return reverse(rest(list), ::list(first(list), newList));
+}
\ No newline at end of file
diff --git a/Compiler/parser.h b/Compiler/parser.h
new file mode 100644
index 0000000000000000000000000000000000000000..15ffe20d1b1c102d511f9bad3e92f9cd7ee846ef
--- /dev/null
+++ b/Compiler/parser.h
@@ -0,0 +1,18 @@
+#ifndef PARSER_H_
+#define PARSER_H_
+
+
+#include "AST.h"
+
+// The typedef below makes the name "translatedResult"
+//  mean a "Tree" object from our Expr_Node type heirarchy.
+typedef ExprNode *ParserResult;
+
+ParserResult matchStartSymbolAndEOF();
+static ParserResult matchE();
+static ParserResult matchEinParens();
+static ParserResult matchEinBrackets();
+static std::string matchOp();
+list<ExprNode *> reverse(list<ExprNode *> list, ::list<ExprNode *> newList);
+
+#endif /*PARSER_H_*/
diff --git a/Compiler/scanner-regexp.cc b/Compiler/scanner-regexp.cc
new file mode 100644
index 0000000000000000000000000000000000000000..b7ad7688e6baab205aa96ba07e3ab106334e876a
--- /dev/null
+++ b/Compiler/scanner-regexp.cc
@@ -0,0 +1,1871 @@
+
+#line 2 "<stdout>"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 4
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* begin standard C++ headers. */
+
+/* TODO: this is always defined, so inline it */
+#define yyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
+#else
+#define yynoreturn
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
+ */
+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin  )
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+    
+    #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	int yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = NULL;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart ( FILE *input_file  );
+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
+void yy_delete_buffer ( YY_BUFFER_STATE b  );
+void yy_flush_buffer ( YY_BUFFER_STATE b  );
+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state ( void );
+
+static void yyensure_buffer_stack ( void );
+static void yy_load_buffer_state ( void );
+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
+
+void *yyalloc ( yy_size_t  );
+void *yyrealloc ( void *, yy_size_t  );
+void yyfree ( void *  );
+
+#define yy_new_buffer yy_create_buffer
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+typedef flex_uint8_t YY_CHAR;
+
+FILE *yyin = NULL, *yyout = NULL;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+int yylineno = 1;
+
+extern char *yytext;
+#ifdef yytext_ptr
+#undef yytext_ptr
+#endif
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state ( void );
+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
+static int yy_get_next_buffer ( void );
+static void yynoreturn yy_fatal_error ( const char* msg  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+#define YY_NUM_RULES 19
+#define YY_END_OF_BUFFER 20
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static const flex_int16_t yy_accept[33] =
+    {   0,
+        0,    0,   20,   18,    1,    2,    2,   18,    4,    5,
+       10,    8,    9,   15,    3,   18,   11,   18,   17,    6,
+        7,   16,   15,    3,   12,    0,   13,   17,    0,    0,
+       14,    0
+    } ;
+
+static const YY_CHAR yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    5,    1,    1,    1,    1,    6,
+        7,    8,    9,    1,   10,    1,    1,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,    1,   12,   13,
+       14,   15,    1,    1,   16,   16,   16,   16,   17,   18,
+       16,   16,   16,   16,   16,   16,   16,   16,   19,   16,
+       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
+       20,    1,   21,    1,   22,    1,   23,   23,   23,   23,
+
+       23,   24,   23,   23,   23,   23,   23,   23,   23,   23,
+       23,   23,   23,   23,   23,   25,   23,   23,   23,   23,
+       23,   23,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static const YY_CHAR yy_meta[26] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        3,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    3,    3,    3
+    } ;
+
+static const flex_int16_t yy_base[35] =
+    {   0,
+        0,    0,   40,   41,   41,   41,   41,    2,   41,   41,
+       41,   41,   28,   27,    0,   14,   41,   23,    0,   41,
+       41,   41,   25,    0,   41,   16,   41,    0,   15,   15,
+       41,   41,   31,   26
+    } ;
+
+static const flex_int16_t yy_def[35] =
+    {   0,
+       32,    1,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   33,   32,   32,   32,   34,   32,
+       32,   32,   32,   33,   32,   32,   32,   34,   32,   32,
+       32,    0,   32,   32
+    } ;
+
+static const flex_int16_t yy_nxt[67] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,   15,   16,   17,   18,   19,   19,   19,   19,   20,
+       21,    4,   19,   19,   19,   22,   22,   25,   28,   31,
+       26,   24,   30,   24,   29,   23,   27,   23,   23,   32,
+        3,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32
+    } ;
+
+static const flex_int16_t yy_chk[67] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    8,    8,   16,   34,   30,
+       16,   33,   29,   33,   26,   23,   18,   14,   13,    3,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "scanner-regexp.l"
+#line 2 "scanner-regexp.l"
+/*
+
+   This is a lexical scanner specification for the "lex" (or "flex") language.
+   It can be translated into a "C++" file by running, in the project directory, the command
+
+    flex  -t scanner-regexp.l > scanner-regexp.cc
+
+
+   In this first section of the lex file (between %{ and %}),
+   we define C++ functions that will be used later in the actions of part 3.
+
+*/
+
+#include "scanner-regexp.h"
+
+// the code generated by the flex system requires we write this:
+extern "C" int yywrap()
+{
+ return 1;
+}
+
+#line 484 "<stdout>"
+/* In this second section of the lex file (after the %}),
+   we can define variables in terms of regular expressions.
+   C-style comments (like this one) are also legal. */
+/* In the third section of the lex file (after the %%),
+   we can define the patterns for each token
+   in terms of regular expressions and the variables above,
+   and give the action (as C++ code) for each token.
+   Comments are legal only inside the actions. */
+#line 493 "<stdout>"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals ( void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy ( void );
+
+int yyget_debug ( void );
+
+void yyset_debug ( int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra ( void );
+
+void yyset_extra ( YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in ( void );
+
+void yyset_in  ( FILE * _in_str  );
+
+FILE *yyget_out ( void );
+
+void yyset_out  ( FILE * _out_str  );
+
+			int yyget_leng ( void );
+
+char *yyget_text ( void );
+
+int yyget_lineno ( void );
+
+void yyset_lineno ( int _line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap ( void );
+#else
+extern int yywrap ( void );
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+    
+    static void yyunput ( int c, char *buf_ptr  );
+    
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy ( char *, const char *, int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen ( const char * );
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput ( void );
+#else
+static int input ( void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK /*LINTED*/break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
+    
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state(  );
+		}
+
+	{
+#line 38 "scanner-regexp.l"
+
+
+#line 713 "<stdout>"
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 33 )
+					yy_c = yy_meta[yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 41 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 40 "scanner-regexp.l"
+{ continue; }  /* do nothing with blank spaces */
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 41 "scanner-regexp.l"
+{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 42 "scanner-regexp.l"
+{ continue; }  /* treat comments like other blank space */
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 44 "scanner-regexp.l"
+{ tokenCount++; return LPAREN; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 45 "scanner-regexp.l"
+{ tokenCount++; return RPAREN; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 46 "scanner-regexp.l"
+{ tokenCount++; return LBRACKET; }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 47 "scanner-regexp.l"
+{ tokenCount++; return RBRACKET; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 48 "scanner-regexp.l"
+{ tokenCount++; return PLUS; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 49 "scanner-regexp.l"
+{ tokenCount++; return MINUS; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 50 "scanner-regexp.l"
+{ tokenCount++; return TIMES; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 51 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 52 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 53 "scanner-regexp.l"
+{ tokenCount++; return OP_COMPARE; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 55 "scanner-regexp.l"
+{ tokenCount++; return END_OF_INPUT; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 57 "scanner-regexp.l"
+{ tokenCount++; return INT_LITERAL; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 58 "scanner-regexp.l"
+{ tokenCount++; return BOOL_LITERAL; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 60 "scanner-regexp.l"
+{ tokenCount++; return IDENTIFIER; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 62 "scanner-regexp.l"
+{ scannerError(); continue; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 63 "scanner-regexp.l"
+ECHO;
+	YY_BREAK
+#line 866 "<stdout>"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap(  ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of user's declarations */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = (yytext_ptr);
+	int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc( (void *) b->yy_ch_buf,
+							 (yy_size_t) (b->yy_buf_size + 2)  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = NULL;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
+			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	yy_state_type yy_current_state;
+	char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 33 )
+				yy_c = yy_meta[yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	int yy_is_jam;
+    	char *yy_cp = (yy_c_buf_p);
+
+	YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 33 )
+			yy_c = yy_meta[yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+	yy_is_jam = (yy_current_state == 32);
+
+		return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_UNPUT
+
+    static void yyunput (int c, char * yy_bp )
+{
+	char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		int number_to_move = (yy_n_chars) + 2;
+		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap(  ) )
+						return 0;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer( yyin, YY_BUF_SIZE );
+	}
+
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state(  );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree( (void *) b->yy_ch_buf  );
+
+	yyfree( (void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state(  );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state(  );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state(  );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	yy_size_t num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return NULL;
+
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = NULL;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (const char * yystr )
+{
+    
+	return yy_scan_bytes( yystr, (int) strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = (yy_size_t) (_yybytes_len + 2);
+	buf = (char *) yyalloc( n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yynoreturn yy_fatal_error (const char* msg )
+{
+			fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+    
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param _line_number line number
+ * 
+ */
+void yyset_lineno (int  _line_number )
+{
+    
+    yylineno = _line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param _in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  _in_str )
+{
+        yyin = _in_str ;
+}
+
+void yyset_out (FILE *  _out_str )
+{
+        yyout = _out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  _bdebug )
+{
+        yy_flex_debug = _bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = NULL;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = NULL;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = NULL;
+    yyout = NULL;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, const char * s2, int n )
+{
+		
+	int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (const char * s )
+{
+	int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+			return malloc(size);
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+		
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return realloc(ptr, size);
+}
+
+void yyfree (void * ptr )
+{
+			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 63 "scanner-regexp.l"
diff --git a/Compiler/scanner-regexp.h b/Compiler/scanner-regexp.h
new file mode 100644
index 0000000000000000000000000000000000000000..5fa81c7468cafb661690537bdcabda0390bf56a7
--- /dev/null
+++ b/Compiler/scanner-regexp.h
@@ -0,0 +1,13 @@
+enum kindOfToken {
+	END_OF_INPUT = 0,   // defined by flex system
+	LPAREN,	RPAREN,
+	PLUS,	MINUS,	TIMES,
+	OP_COMPARE,
+	INT_LITERAL, BOOL_LITERAL,
+	IDENTIFIER, LBRACKET,
+	RBRACKET
+};
+
+void scannerError(); /// define in whatever uses the regexp-based scanner
+
+extern int tokenCount;  // not static because the .l file needs it too
diff --git a/Compiler/scanner-regexp.l b/Compiler/scanner-regexp.l
new file mode 100644
index 0000000000000000000000000000000000000000..f8a896b4eecb04d6369f19286b40cb45f4ec73b3
--- /dev/null
+++ b/Compiler/scanner-regexp.l
@@ -0,0 +1,62 @@
+%{
+/*
+
+   This is a lexical scanner specification for the "lex" (or "flex") language.
+   It can be translated into a "C++" file by running, in the project directory, the command
+
+    flex  -t scanner-regexp.l > scanner-regexp.cc
+
+
+   In this first section of the lex file (between %{ and %}),
+   we define C++ functions that will be used later in the actions of part 3.
+
+*/
+
+#include "scanner-regexp.h"
+
+// the code generated by the flex system requires we write this:
+extern "C" int yywrap()
+{
+ return 1;
+}
+
+%}
+
+/* In this second section of the lex file (after the %}),
+   we can define variables in terms of regular expressions.
+   C-style comments (like this one) are also legal. */
+
+digit		[0-9]
+identifier	[a-zA-Z][a-z0-9_]*
+
+/* In the third section of the lex file (after the %%),
+   we can define the patterns for each token
+   in terms of regular expressions and the variables above,
+   and give the action (as C++ code) for each token.
+   Comments are legal only inside the actions. */
+
+%%
+
+[ \t]		{ continue; }  /* do nothing with blank spaces */
+[\n\r]		{ continue; }  /* allow MacOS \r as well as \n  -- may double-count in MS Windows */
+\;.*		{ continue; }  /* treat comments like other blank space */
+
+"("			{ tokenCount++; return LPAREN; }
+")"			{ tokenCount++; return RPAREN; }
+"["			{ tokenCount++; return LBRACKET; }
+"]"			{ tokenCount++; return RBRACKET; }
+"+"			{ tokenCount++; return PLUS; }
+"-"			{ tokenCount++; return MINUS; }
+"*"			{ tokenCount++; return TIMES; }
+"="			{ tokenCount++; return OP_COMPARE; }
+"<="			{ tokenCount++; return OP_COMPARE; }
+">="			{ tokenCount++; return OP_COMPARE; }
+
+"<EOF>"		{ tokenCount++; return END_OF_INPUT; }
+
+-?{digit}+	  { tokenCount++; return INT_LITERAL; }
+(#t|#f)	  { tokenCount++; return BOOL_LITERAL; }
+
+{identifier}  { tokenCount++; return IDENTIFIER; }
+
+.			{ scannerError(); continue; }
diff --git a/Compiler/scanner.cc b/Compiler/scanner.cc
new file mode 100644
index 0000000000000000000000000000000000000000..6914da3cb3772f259411ae765eb35f0dc8d6517b
--- /dev/null
+++ b/Compiler/scanner.cc
@@ -0,0 +1,82 @@
+#include <iostream>
+#include <logic.h>
+#include "scanner.h"
+
+#if ! defined USE_YYLEX
+#define USE_YYLEX 1  /* Use the stuff from scanner-regexp.l by default */
+#endif
+
+using namespace std;
+
+int tokenCount = 0;  // not static because the .l file needs it too
+static bool endOfInput = false;
+static bool calledGetNextTokenAlready = false;
+static string current = "";
+static kindOfToken currentKind;
+
+// some things built into scanner-regexp.cc by the flex system:
+extern int yylex();
+extern char *yytext;  // C-style string
+
+
+string currentToken()
+{
+	precondition(calledGetNextTokenAlready);
+	precondition(tokenAvailable());
+	
+	return current;
+}
+enum kindOfToken currentTokenKind()
+{
+	precondition(calledGetNextTokenAlready);
+	precondition(tokenAvailable());
+
+	return currentKind;
+}
+
+bool tokenAvailable()
+{
+	precondition(calledGetNextTokenAlready);
+	
+	return !endOfInput;
+}
+
+int  tokenNumber()
+{
+	return tokenCount;
+}
+
+void getNextToken()
+{
+	if (calledGetNextTokenAlready && endOfInput) return;  // No soup for you!
+	
+	calledGetNextTokenAlready = true;
+#if USE_YYLEX
+	/// This interfaces with scanner-regexp.cc
+	/// remember to update it from scanner-regexp.l if that is changed!
+	currentKind = kindOfToken(yylex()); // yylex thinks it could return any int but we know better
+	if (currentKind == 0) {
+		endOfInput = true;
+		current      = "";
+	} else {
+		current      = yytext;
+	}
+#else
+	/// HERE IS THE OLD CODE, before I tried lex
+	if (endOfInput || !cin) {
+		endOfInput = true;
+	} else {
+		cin >> current;
+		if (cin && current != "<EOF>") {
+			tokenCount++;
+		} else {
+			endOfInput = true;
+		}
+	}
+#endif
+}
+
+void scannerError()
+{
+	cerr << "Error: illegal token: '" << yytext << "'\n";
+}
diff --git a/Compiler/scanner.h b/Compiler/scanner.h
new file mode 100644
index 0000000000000000000000000000000000000000..4f5e847c7e37bc31c039d0689e8a4d61aa8e61da
--- /dev/null
+++ b/Compiler/scanner.h
@@ -0,0 +1,27 @@
+#ifndef _SCANNER_H_
+#define _SCANNER_H_
+
+#include <string>
+#include "scanner-regexp.h"
+
+// A simple lexical scanner
+
+// return the current token
+//  precondition:     you have called getNextToken at least once
+//                and tokenAvialable did not return false
+std::string currentToken();
+enum kindOfToken currentTokenKind();
+
+// see if there is a token (return false for end-of-input or the special input <EOF>)
+//  precondition: you must have called getNextToken at least once
+bool tokenAvailable();
+
+// return the number of tokens scanned so far
+// precondition: true
+int  tokenNumber();
+
+// advance current token to the next input
+// precondition: true
+void getNextToken();
+
+#endif //_SCANNER_H_
diff --git a/Compiler/scannerDemo.cc b/Compiler/scannerDemo.cc
new file mode 100644
index 0000000000000000000000000000000000000000..208c53d98c9e7123e7d493a23ac1b672511904a1
--- /dev/null
+++ b/Compiler/scannerDemo.cc
@@ -0,0 +1,16 @@
+#include <iostream>
+#include "scanner.h"
+#include "scannerDemo.h"
+
+using std::cout;
+using std::endl;
+
+void scannerDemo()
+{
+	while (getNextToken(), tokenAvailable()) {
+		cout << "Token number " << tokenNumber() << " is ";
+		cout << "'" << currentToken() << "'";
+		cout << ", which is token kind " << kindOfToken(currentTokenKind()) << endl;
+	}
+	cout << "Reached end-of-file, now stopping!" << endl;
+}
diff --git a/Compiler/scannerDemo.h b/Compiler/scannerDemo.h
new file mode 100644
index 0000000000000000000000000000000000000000..7a767af034dc466d09612dc1c35e571617d4b380
--- /dev/null
+++ b/Compiler/scannerDemo.h
@@ -0,0 +1,13 @@
+/*
+ * scanner_demo.h
+ *
+ *  Created on: Oct 2, 2009
+ *      Author: davew
+ */
+
+#ifndef SCANNER_DEMO_H_
+#define SCANNER_DEMO_H_
+
+void scannerDemo();
+
+#endif /* SCANNER_DEMO_H_ */
diff --git a/Compiler/streams.h b/Compiler/streams.h
new file mode 100644
index 0000000000000000000000000000000000000000..7fb6c59e608e66bc3c4191565ad9e58c63ec9bb3
--- /dev/null
+++ b/Compiler/streams.h
@@ -0,0 +1,3 @@
+extern std::ostream &trace;
+extern std::ostream &prompt;
+// extern std::ostream &debug;  // could separate these if we had a reason to do so...
diff --git a/Compiler/tests/01-multiply.hrk b/Compiler/tests/01-multiply.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..93a3f65ef3836c85fd496c0688b7ac5ff194d3f8
--- /dev/null
+++ b/Compiler/tests/01-multiply.hrk
@@ -0,0 +1 @@
+(* 6 7)
diff --git a/Compiler/tests/02-add-and-mult.hrk b/Compiler/tests/02-add-and-mult.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..f35212807441cfcf33303be75c979f77563f03d1
--- /dev/null
+++ b/Compiler/tests/02-add-and-mult.hrk
@@ -0,0 +1 @@
+(* (+ 2 5) (+ (+ 1 (* 2 1)) (+ 2 1)))
diff --git a/Compiler/tests/03-mult-input.hrk b/Compiler/tests/03-mult-input.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..06969783b8af0aba0d6bf02916955cdbb0cdb750
--- /dev/null
+++ b/Compiler/tests/03-mult-input.hrk
@@ -0,0 +1 @@
+(* 3 (getint))
diff --git a/Compiler/tests/04-mult-exit.hrk b/Compiler/tests/04-mult-exit.hrk
new file mode 100644
index 0000000000000000000000000000000000000000..7de54e54bb3b816fff8e9c3d353e35c6dbc78f48
--- /dev/null
+++ b/Compiler/tests/04-mult-exit.hrk
@@ -0,0 +1 @@
+(* 3 (exit))
diff --git a/Compiler/tests/arithmetic or comparison operation type error.txt b/Compiler/tests/arithmetic or comparison operation type error.txt
new file mode 100644
index 0000000000000000000000000000000000000000..74171143e261de0bc3b254b650af40c193bedf3e
--- /dev/null
+++ b/Compiler/tests/arithmetic or comparison operation type error.txt	
@@ -0,0 +1 @@
+( <= 4 #f ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/comparison.txt b/Compiler/tests/comparison.txt
new file mode 100644
index 0000000000000000000000000000000000000000..8bdf47dbd9ea3f0bc1319e04feb58aee6c3ce058
--- /dev/null
+++ b/Compiler/tests/comparison.txt
@@ -0,0 +1 @@
+( <= 4 5 ) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if type error.txt b/Compiler/tests/if type error.txt
new file mode 100644
index 0000000000000000000000000000000000000000..60dca31173babb20287ac03e8cda9f9669101989
--- /dev/null
+++ b/Compiler/tests/if type error.txt	
@@ -0,0 +1 @@
+(if #t 3 h) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/if.txt b/Compiler/tests/if.txt
new file mode 100644
index 0000000000000000000000000000000000000000..0fbbcb19e4e2929c3eaa6d30d03260f63901f1bb
--- /dev/null
+++ b/Compiler/tests/if.txt
@@ -0,0 +1 @@
+(if #t (if #f 2 3) (if #t 4 5)) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/let.txt b/Compiler/tests/let.txt
new file mode 100644
index 0000000000000000000000000000000000000000..3fe340a7484f889f26288b6a1175d4a6373d5e93
--- /dev/null
+++ b/Compiler/tests/let.txt
@@ -0,0 +1 @@
+(+ (letstar ( [x 1] [y 2] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/letstar.txt b/Compiler/tests/letstar.txt
new file mode 100644
index 0000000000000000000000000000000000000000..366eb923d0f93ca9fdb2006108e0a168112eb779
--- /dev/null
+++ b/Compiler/tests/letstar.txt
@@ -0,0 +1 @@
+(+ (letstar ( [x 3] [y x] ) (+ y x) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested let.txt b/Compiler/tests/nested let.txt
new file mode 100644
index 0000000000000000000000000000000000000000..17e52566013a6c055a7c8ad9fbb3ae9b235f7ece
--- /dev/null
+++ b/Compiler/tests/nested let.txt	
@@ -0,0 +1 @@
+(+ (letstar ( [x 1] [y 2] ) (+ x (letstar ( [z 3] [y 4] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file
diff --git a/Compiler/tests/nested letstar.txt b/Compiler/tests/nested letstar.txt
new file mode 100644
index 0000000000000000000000000000000000000000..8808cc7ddf8d4f32094aa7e973959b70d9441474
--- /dev/null
+++ b/Compiler/tests/nested letstar.txt	
@@ -0,0 +1 @@
+(+ (letstar ( [x 4] [y 2] ) (+ x (letstar ( [z y] [y x] ) (+ y z))) ) 31) <EOF>
\ No newline at end of file
